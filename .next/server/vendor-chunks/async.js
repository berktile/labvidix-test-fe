"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/async";
exports.ids = ["vendor-chunks/async"];
exports.modules = {

/***/ "(ssr)/./node_modules/async/dist/async.mjs":
/*!*******************************************!*\
  !*** ./node_modules/async/dist/async.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   all: () => (/* binding */ every$1),\n/* harmony export */   allLimit: () => (/* binding */ everyLimit$1),\n/* harmony export */   allSeries: () => (/* binding */ everySeries$1),\n/* harmony export */   any: () => (/* binding */ some$1),\n/* harmony export */   anyLimit: () => (/* binding */ someLimit$1),\n/* harmony export */   anySeries: () => (/* binding */ someSeries$1),\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   applyEach: () => (/* binding */ applyEach),\n/* harmony export */   applyEachSeries: () => (/* binding */ applyEachSeries),\n/* harmony export */   asyncify: () => (/* binding */ asyncify),\n/* harmony export */   auto: () => (/* binding */ auto),\n/* harmony export */   autoInject: () => (/* binding */ autoInject),\n/* harmony export */   cargo: () => (/* binding */ cargo$1),\n/* harmony export */   cargoQueue: () => (/* binding */ cargo),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   concat: () => (/* binding */ concat$1),\n/* harmony export */   concatLimit: () => (/* binding */ concatLimit$1),\n/* harmony export */   concatSeries: () => (/* binding */ concatSeries$1),\n/* harmony export */   constant: () => (/* binding */ constant$1),\n/* harmony export */   \"default\": () => (/* binding */ index),\n/* harmony export */   detect: () => (/* binding */ detect$1),\n/* harmony export */   detectLimit: () => (/* binding */ detectLimit$1),\n/* harmony export */   detectSeries: () => (/* binding */ detectSeries$1),\n/* harmony export */   dir: () => (/* binding */ dir),\n/* harmony export */   doDuring: () => (/* binding */ doWhilst$1),\n/* harmony export */   doUntil: () => (/* binding */ doUntil),\n/* harmony export */   doWhilst: () => (/* binding */ doWhilst$1),\n/* harmony export */   during: () => (/* binding */ whilst$1),\n/* harmony export */   each: () => (/* binding */ each),\n/* harmony export */   eachLimit: () => (/* binding */ eachLimit$1),\n/* harmony export */   eachOf: () => (/* binding */ eachOf$1),\n/* harmony export */   eachOfLimit: () => (/* binding */ eachOfLimit$1),\n/* harmony export */   eachOfSeries: () => (/* binding */ eachOfSeries$1),\n/* harmony export */   eachSeries: () => (/* binding */ eachSeries$1),\n/* harmony export */   ensureAsync: () => (/* binding */ ensureAsync),\n/* harmony export */   every: () => (/* binding */ every$1),\n/* harmony export */   everyLimit: () => (/* binding */ everyLimit$1),\n/* harmony export */   everySeries: () => (/* binding */ everySeries$1),\n/* harmony export */   filter: () => (/* binding */ filter$1),\n/* harmony export */   filterLimit: () => (/* binding */ filterLimit$1),\n/* harmony export */   filterSeries: () => (/* binding */ filterSeries$1),\n/* harmony export */   find: () => (/* binding */ detect$1),\n/* harmony export */   findLimit: () => (/* binding */ detectLimit$1),\n/* harmony export */   findSeries: () => (/* binding */ detectSeries$1),\n/* harmony export */   flatMap: () => (/* binding */ concat$1),\n/* harmony export */   flatMapLimit: () => (/* binding */ concatLimit$1),\n/* harmony export */   flatMapSeries: () => (/* binding */ concatSeries$1),\n/* harmony export */   foldl: () => (/* binding */ reduce$1),\n/* harmony export */   foldr: () => (/* binding */ reduceRight),\n/* harmony export */   forEach: () => (/* binding */ each),\n/* harmony export */   forEachLimit: () => (/* binding */ eachLimit$1),\n/* harmony export */   forEachOf: () => (/* binding */ eachOf$1),\n/* harmony export */   forEachOfLimit: () => (/* binding */ eachOfLimit$1),\n/* harmony export */   forEachOfSeries: () => (/* binding */ eachOfSeries$1),\n/* harmony export */   forEachSeries: () => (/* binding */ eachSeries$1),\n/* harmony export */   forever: () => (/* binding */ forever$1),\n/* harmony export */   groupBy: () => (/* binding */ groupBy),\n/* harmony export */   groupByLimit: () => (/* binding */ groupByLimit$1),\n/* harmony export */   groupBySeries: () => (/* binding */ groupBySeries),\n/* harmony export */   inject: () => (/* binding */ reduce$1),\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   map: () => (/* binding */ map$1),\n/* harmony export */   mapLimit: () => (/* binding */ mapLimit$1),\n/* harmony export */   mapSeries: () => (/* binding */ mapSeries$1),\n/* harmony export */   mapValues: () => (/* binding */ mapValues),\n/* harmony export */   mapValuesLimit: () => (/* binding */ mapValuesLimit$1),\n/* harmony export */   mapValuesSeries: () => (/* binding */ mapValuesSeries),\n/* harmony export */   memoize: () => (/* binding */ memoize),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   parallel: () => (/* binding */ parallel),\n/* harmony export */   parallelLimit: () => (/* binding */ parallelLimit),\n/* harmony export */   priorityQueue: () => (/* binding */ priorityQueue),\n/* harmony export */   queue: () => (/* binding */ queue),\n/* harmony export */   race: () => (/* binding */ race$1),\n/* harmony export */   reduce: () => (/* binding */ reduce$1),\n/* harmony export */   reduceRight: () => (/* binding */ reduceRight),\n/* harmony export */   reflect: () => (/* binding */ reflect),\n/* harmony export */   reflectAll: () => (/* binding */ reflectAll),\n/* harmony export */   reject: () => (/* binding */ reject$1),\n/* harmony export */   rejectLimit: () => (/* binding */ rejectLimit$1),\n/* harmony export */   rejectSeries: () => (/* binding */ rejectSeries$1),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   retryable: () => (/* binding */ retryable),\n/* harmony export */   select: () => (/* binding */ filter$1),\n/* harmony export */   selectLimit: () => (/* binding */ filterLimit$1),\n/* harmony export */   selectSeries: () => (/* binding */ filterSeries$1),\n/* harmony export */   seq: () => (/* binding */ seq),\n/* harmony export */   series: () => (/* binding */ series),\n/* harmony export */   setImmediate: () => (/* binding */ setImmediate$1),\n/* harmony export */   some: () => (/* binding */ some$1),\n/* harmony export */   someLimit: () => (/* binding */ someLimit$1),\n/* harmony export */   someSeries: () => (/* binding */ someSeries$1),\n/* harmony export */   sortBy: () => (/* binding */ sortBy$1),\n/* harmony export */   timeout: () => (/* binding */ timeout),\n/* harmony export */   times: () => (/* binding */ times),\n/* harmony export */   timesLimit: () => (/* binding */ timesLimit),\n/* harmony export */   timesSeries: () => (/* binding */ timesSeries),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   tryEach: () => (/* binding */ tryEach$1),\n/* harmony export */   unmemoize: () => (/* binding */ unmemoize),\n/* harmony export */   until: () => (/* binding */ until),\n/* harmony export */   waterfall: () => (/* binding */ waterfall$1),\n/* harmony export */   whilst: () => (/* binding */ whilst$1),\n/* harmony export */   wrapSync: () => (/* binding */ asyncify)\n/* harmony export */ });\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @returns {Function} the partially-applied function\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */ function apply(fn, ...args) {\n    return (...callArgs)=>fn(...args, ...callArgs);\n}\nfunction initialParams(fn) {\n    return function(...args /*, callback*/ ) {\n        var callback = args.pop();\n        return fn.call(this, args, callback);\n    };\n}\n/* istanbul ignore file */ var hasQueueMicrotask = typeof queueMicrotask === \"function\" && queueMicrotask;\nvar hasSetImmediate = typeof setImmediate === \"function\" && setImmediate;\nvar hasNextTick = typeof process === \"object\" && typeof process.nextTick === \"function\";\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\nfunction wrap(defer) {\n    return (fn, ...args)=>defer(()=>fn(...args));\n}\nvar _defer$1;\nif (hasQueueMicrotask) {\n    _defer$1 = queueMicrotask;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else if (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else {\n    _defer$1 = fallback;\n}\nvar setImmediate$1 = wrap(_defer$1);\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */ function asyncify(func) {\n    if (isAsync(func)) {\n        return function(...args /*, callback*/ ) {\n            const callback = args.pop();\n            const promise = func.apply(this, args);\n            return handlePromise(promise, callback);\n        };\n    }\n    return initialParams(function(args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (result && typeof result.then === \"function\") {\n            return handlePromise(result, callback);\n        } else {\n            callback(null, result);\n        }\n    });\n}\nfunction handlePromise(promise, callback) {\n    return promise.then((value)=>{\n        invokeCallback(callback, null, value);\n    }, (err)=>{\n        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));\n    });\n}\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (err) {\n        setImmediate$1((e)=>{\n            throw e;\n        }, err);\n    }\n}\nfunction isAsync(fn) {\n    return fn[Symbol.toStringTag] === \"AsyncFunction\";\n}\nfunction isAsyncGenerator(fn) {\n    return fn[Symbol.toStringTag] === \"AsyncGenerator\";\n}\nfunction isAsyncIterable(obj) {\n    return typeof obj[Symbol.asyncIterator] === \"function\";\n}\nfunction wrapAsync(asyncFn) {\n    if (typeof asyncFn !== \"function\") throw new Error(\"expected a function\");\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n}\n// conditionally promisify a function.\n// only return a promise if a callback is omitted\nfunction awaitify(asyncFn, arity) {\n    if (!arity) arity = asyncFn.length;\n    if (!arity) throw new Error(\"arity is undefined\");\n    function awaitable(...args) {\n        if (typeof args[arity - 1] === \"function\") {\n            return asyncFn.apply(this, args);\n        }\n        return new Promise((resolve, reject)=>{\n            args[arity - 1] = (err, ...cbArgs)=>{\n                if (err) return reject(err);\n                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n            };\n            asyncFn.apply(this, args);\n        });\n    }\n    return awaitable;\n}\nfunction applyEach$1(eachfn) {\n    return function applyEach(fns, ...callArgs) {\n        const go = awaitify(function(callback) {\n            var that = this;\n            return eachfn(fns, (fn, cb)=>{\n                wrapAsync(fn).apply(that, callArgs.concat(cb));\n            }, callback);\n        });\n        return go;\n    };\n}\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync(iteratee);\n    return eachfn(arr, (value, _, iterCb)=>{\n        var index = counter++;\n        _iteratee(value, (err, v)=>{\n            results[index] = v;\n            iterCb(err);\n        });\n    }, (err)=>{\n        callback(err, results);\n    });\n}\nfunction isArrayLike(value) {\n    return value && typeof value.length === \"number\" && value.length >= 0 && value.length % 1 === 0;\n}\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nconst breakLoop = {};\nvar breakLoop$1 = breakLoop;\nfunction once(fn) {\n    function wrapper(...args) {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    }\n    Object.assign(wrapper, fn);\n    return wrapper;\n}\nfunction getIterator(coll) {\n    return coll[Symbol.iterator] && coll[Symbol.iterator]();\n}\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? {\n            value: coll[i],\n            key: i\n        } : null;\n    };\n}\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return {\n            value: item.value,\n            key: i\n        };\n    };\n}\nfunction createObjectIterator(obj) {\n    var okeys = obj ? Object.keys(obj) : [];\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        if (key === \"__proto__\") {\n            return next();\n        }\n        return i < len ? {\n            value: obj[key],\n            key\n        } : null;\n    };\n}\nfunction createIterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\nfunction onlyOnce(fn) {\n    return function(...args) {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    };\n}\n// for async generators\nfunction asyncEachOfLimit(generator, limit, iteratee, callback) {\n    let done = false;\n    let canceled = false;\n    let awaiting = false;\n    let running = 0;\n    let idx = 0;\n    function replenish() {\n        //console.log('replenish')\n        if (running >= limit || awaiting || done) return;\n        //console.log('replenish awaiting')\n        awaiting = true;\n        generator.next().then(({ value, done: iterDone })=>{\n            //console.log('got value', value)\n            if (canceled || done) return;\n            awaiting = false;\n            if (iterDone) {\n                done = true;\n                if (running <= 0) {\n                    //console.log('done nextCb')\n                    callback(null);\n                }\n                return;\n            }\n            running++;\n            iteratee(value, idx, iterateeCallback);\n            idx++;\n            replenish();\n        }).catch(handleError);\n    }\n    function iterateeCallback(err, result) {\n        //console.log('iterateeCallback')\n        running -= 1;\n        if (canceled) return;\n        if (err) return handleError(err);\n        if (err === false) {\n            done = true;\n            canceled = true;\n            return;\n        }\n        if (result === breakLoop$1 || done && running <= 0) {\n            done = true;\n            //console.log('done iterCb')\n            return callback(null);\n        }\n        replenish();\n    }\n    function handleError(err) {\n        if (canceled) return;\n        awaiting = false;\n        done = true;\n        callback(err);\n    }\n    replenish();\n}\nvar eachOfLimit$2 = (limit)=>{\n    return (obj, iteratee, callback)=>{\n        callback = once(callback);\n        if (limit <= 0) {\n            throw new RangeError(\"concurrency limit cannot be less than 1\");\n        }\n        if (!obj) {\n            return callback(null);\n        }\n        if (isAsyncGenerator(obj)) {\n            return asyncEachOfLimit(obj, limit, iteratee, callback);\n        }\n        if (isAsyncIterable(obj)) {\n            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);\n        }\n        var nextElem = createIterator(obj);\n        var done = false;\n        var canceled = false;\n        var running = 0;\n        var looping = false;\n        function iterateeCallback(err, value) {\n            if (canceled) return;\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (err === false) {\n                done = true;\n                canceled = true;\n            } else if (value === breakLoop$1 || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else if (!looping) {\n                replenish();\n            }\n        }\n        function replenish() {\n            looping = true;\n            while(running < limit && !done){\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n            looping = false;\n        }\n        replenish();\n    };\n};\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */ function eachOfLimit(coll, limit, iteratee, callback) {\n    return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);\n}\nvar eachOfLimit$1 = awaitify(eachOfLimit, 4);\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback);\n    var index = 0, completed = 0, { length } = coll, canceled = false;\n    if (length === 0) {\n        callback(null);\n    }\n    function iteratorCallback(err, value) {\n        if (err === false) {\n            canceled = true;\n        }\n        if (canceled === true) return;\n        if (err) {\n            callback(err);\n        } else if (++completed === length || value === breakLoop$1) {\n            callback(null);\n        }\n    }\n    for(; index < length; index++){\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n// a generic version of eachOf which can handle array, object, and iterator cases.\nfunction eachOfGeneric(coll, iteratee, callback) {\n    return eachOfLimit$1(coll, Infinity, iteratee, callback);\n}\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each\n * item in `coll`.\n * The `key` is the item's key, or index in the case of an array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * // dev.json is a file containing a valid json object config for dev environment\n * // dev.json is a file containing a valid json object config for test environment\n * // prod.json is a file containing a valid json object config for prod environment\n * // invalid.json is a file with a malformed json object\n *\n * let configs = {}; //global variable\n * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};\n * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};\n *\n * // asynchronous function that reads a json file and parses the contents as json object\n * function parseFile(file, key, callback) {\n *     fs.readFile(file, \"utf8\", function(err, data) {\n *         if (err) return calback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }\n *\n * // Using callbacks\n * async.forEachOf(validConfigFileMap, parseFile, function (err) {\n *     if (err) {\n *         console.error(err);\n *     } else {\n *         console.log(configs);\n *         // configs is now a map of JSON data, e.g.\n *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n *     }\n * });\n *\n * //Error handing\n * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {\n *     if (err) {\n *         console.error(err);\n *         // JSON parse error exception\n *     } else {\n *         console.log(configs);\n *     }\n * });\n *\n * // Using Promises\n * async.forEachOf(validConfigFileMap, parseFile)\n * .then( () => {\n *     console.log(configs);\n *     // configs is now a map of JSON data, e.g.\n *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n * }).catch( err => {\n *     console.error(err);\n * });\n *\n * //Error handing\n * async.forEachOf(invalidConfigFileMap, parseFile)\n * .then( () => {\n *     console.log(configs);\n * }).catch( err => {\n *     console.error(err);\n *     // JSON parse error exception\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.forEachOf(validConfigFileMap, parseFile);\n *         console.log(configs);\n *         // configs is now a map of JSON data, e.g.\n *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * //Error handing\n * async () => {\n *     try {\n *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);\n *         console.log(configs);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // JSON parse error exception\n *     }\n * }\n *\n */ function eachOf(coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    return eachOfImplementation(coll, wrapAsync(iteratee), callback);\n}\nvar eachOf$1 = awaitify(eachOf, 3);\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callbacks\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines).\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n * // file4.txt does not exist\n *\n * const fileList = ['file1.txt','file2.txt','file3.txt'];\n * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n *\n * // asynchronous function that returns the file size in bytes\n * function getFileSizeInBytes(file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.map(fileList, getFileSizeInBytes, function(err, results) {\n *     if (err) {\n *         console.log(err);\n *     } else {\n *         console.log(results);\n *         // results is now an array of the file size in bytes for each file, e.g.\n *         // [ 1000, 2000, 3000]\n *     }\n * });\n *\n * // Error Handling\n * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {\n *     if (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     } else {\n *         console.log(results);\n *     }\n * });\n *\n * // Using Promises\n * async.map(fileList, getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n *     // results is now an array of the file size in bytes for each file, e.g.\n *     // [ 1000, 2000, 3000]\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.map(withMissingFileList, getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.map(fileList, getFileSizeInBytes);\n *         console.log(results);\n *         // results is now an array of the file size in bytes for each file, e.g.\n *         // [ 1000, 2000, 3000]\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let results = await async.map(withMissingFileList, getFileSizeInBytes);\n *         console.log(results);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */ function map(coll, iteratee, callback) {\n    return _asyncMap(eachOf$1, coll, iteratee, callback);\n}\nvar map$1 = awaitify(map, 3);\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional. The results\n * for each of the applied async functions are passed to the final callback\n * as an array.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {AsyncFunction} - Returns a function that takes no args other than\n * an optional callback, that is the result of applying the `args` to each\n * of the functions.\n * @example\n *\n * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')\n *\n * appliedFn((err, results) => {\n *     // results[0] is the results for `enableSearch`\n *     // results[1] is the results for `updateSchema`\n * });\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),\n *     callback\n * );\n */ var applyEach = applyEach$1(map$1);\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */ function eachOfSeries(coll, iteratee, callback) {\n    return eachOfLimit$1(coll, 1, iteratee, callback);\n}\nvar eachOfSeries$1 = awaitify(eachOfSeries, 3);\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */ function mapSeries(coll, iteratee, callback) {\n    return _asyncMap(eachOfSeries$1, coll, iteratee, callback);\n}\nvar mapSeries$1 = awaitify(mapSeries, 3);\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {AsyncFunction} - A function, that when called, is the result of\n * appling the `args` to the list of functions.  It takes no args, other than\n * a callback.\n */ var applyEachSeries = applyEach$1(mapSeries$1);\nconst PROMISE_SYMBOL = Symbol(\"promiseCallback\");\nfunction promiseCallback() {\n    let resolve, reject;\n    function callback(err, ...args) {\n        if (err) return reject(err);\n        resolve(args.length > 1 ? args : args[0]);\n    }\n    callback[PROMISE_SYMBOL] = new Promise((res, rej)=>{\n        resolve = res, reject = rej;\n    });\n    return callback;\n}\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n * @example\n *\n * //Using Callbacks\n * async.auto({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     if (err) {\n *         console.log('err = ', err);\n *     }\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * });\n *\n * //Using Promises\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }).then(results => {\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * }).catch(err => {\n *     console.log('err = ', err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.auto({\n *             get_data: function(callback) {\n *                 // async code to get some data\n *                 callback(null, 'data', 'converted to array');\n *             },\n *             make_folder: function(callback) {\n *                 // async code to create a directory to store a file in\n *                 // this is run at the same time as getting the data\n *                 callback(null, 'folder');\n *             },\n *             write_file: ['get_data', 'make_folder', function(results, callback) {\n *                 // once there is some data and the directory exists,\n *                 // write the data to a file in the directory\n *                 callback(null, 'filename');\n *             }],\n *             email_link: ['write_file', function(results, callback) {\n *                 // once the file is written let's email a link to it...\n *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *             }]\n *         });\n *         console.log('results = ', results);\n *         // results = {\n *         //     get_data: ['data', 'converted to array']\n *         //     make_folder; 'folder',\n *         //     write_file: 'filename'\n *         //     email_link: { file: 'filename', email: 'user@example.com' }\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */ function auto(tasks, concurrency, callback) {\n    if (typeof concurrency !== \"number\") {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || promiseCallback());\n    var numTasks = Object.keys(tasks).length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n    var results = {};\n    var runningTasks = 0;\n    var canceled = false;\n    var hasError = false;\n    var listeners = Object.create(null);\n    var readyTasks = [];\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n    Object.keys(tasks).forEach((key)=>{\n        var task = tasks[key];\n        if (!Array.isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [\n                task\n            ]);\n            readyToCheck.push(key);\n            return;\n        }\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n        dependencies.forEach((dependencyName)=>{\n            if (!tasks[dependencyName]) {\n                throw new Error(\"async.auto task `\" + key + \"` has a non-existent dependency `\" + dependencyName + \"` in \" + dependencies.join(\", \"));\n            }\n            addListener(dependencyName, ()=>{\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n    checkForDeadlocks();\n    processQueue();\n    function enqueueTask(key, task) {\n        readyTasks.push(()=>runTask(key, task));\n    }\n    function processQueue() {\n        if (canceled) return;\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while(readyTasks.length && runningTasks < concurrency){\n            var run = readyTasks.shift();\n            run();\n        }\n    }\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n        taskListeners.push(fn);\n    }\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        taskListeners.forEach((fn)=>fn());\n        processQueue();\n    }\n    function runTask(key, task) {\n        if (hasError) return;\n        var taskCallback = onlyOnce((err, ...result)=>{\n            runningTasks--;\n            if (err === false) {\n                canceled = true;\n                return;\n            }\n            if (result.length < 2) {\n                [result] = result;\n            }\n            if (err) {\n                var safeResults = {};\n                Object.keys(results).forEach((rkey)=>{\n                    safeResults[rkey] = results[rkey];\n                });\n                safeResults[key] = result;\n                hasError = true;\n                listeners = Object.create(null);\n                if (canceled) return;\n                callback(err, safeResults);\n            } else {\n                results[key] = result;\n                taskComplete(key);\n            }\n        });\n        runningTasks++;\n        var taskFn = wrapAsync(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while(readyToCheck.length){\n            currentTask = readyToCheck.pop();\n            counter++;\n            getDependents(currentTask).forEach((dependent)=>{\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n        if (counter !== numTasks) {\n            throw new Error(\"async.auto cannot execute tasks due to a recursive dependency\");\n        }\n    }\n    function getDependents(taskName) {\n        var result = [];\n        Object.keys(tasks).forEach((key)=>{\n            const task = tasks[key];\n            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n    return callback[PROMISE_SYMBOL];\n}\nvar FN_ARGS = /^(?:async\\s+)?(?:function)?\\s*\\w*\\s*\\(\\s*([^)]+)\\s*\\)(?:\\s*{)/;\nvar ARROW_FN_ARGS = /^(?:async\\s+)?\\(?\\s*([^)=]+)\\s*\\)?(?:\\s*=>)/;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nfunction stripComments(string) {\n    let stripped = \"\";\n    let index = 0;\n    let endBlockComment = string.indexOf(\"*/\");\n    while(index < string.length){\n        if (string[index] === \"/\" && string[index + 1] === \"/\") {\n            // inline comment\n            let endIndex = string.indexOf(\"\\n\", index);\n            index = endIndex === -1 ? string.length : endIndex;\n        } else if (endBlockComment !== -1 && string[index] === \"/\" && string[index + 1] === \"*\") {\n            // block comment\n            let endIndex = string.indexOf(\"*/\", index);\n            if (endIndex !== -1) {\n                index = endIndex + 2;\n                endBlockComment = string.indexOf(\"*/\", index);\n            } else {\n                stripped += string[index];\n                index++;\n            }\n        } else {\n            stripped += string[index];\n            index++;\n        }\n    }\n    return stripped;\n}\nfunction parseParams(func) {\n    const src = stripComments(func.toString());\n    let match = src.match(FN_ARGS);\n    if (!match) {\n        match = src.match(ARROW_FN_ARGS);\n    }\n    if (!match) throw new Error(\"could not parse args in autoInject\\nSource:\\n\" + src);\n    let [, args] = match;\n    return args.replace(/\\s/g, \"\").split(FN_ARG_SPLIT).map((arg)=>arg.replace(FN_ARG, \"\").trim());\n}\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */ function autoInject(tasks, callback) {\n    var newTasks = {};\n    Object.keys(tasks).forEach((key)=>{\n        var taskFn = tasks[key];\n        var params;\n        var fnIsAsync = isAsync(taskFn);\n        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;\n        if (Array.isArray(taskFn)) {\n            params = [\n                ...taskFn\n            ];\n            taskFn = params.pop();\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n            newTasks[key] = params.concat(newTask);\n        }\n        function newTask(results, taskCb) {\n            var newArgs = params.map((name)=>results[name]);\n            newArgs.push(taskCb);\n            wrapAsync(taskFn)(...newArgs);\n        }\n    });\n    return auto(newTasks, callback);\n}\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nclass DLL {\n    constructor(){\n        this.head = this.tail = null;\n        this.length = 0;\n    }\n    removeLink(node) {\n        if (node.prev) node.prev.next = node.next;\n        else this.head = node.next;\n        if (node.next) node.next.prev = node.prev;\n        else this.tail = node.prev;\n        node.prev = node.next = null;\n        this.length -= 1;\n        return node;\n    }\n    empty() {\n        while(this.head)this.shift();\n        return this;\n    }\n    insertAfter(node, newNode) {\n        newNode.prev = node;\n        newNode.next = node.next;\n        if (node.next) node.next.prev = newNode;\n        else this.tail = newNode;\n        node.next = newNode;\n        this.length += 1;\n    }\n    insertBefore(node, newNode) {\n        newNode.prev = node.prev;\n        newNode.next = node;\n        if (node.prev) node.prev.next = newNode;\n        else this.head = newNode;\n        node.prev = newNode;\n        this.length += 1;\n    }\n    unshift(node) {\n        if (this.head) this.insertBefore(this.head, node);\n        else setInitial(this, node);\n    }\n    push(node) {\n        if (this.tail) this.insertAfter(this.tail, node);\n        else setInitial(this, node);\n    }\n    shift() {\n        return this.head && this.removeLink(this.head);\n    }\n    pop() {\n        return this.tail && this.removeLink(this.tail);\n    }\n    toArray() {\n        return [\n            ...this\n        ];\n    }\n    *[Symbol.iterator]() {\n        var cur = this.head;\n        while(cur){\n            yield cur.data;\n            cur = cur.next;\n        }\n    }\n    remove(testFn) {\n        var curr = this.head;\n        while(curr){\n            var { next } = curr;\n            if (testFn(curr)) {\n                this.removeLink(curr);\n            }\n            curr = next;\n        }\n        return this;\n    }\n}\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\nfunction queue$1(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    } else if (concurrency === 0) {\n        throw new RangeError(\"Concurrency must not be zero\");\n    }\n    var _worker = wrapAsync(worker);\n    var numRunning = 0;\n    var workersList = [];\n    const events = {\n        error: [],\n        drain: [],\n        saturated: [],\n        unsaturated: [],\n        empty: []\n    };\n    function on(event, handler) {\n        events[event].push(handler);\n    }\n    function once(event, handler) {\n        const handleAndRemove = (...args)=>{\n            off(event, handleAndRemove);\n            handler(...args);\n        };\n        events[event].push(handleAndRemove);\n    }\n    function off(event, handler) {\n        if (!event) return Object.keys(events).forEach((ev)=>events[ev] = []);\n        if (!handler) return events[event] = [];\n        events[event] = events[event].filter((ev)=>ev !== handler);\n    }\n    function trigger(event, ...args) {\n        events[event].forEach((handler)=>handler(...args));\n    }\n    var processingScheduled = false;\n    function _insert(data, insertAtFront, rejectOnError, callback) {\n        if (callback != null && typeof callback !== \"function\") {\n            throw new Error(\"task callback must be a function\");\n        }\n        q.started = true;\n        var res, rej;\n        function promiseCallback(err, ...args) {\n            // we don't care about the error, let the global error handler\n            // deal with it\n            if (err) return rejectOnError ? rej(err) : res();\n            if (args.length <= 1) return res(args[0]);\n            res(args);\n        }\n        var item = q._createTaskItem(data, rejectOnError ? promiseCallback : callback || promiseCallback);\n        if (insertAtFront) {\n            q._tasks.unshift(item);\n        } else {\n            q._tasks.push(item);\n        }\n        if (!processingScheduled) {\n            processingScheduled = true;\n            setImmediate$1(()=>{\n                processingScheduled = false;\n                q.process();\n            });\n        }\n        if (rejectOnError || !callback) {\n            return new Promise((resolve, reject)=>{\n                res = resolve;\n                rej = reject;\n            });\n        }\n    }\n    function _createCB(tasks) {\n        return function(err, ...args) {\n            numRunning -= 1;\n            for(var i = 0, l = tasks.length; i < l; i++){\n                var task = tasks[i];\n                var index = workersList.indexOf(task);\n                if (index === 0) {\n                    workersList.shift();\n                } else if (index > 0) {\n                    workersList.splice(index, 1);\n                }\n                task.callback(err, ...args);\n                if (err != null) {\n                    trigger(\"error\", err, task.data);\n                }\n            }\n            if (numRunning <= q.concurrency - q.buffer) {\n                trigger(\"unsaturated\");\n            }\n            if (q.idle()) {\n                trigger(\"drain\");\n            }\n            q.process();\n        };\n    }\n    function _maybeDrain(data) {\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            setImmediate$1(()=>trigger(\"drain\"));\n            return true;\n        }\n        return false;\n    }\n    const eventMethod = (name)=>(handler)=>{\n            if (!handler) {\n                return new Promise((resolve, reject)=>{\n                    once(name, (err, data)=>{\n                        if (err) return reject(err);\n                        resolve(data);\n                    });\n                });\n            }\n            off(name);\n            on(name, handler);\n        };\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        _createTaskItem (data, callback) {\n            return {\n                data,\n                callback\n            };\n        },\n        *[Symbol.iterator] () {\n            yield* q._tasks[Symbol.iterator]();\n        },\n        concurrency,\n        payload,\n        buffer: concurrency / 4,\n        started: false,\n        paused: false,\n        push (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return;\n                return data.map((datum)=>_insert(datum, false, false, callback));\n            }\n            return _insert(data, false, false, callback);\n        },\n        pushAsync (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return;\n                return data.map((datum)=>_insert(datum, false, true, callback));\n            }\n            return _insert(data, false, true, callback);\n        },\n        kill () {\n            off();\n            q._tasks.empty();\n        },\n        unshift (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return;\n                return data.map((datum)=>_insert(datum, true, false, callback));\n            }\n            return _insert(data, true, false, callback);\n        },\n        unshiftAsync (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return;\n                return data.map((datum)=>_insert(datum, true, true, callback));\n            }\n            return _insert(data, true, true, callback);\n        },\n        remove (testFn) {\n            q._tasks.remove(testFn);\n        },\n        process () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while(!q.paused && numRunning < q.concurrency && q._tasks.length){\n                var tasks = [], data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for(var i = 0; i < l; i++){\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    workersList.push(node);\n                    data.push(node.data);\n                }\n                numRunning += 1;\n                if (q._tasks.length === 0) {\n                    trigger(\"empty\");\n                }\n                if (numRunning === q.concurrency) {\n                    trigger(\"saturated\");\n                }\n                var cb = onlyOnce(_createCB(tasks));\n                _worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length () {\n            return q._tasks.length;\n        },\n        running () {\n            return numRunning;\n        },\n        workersList () {\n            return workersList;\n        },\n        idle () {\n            return q._tasks.length + numRunning === 0;\n        },\n        pause () {\n            q.paused = true;\n        },\n        resume () {\n            if (q.paused === false) {\n                return;\n            }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    // define these as fixed properties, so people get useful errors when updating\n    Object.defineProperties(q, {\n        saturated: {\n            writable: false,\n            value: eventMethod(\"saturated\")\n        },\n        unsaturated: {\n            writable: false,\n            value: eventMethod(\"unsaturated\")\n        },\n        empty: {\n            writable: false,\n            value: eventMethod(\"empty\")\n        },\n        drain: {\n            writable: false,\n            value: eventMethod(\"drain\")\n        },\n        error: {\n            writable: false,\n            value: eventMethod(\"error\")\n        }\n    });\n    return q;\n}\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * await cargo.push({name: 'baz'});\n * console.log('finished processing baz');\n */ function cargo$1(worker, payload) {\n    return queue$1(worker, 1, payload);\n}\n/**\n * Creates a `cargoQueue` object with the specified payload. Tasks added to the\n * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.\n * If the all `workers` are in progress, the task is queued until one becomes available. Once\n * a `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,\n * the cargoQueue passes an array of tasks to multiple parallel workers.\n *\n * @name cargoQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @see [async.cargo]{@link module:ControlFLow.cargo}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargoQueue and inner queue.\n * @example\n *\n * // create a cargoQueue object with payload 2 and concurrency 2\n * var cargoQueue = async.cargoQueue(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2, 2);\n *\n * // add some items\n * cargoQueue.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargoQueue.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargoQueue.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n * cargoQueue.push({name: 'boo'}, function(err) {\n *     console.log('finished processing boo');\n * });\n */ function cargo(worker, concurrency, payload) {\n    return queue$1(worker, concurrency, payload);\n}\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee completes with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n * // file4.txt does not exist\n *\n * const fileList = ['file1.txt','file2.txt','file3.txt'];\n * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];\n *\n * // asynchronous function that computes the file size in bytes\n * // file size is added to the memoized value, then returned\n * function getFileSizeInBytes(memo, file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, memo + stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // 6000\n *         // which is the sum of the file sizes of the three files\n *     }\n * });\n *\n * // Error Handling\n * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     } else {\n *         console.log(result);\n *     }\n * });\n *\n * // Using Promises\n * async.reduce(fileList, 0, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n *     // 6000\n *     // which is the sum of the file sizes of the three files\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.reduce(withMissingFileList, 0, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.reduce(fileList, 0, getFileSizeInBytes);\n *         console.log(result);\n *         // 6000\n *         // which is the sum of the file sizes of the three files\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);\n *         console.log(result);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */ function reduce(coll, memo, iteratee, callback) {\n    callback = once(callback);\n    var _iteratee = wrapAsync(iteratee);\n    return eachOfSeries$1(coll, (x, i, iterCb)=>{\n        _iteratee(memo, x, (err, v)=>{\n            memo = v;\n            iterCb(err);\n        });\n    }, (err)=>callback(err, memo));\n}\nvar reduce$1 = awaitify(reduce, 4);\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         User.get.bind(User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */ function seq(...functions) {\n    var _functions = functions.map(wrapAsync);\n    return function(...args) {\n        var that = this;\n        var cb = args[args.length - 1];\n        if (typeof cb == \"function\") {\n            args.pop();\n        } else {\n            cb = promiseCallback();\n        }\n        reduce$1(_functions, args, (newargs, fn, iterCb)=>{\n            fn.apply(that, newargs.concat((err, ...nextargs)=>{\n                iterCb(err, nextargs);\n            }));\n        }, (err, results)=>cb(err, ...results));\n        return cb[PROMISE_SYMBOL];\n    };\n}\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * If the last argument to the composed function is not a function, a promise\n * is returned when you call it.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */ function compose(...args) {\n    return seq(...args.reverse());\n}\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */ function mapLimit(coll, limit, iteratee, callback) {\n    return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);\n}\nvar mapLimit$1 = awaitify(mapLimit, 4);\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n *\n * @name concatLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @alias flatMapLimit\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed\n */ function concatLimit(coll, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(coll, limit, (val, iterCb)=>{\n        _iteratee(val, (err, ...args)=>{\n            if (err) return iterCb(err);\n            return iterCb(err, args);\n        });\n    }, (err, mapResults)=>{\n        var result = [];\n        for(var i = 0; i < mapResults.length; i++){\n            if (mapResults[i]) {\n                result = result.concat(...mapResults[i]);\n            }\n        }\n        return callback(err, result);\n    });\n}\nvar concatLimit$1 = awaitify(concatLimit, 4);\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. The results array will be returned in\n * the original order of `coll` passed to the `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @alias flatMap\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * let directoryList = ['dir1','dir2','dir3'];\n * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];\n *\n * // Using callbacks\n * async.concat(directoryList, fs.readdir, function(err, results) {\n *    if (err) {\n *        console.log(err);\n *    } else {\n *        console.log(results);\n *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n *    }\n * });\n *\n * // Error Handling\n * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {\n *    if (err) {\n *        console.log(err);\n *        // [ Error: ENOENT: no such file or directory ]\n *        // since dir4 does not exist\n *    } else {\n *        console.log(results);\n *    }\n * });\n *\n * // Using Promises\n * async.concat(directoryList, fs.readdir)\n * .then(results => {\n *     console.log(results);\n *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n * }).catch(err => {\n *      console.log(err);\n * });\n *\n * // Error Handling\n * async.concat(withMissingDirectoryList, fs.readdir)\n * .then(results => {\n *     console.log(results);\n * }).catch(err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n *     // since dir4 does not exist\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.concat(directoryList, fs.readdir);\n *         console.log(results);\n *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n *     } catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let results = await async.concat(withMissingDirectoryList, fs.readdir);\n *         console.log(results);\n *     } catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *         // since dir4 does not exist\n *     }\n * }\n *\n */ function concat(coll, iteratee, callback) {\n    return concatLimit$1(coll, Infinity, iteratee, callback);\n}\nvar concat$1 = awaitify(concat, 3);\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @alias flatMapSeries\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed\n */ function concatSeries(coll, iteratee, callback) {\n    return concatLimit$1(coll, 1, iteratee, callback);\n}\nvar concatSeries$1 = awaitify(concatSeries, 3);\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {AsyncFunction} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */ function constant$1(...args) {\n    return function(...ignoredArgs /*, callback*/ ) {\n        var callback = ignoredArgs.pop();\n        return callback(null, ...args);\n    };\n}\nfunction _createTester(check, getResult) {\n    return (eachfn, arr, _iteratee, cb)=>{\n        var testPassed = false;\n        var testResult;\n        const iteratee = wrapAsync(_iteratee);\n        eachfn(arr, (value, _, callback)=>{\n            iteratee(value, (err, result)=>{\n                if (err || err === false) return callback(err);\n                if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    return callback(null, breakLoop$1);\n                }\n                callback();\n            });\n        }, (err)=>{\n            if (err) return cb(err);\n            cb(null, testPassed ? testResult : getResult(false));\n        });\n    };\n}\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,\n *    function(err, result) {\n *        console.log(result);\n *        // dir1/file1.txt\n *        // result now equals the first file in the list that exists\n *    }\n *);\n *\n * // Using Promises\n * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)\n * .then(result => {\n *     console.log(result);\n *     // dir1/file1.txt\n *     // result now equals the first file in the list that exists\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);\n *         console.log(result);\n *         // dir1/file1.txt\n *         // result now equals the file in the list that exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */ function detect(coll, iteratee, callback) {\n    return _createTester((bool)=>bool, (res, item)=>item)(eachOf$1, coll, iteratee, callback);\n}\nvar detect$1 = awaitify(detect, 3);\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if a callback is omitted\n */ function detectLimit(coll, limit, iteratee, callback) {\n    return _createTester((bool)=>bool, (res, item)=>item)(eachOfLimit$2(limit), coll, iteratee, callback);\n}\nvar detectLimit$1 = awaitify(detectLimit, 4);\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if a callback is omitted\n */ function detectSeries(coll, iteratee, callback) {\n    return _createTester((bool)=>bool, (res, item)=>item)(eachOfLimit$2(1), coll, iteratee, callback);\n}\nvar detectSeries$1 = awaitify(detectSeries, 3);\nfunction consoleFunc(name) {\n    return (fn, ...args)=>wrapAsync(fn)(...args, (err, ...resultArgs)=>{\n            /* istanbul ignore else */ if (typeof console === \"object\") {\n                /* istanbul ignore else */ if (err) {\n                    /* istanbul ignore else */ if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) {\n                    resultArgs.forEach((x)=>console[name](x));\n                }\n            }\n        });\n}\n/**\n * Logs the result of an [`async` function]{@link AsyncFunction} to the\n * `console` using `console.dir` to display the properties of the resulting object.\n * Only works in Node.js or in browsers that support `console.dir` and\n * `console.error` (such as FF and Chrome).\n * If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */ var dir = consoleFunc(\"dir\");\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - A function which is called each time `test`\n * passes. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform after each\n * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if no callback is passed\n */ function doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback);\n    var _fn = wrapAsync(iteratee);\n    var _test = wrapAsync(test);\n    var results;\n    function next(err, ...args) {\n        if (err) return callback(err);\n        if (err === false) return;\n        results = args;\n        _test(...args, check);\n    }\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (err === false) return;\n        if (!truth) return callback(null, ...results);\n        _fn(next);\n    }\n    return check(null, true);\n}\nvar doWhilst$1 = awaitify(doWhilst, 3);\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform after each\n * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `iteratee`\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if no callback is passed\n */ function doUntil(iteratee, test, callback) {\n    const _test = wrapAsync(test);\n    return doWhilst$1(iteratee, (...args)=>{\n        const cb = args.pop();\n        _test(...args, (err, truth)=>cb(err, !truth));\n    }, callback);\n}\nfunction _withoutIndex(iteratee) {\n    return (value, index, callback)=>iteratee(value, callback);\n}\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to\n * each item in `coll`. Invoked with (item, callback).\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];\n * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];\n *\n * // asynchronous function that deletes a file\n * const deleteFile = function(file, callback) {\n *     fs.unlink(file, callback);\n * };\n *\n * // Using callbacks\n * async.each(fileList, deleteFile, function(err) {\n *     if( err ) {\n *         console.log(err);\n *     } else {\n *         console.log('All files have been deleted successfully');\n *     }\n * });\n *\n * // Error Handling\n * async.each(withMissingFileList, deleteFile, function(err){\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n *     // since dir4/file2.txt does not exist\n *     // dir1/file1.txt could have been deleted\n * });\n *\n * // Using Promises\n * async.each(fileList, deleteFile)\n * .then( () => {\n *     console.log('All files have been deleted successfully');\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.each(fileList, deleteFile)\n * .then( () => {\n *     console.log('All files have been deleted successfully');\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n *     // since dir4/file2.txt does not exist\n *     // dir1/file1.txt could have been deleted\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         await async.each(files, deleteFile);\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         await async.each(withMissingFileList, deleteFile);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *         // since dir4/file2.txt does not exist\n *         // dir1/file1.txt could have been deleted\n *     }\n * }\n *\n */ function eachLimit$2(coll, iteratee, callback) {\n    return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\nvar each = awaitify(eachLimit$2, 3);\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */ function eachLimit(coll, limit, iteratee, callback) {\n    return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\nvar eachLimit$1 = awaitify(eachLimit, 4);\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item\n * in series and therefore the iteratee functions will complete in order.\n\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */ function eachSeries(coll, iteratee, callback) {\n    return eachLimit$1(coll, 1, iteratee, callback);\n}\nvar eachSeries$1 = awaitify(eachSeries, 3);\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */ function ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return function(...args /*, callback*/ ) {\n        var callback = args.pop();\n        var sync = true;\n        args.push((...innerArgs)=>{\n            if (sync) {\n                setImmediate$1(()=>callback(...innerArgs));\n            } else {\n                callback(...innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    };\n}\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];\n * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.every(fileList, fileExists, function(err, result) {\n *     console.log(result);\n *     // true\n *     // result is true since every file exists\n * });\n *\n * async.every(withMissingFileList, fileExists, function(err, result) {\n *     console.log(result);\n *     // false\n *     // result is false since NOT every file exists\n * });\n *\n * // Using Promises\n * async.every(fileList, fileExists)\n * .then( result => {\n *     console.log(result);\n *     // true\n *     // result is true since every file exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * async.every(withMissingFileList, fileExists)\n * .then( result => {\n *     console.log(result);\n *     // false\n *     // result is false since NOT every file exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.every(fileList, fileExists);\n *         console.log(result);\n *         // true\n *         // result is true since every file exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * async () => {\n *     try {\n *         let result = await async.every(withMissingFileList, fileExists);\n *         console.log(result);\n *         // false\n *         // result is false since NOT every file exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */ function every(coll, iteratee, callback) {\n    return _createTester((bool)=>!bool, (res)=>!res)(eachOf$1, coll, iteratee, callback);\n}\nvar every$1 = awaitify(every, 3);\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */ function everyLimit(coll, limit, iteratee, callback) {\n    return _createTester((bool)=>!bool, (res)=>!res)(eachOfLimit$2(limit), coll, iteratee, callback);\n}\nvar everyLimit$1 = awaitify(everyLimit, 4);\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in series.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */ function everySeries(coll, iteratee, callback) {\n    return _createTester((bool)=>!bool, (res)=>!res)(eachOfSeries$1, coll, iteratee, callback);\n}\nvar everySeries$1 = awaitify(everySeries, 3);\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, (x, index, iterCb)=>{\n        iteratee(x, (err, v)=>{\n            truthValues[index] = !!v;\n            iterCb(err);\n        });\n    }, (err)=>{\n        if (err) return callback(err);\n        var results = [];\n        for(var i = 0; i < arr.length; i++){\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, (x, index, iterCb)=>{\n        iteratee(x, (err, v)=>{\n            if (err) return iterCb(err);\n            if (v) {\n                results.push({\n                    index,\n                    value: x\n                });\n            }\n            iterCb(err);\n        });\n    }, (err)=>{\n        if (err) return callback(err);\n        callback(null, results.sort((a, b)=>a.index - b.index).map((v)=>v.value));\n    });\n}\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    return filter(eachfn, coll, wrapAsync(iteratee), callback);\n}\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n *\n * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.filter(files, fileExists, function(err, results) {\n *    if(err) {\n *        console.log(err);\n *    } else {\n *        console.log(results);\n *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n *        // results is now an array of the existing files\n *    }\n * });\n *\n * // Using Promises\n * async.filter(files, fileExists)\n * .then(results => {\n *     console.log(results);\n *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n *     // results is now an array of the existing files\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.filter(files, fileExists);\n *         console.log(results);\n *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n *         // results is now an array of the existing files\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */ function filter(coll, iteratee, callback) {\n    return _filter(eachOf$1, coll, iteratee, callback);\n}\nvar filter$1 = awaitify(filter, 3);\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback provided\n */ function filterLimit(coll, limit, iteratee, callback) {\n    return _filter(eachOfLimit$2(limit), coll, iteratee, callback);\n}\nvar filterLimit$1 = awaitify(filterLimit, 4);\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n * @returns {Promise} a promise, if no callback provided\n */ function filterSeries(coll, iteratee, callback) {\n    return _filter(eachOfSeries$1, coll, iteratee, callback);\n}\nvar filterSeries$1 = awaitify(filterSeries, 3);\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the callback then `errback` is called with the\n * error, and execution stops, otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} fn - an async function to call repeatedly.\n * Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @returns {Promise} a promise that rejects if an error occurs and an errback\n * is not passed\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */ function forever(fn, errback) {\n    var done = onlyOnce(errback);\n    var task = wrapAsync(ensureAsync(fn));\n    function next(err) {\n        if (err) return done(err);\n        if (err === false) return;\n        task(next);\n    }\n    return next();\n}\nvar forever$1 = awaitify(forever, 2);\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n *\n * @name groupByLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @returns {Promise} a promise, if no callback is passed\n */ function groupByLimit(coll, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(coll, limit, (val, iterCb)=>{\n        _iteratee(val, (err, key)=>{\n            if (err) return iterCb(err);\n            return iterCb(err, {\n                key,\n                val\n            });\n        });\n    }, (err, mapResults)=>{\n        var result = {};\n        // from MDN, handle object having an `hasOwnProperty` prop\n        var { hasOwnProperty } = Object.prototype;\n        for(var i = 0; i < mapResults.length; i++){\n            if (mapResults[i]) {\n                var { key } = mapResults[i];\n                var { val } = mapResults[i];\n                if (hasOwnProperty.call(result, key)) {\n                    result[key].push(val);\n                } else {\n                    result[key] = [\n                        val\n                    ];\n                }\n            }\n        }\n        return callback(err, result);\n    });\n}\nvar groupByLimit$1 = awaitify(groupByLimit, 4);\n/**\n * Returns a new object, where each value corresponds to an array of items, from\n * `coll`, that returned the corresponding key. That is, the keys of the object\n * correspond to the values passed to the `iteratee` callback.\n *\n * Note: Since this function applies the `iteratee` to each item in parallel,\n * there is no guarantee that the `iteratee` functions will complete in order.\n * However, the values for each key in the `result` will be in the same order as\n * the original `coll`. For Objects, the values will roughly be in the order of\n * the original Objects' keys (but this can vary across JavaScript engines).\n *\n * @name groupBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * const files = ['dir1/file1.txt','dir2','dir4']\n *\n * // asynchronous function that detects file type as none, file, or directory\n * function detectFile(file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(null, 'none');\n *         }\n *         callback(null, stat.isDirectory() ? 'directory' : 'file');\n *     });\n * }\n *\n * //Using callbacks\n * async.groupBy(files, detectFile, function(err, result) {\n *     if(err) {\n *         console.log(err);\n *     } else {\n *\t       console.log(result);\n *         // {\n *         //     file: [ 'dir1/file1.txt' ],\n *         //     none: [ 'dir4' ],\n *         //     directory: [ 'dir2']\n *         // }\n *         // result is object containing the files grouped by type\n *     }\n * });\n *\n * // Using Promises\n * async.groupBy(files, detectFile)\n * .then( result => {\n *     console.log(result);\n *     // {\n *     //     file: [ 'dir1/file1.txt' ],\n *     //     none: [ 'dir4' ],\n *     //     directory: [ 'dir2']\n *     // }\n *     // result is object containing the files grouped by type\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.groupBy(files, detectFile);\n *         console.log(result);\n *         // {\n *         //     file: [ 'dir1/file1.txt' ],\n *         //     none: [ 'dir4' ],\n *         //     directory: [ 'dir2']\n *         // }\n *         // result is object containing the files grouped by type\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */ function groupBy(coll, iteratee, callback) {\n    return groupByLimit$1(coll, Infinity, iteratee, callback);\n}\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n *\n * @name groupBySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whose\n * properties are arrays of values which returned the corresponding key.\n * @returns {Promise} a promise, if no callback is passed\n */ function groupBySeries(coll, iteratee, callback) {\n    return groupByLimit$1(coll, 1, iteratee, callback);\n}\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */ var log = consoleFunc(\"log\");\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback is passed\n */ function mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback);\n    var newObj = {};\n    var _iteratee = wrapAsync(iteratee);\n    return eachOfLimit$2(limit)(obj, (val, key, next)=>{\n        _iteratee(val, key, (err, result)=>{\n            if (err) return next(err);\n            newObj[key] = result;\n            next(err);\n        });\n    }, (err)=>callback(err, newObj));\n}\nvar mapValuesLimit$1 = awaitify(mapValuesLimit, 4);\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n * // file4.txt does not exist\n *\n * const fileMap = {\n *     f1: 'file1.txt',\n *     f2: 'file2.txt',\n *     f3: 'file3.txt'\n * };\n *\n * const withMissingFileMap = {\n *     f1: 'file1.txt',\n *     f2: 'file2.txt',\n *     f3: 'file4.txt'\n * };\n *\n * // asynchronous function that returns the file size in bytes\n * function getFileSizeInBytes(file, key, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // result is now a map of file size in bytes for each file, e.g.\n *         // {\n *         //     f1: 1000,\n *         //     f2: 2000,\n *         //     f3: 3000\n *         // }\n *     }\n * });\n *\n * // Error handling\n * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     } else {\n *         console.log(result);\n *     }\n * });\n *\n * // Using Promises\n * async.mapValues(fileMap, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n *     // result is now a map of file size in bytes for each file, e.g.\n *     // {\n *     //     f1: 1000,\n *     //     f2: 2000,\n *     //     f3: 3000\n *     // }\n * }).catch (err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.mapValues(withMissingFileMap, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n * }).catch (err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.mapValues(fileMap, getFileSizeInBytes);\n *         console.log(result);\n *         // result is now a map of file size in bytes for each file, e.g.\n *         // {\n *         //     f1: 1000,\n *         //     f2: 2000,\n *         //     f3: 3000\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);\n *         console.log(result);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */ function mapValues(obj, iteratee, callback) {\n    return mapValuesLimit$1(obj, Infinity, iteratee, callback);\n}\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback is passed\n */ function mapValuesSeries(obj, iteratee, callback) {\n    return mapValuesLimit$1(obj, 1, iteratee, callback);\n}\n/**\n * Caches the results of an async function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * **Note: if the async function errs, the result will not be cached and\n * subsequent calls will call the wrapped function.**\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {AsyncFunction} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */ function memoize(fn, hasher = (v)=>v) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    var _fn = wrapAsync(fn);\n    var memoized = initialParams((args, callback)=>{\n        var key = hasher(...args);\n        if (key in memo) {\n            setImmediate$1(()=>callback(null, ...memo[key]));\n        } else if (key in queues) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [\n                callback\n            ];\n            _fn(...args, (err, ...resultArgs)=>{\n                // #1465 don't memoize if an error occurred\n                if (!err) {\n                    memo[key] = resultArgs;\n                }\n                var q = queues[key];\n                delete queues[key];\n                for(var i = 0, l = q.length; i < l; i++){\n                    q[i](err, ...resultArgs);\n                }\n            });\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n/* istanbul ignore file */ /**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `process.nextTick`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.setImmediate]{@link module:Utils.setImmediate}\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */ var _defer;\nif (hasNextTick) {\n    _defer = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer = setImmediate;\n} else {\n    _defer = fallback;\n}\nvar nextTick = wrap(_defer);\nvar _parallel = awaitify((eachfn, tasks, callback)=>{\n    var results = isArrayLike(tasks) ? [] : {};\n    eachfn(tasks, (task, key, taskCb)=>{\n        wrapAsync(task)((err, ...result)=>{\n            if (result.length < 2) {\n                [result] = result;\n            }\n            results[key] = result;\n            taskCb(err);\n        });\n    }, (err)=>callback(err, results));\n}, 3);\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n * execution of other tasks when a task fails.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n *\n * @example\n *\n * //Using Callbacks\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ], function(err, results) {\n *     console.log(results);\n *     // results is equal to ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * });\n *\n * //Using Promises\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ]).then(results => {\n *     console.log(results);\n *     // results is equal to ['one','two'] even though\n *     // the second function had a shorter timeout.\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }).then(results => {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.parallel([\n *             function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 'one');\n *                 }, 200);\n *             },\n *             function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 'two');\n *                 }, 100);\n *             }\n *         ]);\n *         console.log(results);\n *         // results is equal to ['one','two'] even though\n *         // the second function had a shorter timeout.\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // an example using an object instead of an array\n * async () => {\n *     try {\n *         let results = await async.parallel({\n *             one: function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 1);\n *                 }, 200);\n *             },\n *            two: function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 2);\n *                 }, 100);\n *            }\n *         });\n *         console.log(results);\n *         // results is equal to: { one: 1, two: 2 }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */ function parallel(tasks, callback) {\n    return _parallel(eachOf$1, tasks, callback);\n}\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n */ function parallelLimit(tasks, limit, callback) {\n    return _parallel(eachOfLimit$2(limit), tasks, callback);\n}\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Iterable} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {number} payload - an integer that specifies how many items are\n * passed to the worker function at a time. only applies if this is a\n * [cargo]{@link module:ControlFlow.cargo} object\n * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns\n * a promise that rejects if an error occurs.\n * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns\n * a promise that rejects if an error occurs.\n * @property {Function} remove - remove items from the queue that match a test\n * function.  The test function will be passed an object with a `data` property,\n * and a `priority` property, if this is a\n * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n * `function ({data, priority}) {}` and returns a Boolean.\n * @property {Function} saturated - a function that sets a callback that is\n * called when the number of running workers hits the `concurrency` limit, and\n * further tasks will be queued.  If the callback is omitted, `q.saturated()`\n * returns a promise for the next occurrence.\n * @property {Function} unsaturated - a function that sets a callback that is\n * called when the number of running workers is less than the `concurrency` &\n * `buffer` limits, and further tasks will not be queued. If the callback is\n * omitted, `q.unsaturated()` returns a promise for the next occurrence.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a function that sets a callback that is called\n * when the last item from the `queue` is given to a `worker`. If the callback\n * is omitted, `q.empty()` returns a promise for the next occurrence.\n * @property {Function} drain - a function that sets a callback that is called\n * when the last item from the `queue` has returned from the `worker`. If the\n * callback is omitted, `q.drain()` returns a promise for the next occurrence.\n * @property {Function} error - a function that sets a callback that is called\n * when a task errors. Has the signature `function(error, task)`. If the\n * callback is omitted, `error()` returns a promise that rejects on the next\n * error.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. No more tasks\n * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.\n *\n * @example\n * const q = async.queue(worker, 2)\n * q.push(item1)\n * q.push(item2)\n * q.push(item3)\n * // queues are iterable, spread into an array to inspect\n * const items = [...q] // [item1, item2, item3]\n * // or use for of\n * for (let item of q) {\n *     console.log(item)\n * }\n *\n * q.drain(() => {\n *     console.log('all done')\n * })\n * // or\n * await q.drain()\n */ /**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`. Invoked with (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain(function() {\n *     console.log('all items have been processed');\n * });\n * // or await the end\n * await q.drain()\n *\n * // assign an error callback\n * q.error(function(err, task) {\n *     console.error('task experienced an error');\n * });\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * // callback is optional\n * q.push({name: 'bar'});\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */ function queue(worker, concurrency) {\n    var _worker = wrapAsync(worker);\n    return queue$1((items, cb)=>{\n        _worker(items[0], cb);\n    }, concurrency, 1);\n}\n// Binary min-heap implementation used for priority queue.\n// Implementation is stable, i.e. push time is considered for equal priorities\nclass Heap {\n    constructor(){\n        this.heap = [];\n        this.pushCount = Number.MIN_SAFE_INTEGER;\n    }\n    get length() {\n        return this.heap.length;\n    }\n    empty() {\n        this.heap = [];\n        return this;\n    }\n    percUp(index) {\n        let p;\n        while(index > 0 && smaller(this.heap[index], this.heap[p = parent(index)])){\n            let t = this.heap[index];\n            this.heap[index] = this.heap[p];\n            this.heap[p] = t;\n            index = p;\n        }\n    }\n    percDown(index) {\n        let l;\n        while((l = leftChi(index)) < this.heap.length){\n            if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {\n                l = l + 1;\n            }\n            if (smaller(this.heap[index], this.heap[l])) {\n                break;\n            }\n            let t = this.heap[index];\n            this.heap[index] = this.heap[l];\n            this.heap[l] = t;\n            index = l;\n        }\n    }\n    push(node) {\n        node.pushCount = ++this.pushCount;\n        this.heap.push(node);\n        this.percUp(this.heap.length - 1);\n    }\n    unshift(node) {\n        return this.heap.push(node);\n    }\n    shift() {\n        let [top] = this.heap;\n        this.heap[0] = this.heap[this.heap.length - 1];\n        this.heap.pop();\n        this.percDown(0);\n        return top;\n    }\n    toArray() {\n        return [\n            ...this\n        ];\n    }\n    *[Symbol.iterator]() {\n        for(let i = 0; i < this.heap.length; i++){\n            yield this.heap[i].data;\n        }\n    }\n    remove(testFn) {\n        let j = 0;\n        for(let i = 0; i < this.heap.length; i++){\n            if (!testFn(this.heap[i])) {\n                this.heap[j] = this.heap[i];\n                j++;\n            }\n        }\n        this.heap.splice(j);\n        for(let i = parent(this.heap.length - 1); i >= 0; i--){\n            this.percDown(i);\n        }\n        return this;\n    }\n}\nfunction leftChi(i) {\n    return (i << 1) + 1;\n}\nfunction parent(i) {\n    return (i + 1 >> 1) - 1;\n}\nfunction smaller(x, y) {\n    if (x.priority !== y.priority) {\n        return x.priority < y.priority;\n    } else {\n        return x.pushCount < y.pushCount;\n    }\n}\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`.\n * Invoked with (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are three\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * `pushAsync(task, priority, [callback])` - the same as `priorityQueue.push`,\n *   except this returns a promise that rejects if an error occurs.\n * * The `unshift` and `unshiftAsync` methods were removed.\n */ function priorityQueue(worker, concurrency) {\n    // Start with a normal queue\n    var q = queue(worker, concurrency);\n    var { push, pushAsync } = q;\n    q._tasks = new Heap();\n    q._createTaskItem = ({ data, priority }, callback)=>{\n        return {\n            data,\n            priority,\n            callback\n        };\n    };\n    function createDataItems(tasks, priority) {\n        if (!Array.isArray(tasks)) {\n            return {\n                data: tasks,\n                priority\n            };\n        }\n        return tasks.map((data)=>{\n            return {\n                data,\n                priority\n            };\n        });\n    }\n    // Override push to accept second parameter representing priority\n    q.push = function(data, priority = 0, callback) {\n        return push(createDataItems(data, priority), callback);\n    };\n    q.pushAsync = function(data, priority = 0, callback) {\n        return pushAsync(createDataItems(data, priority), callback);\n    };\n    // Remove unshift functions\n    delete q.unshift;\n    delete q.unshiftAsync;\n    return q;\n}\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n * to run. Each function can complete with an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */ function race(tasks, callback) {\n    callback = once(callback);\n    if (!Array.isArray(tasks)) return callback(new TypeError(\"First argument to race must be an array of functions\"));\n    if (!tasks.length) return callback();\n    for(var i = 0, l = tasks.length; i < l; i++){\n        wrapAsync(tasks[i])(callback);\n    }\n}\nvar race$1 = awaitify(race, 2);\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee completes with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if no callback is passed\n */ function reduceRight(array, memo, iteratee, callback) {\n    var reversed = [\n        ...array\n    ].reverse();\n    return reduce$1(reversed, memo, iteratee, callback);\n}\n/**\n * Wraps the async function in another function that always completes with a\n * result object, even when it errors.\n *\n * The result object has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */ function reflect(fn) {\n    var _fn = wrapAsync(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push((error, ...cbArgs)=>{\n            let retVal = {};\n            if (error) {\n                retVal.error = error;\n            }\n            if (cbArgs.length > 0) {\n                var value = cbArgs;\n                if (cbArgs.length <= 1) {\n                    [value] = cbArgs;\n                }\n                retVal.value = value;\n            }\n            reflectCallback(null, retVal);\n        });\n        return _fn.apply(this, args);\n    });\n}\n/**\n * A helper function that wraps an array or an object of functions with `reflect`.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array|Object|Iterable} tasks - The collection of\n * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n * @returns {Array} Returns an array of async functions, each wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */ function reflectAll(tasks) {\n    var results;\n    if (Array.isArray(tasks)) {\n        results = tasks.map(reflect);\n    } else {\n        results = {};\n        Object.keys(tasks).forEach((key)=>{\n            results[key] = reflect.call(this, tasks[key]);\n        });\n    }\n    return results;\n}\nfunction reject$2(eachfn, arr, _iteratee, callback) {\n    const iteratee = wrapAsync(_iteratee);\n    return _filter(eachfn, arr, (value, cb)=>{\n        iteratee(value, (err, v)=>{\n            cb(err, !v);\n        });\n    }, callback);\n}\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n *\n * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.reject(fileList, fileExists, function(err, results) {\n *    // [ 'dir3/file6.txt' ]\n *    // results now equals an array of the non-existing files\n * });\n *\n * // Using Promises\n * async.reject(fileList, fileExists)\n * .then( results => {\n *     console.log(results);\n *     // [ 'dir3/file6.txt' ]\n *     // results now equals an array of the non-existing files\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.reject(fileList, fileExists);\n *         console.log(results);\n *         // [ 'dir3/file6.txt' ]\n *         // results now equals an array of the non-existing files\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */ function reject(coll, iteratee, callback) {\n    return reject$2(eachOf$1, coll, iteratee, callback);\n}\nvar reject$1 = awaitify(reject, 3);\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */ function rejectLimit(coll, limit, iteratee, callback) {\n    return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);\n}\nvar rejectLimit$1 = awaitify(rejectLimit, 4);\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */ function rejectSeries(coll, iteratee, callback) {\n    return reject$2(eachOfSeries$1, coll, iteratee, callback);\n}\nvar rejectSeries$1 = awaitify(rejectSeries, 3);\nfunction constant(value) {\n    return function() {\n        return value;\n    };\n}\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @returns {Promise} a promise if no callback provided\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */ const DEFAULT_TIMES = 5;\nconst DEFAULT_INTERVAL = 0;\nfunction retry(opts, task, callback) {\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant(DEFAULT_INTERVAL)\n    };\n    if (arguments.length < 3 && typeof opts === \"function\") {\n        callback = task || promiseCallback();\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || promiseCallback();\n    }\n    if (typeof task !== \"function\") {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n    var _task = wrapAsync(task);\n    var attempt = 1;\n    function retryAttempt() {\n        _task((err, ...args)=>{\n            if (err === false) return;\n            if (err && attempt++ < options.times && (typeof options.errorFilter != \"function\" || options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt - 1));\n            } else {\n                callback(err, ...args);\n            }\n        });\n    }\n    retryAttempt();\n    return callback[PROMISE_SYMBOL];\n}\nfunction parseTimes(acc, t) {\n    if (typeof t === \"object\") {\n        acc.times = +t.times || DEFAULT_TIMES;\n        acc.intervalFunc = typeof t.interval === \"function\" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);\n        acc.errorFilter = t.errorFilter;\n    } else if (typeof t === \"number\" || typeof t === \"string\") {\n        acc.times = +t || DEFAULT_TIMES;\n    } else {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n}\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n * wraps a task and makes it retryable, rather than immediately calling it\n * with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`, except for a `opts.arity` that\n * is the arity of the `task` function, defaulting to `task.length`\n * @param {AsyncFunction} task - the asynchronous function to wrap.\n * This function will be passed any arguments passed to the returned wrapper.\n * Invoked with (...args, callback).\n * @returns {AsyncFunction} The wrapped function, which when invoked, will\n * retry on an error, based on the parameters specified in `opts`.\n * This function will accept the same parameters as `task`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */ function retryable(opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    let arity = opts && opts.arity || task.length;\n    if (isAsync(task)) {\n        arity += 1;\n    }\n    var _task = wrapAsync(task);\n    return initialParams((args, callback)=>{\n        if (args.length < arity - 1 || callback == null) {\n            args.push(callback);\n            callback = promiseCallback();\n        }\n        function taskFn(cb) {\n            _task(...args, cb);\n        }\n        if (opts) retry(opts, taskFn, callback);\n        else retry(taskFn, callback);\n        return callback[PROMISE_SYMBOL];\n    });\n}\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing\n * [async functions]{@link AsyncFunction} to run in series.\n * Each function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @return {Promise} a promise, if no callback is passed\n * @example\n *\n * //Using Callbacks\n * async.series([\n *     function(callback) {\n *         setTimeout(function() {\n *             // do some async task\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             // then do another async task\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ], function(err, results) {\n *     console.log(results);\n *     // results is equal to ['one','two']\n * });\n *\n * // an example using objects instead of arrays\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             // do some async task\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             // then do another async task\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * });\n *\n * //Using Promises\n * async.series([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ]).then(results => {\n *     console.log(results);\n *     // results is equal to ['one','two']\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // an example using an object instead of an array\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             // do some async task\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             // then do another async task\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }).then(results => {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.series([\n *             function(callback) {\n *                 setTimeout(function() {\n *                     // do some async task\n *                     callback(null, 'one');\n *                 }, 200);\n *             },\n *             function(callback) {\n *                 setTimeout(function() {\n *                     // then do another async task\n *                     callback(null, 'two');\n *                 }, 100);\n *             }\n *         ]);\n *         console.log(results);\n *         // results is equal to ['one','two']\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // an example using an object instead of an array\n * async () => {\n *     try {\n *         let results = await async.parallel({\n *             one: function(callback) {\n *                 setTimeout(function() {\n *                     // do some async task\n *                     callback(null, 1);\n *                 }, 200);\n *             },\n *            two: function(callback) {\n *                 setTimeout(function() {\n *                     // then do another async task\n *                     callback(null, 2);\n *                 }, 100);\n *            }\n *         });\n *         console.log(results);\n *         // results is equal to: { one: 1, two: 2 }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */ function series(tasks, callback) {\n    return _parallel(eachOfSeries$1, tasks, callback);\n}\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,\n *    function(err, result) {\n *        console.log(result);\n *        // true\n *        // result is true since some file in the list exists\n *    }\n *);\n *\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,\n *    function(err, result) {\n *        console.log(result);\n *        // false\n *        // result is false since none of the files exists\n *    }\n *);\n *\n * // Using Promises\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)\n * .then( result => {\n *     console.log(result);\n *     // true\n *     // result is true since some file in the list exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)\n * .then( result => {\n *     console.log(result);\n *     // false\n *     // result is false since none of the files exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);\n *         console.log(result);\n *         // true\n *         // result is true since some file in the list exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * async () => {\n *     try {\n *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);\n *         console.log(result);\n *         // false\n *         // result is false since none of the files exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */ function some(coll, iteratee, callback) {\n    return _createTester(Boolean, (res)=>res)(eachOf$1, coll, iteratee, callback);\n}\nvar some$1 = awaitify(some, 3);\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */ function someLimit(coll, limit, iteratee, callback) {\n    return _createTester(Boolean, (res)=>res)(eachOfLimit$2(limit), coll, iteratee, callback);\n}\nvar someLimit$1 = awaitify(someLimit, 4);\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in series.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */ function someSeries(coll, iteratee, callback) {\n    return _createTester(Boolean, (res)=>res)(eachOfSeries$1, coll, iteratee, callback);\n}\nvar someSeries$1 = awaitify(someSeries, 3);\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a value to use as the sort criteria as\n * its `result`.\n * Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback passed\n * @example\n *\n * // bigfile.txt is a file that is 251100 bytes in size\n * // mediumfile.txt is a file that is 11000 bytes in size\n * // smallfile.txt is a file that is 121 bytes in size\n *\n * // asynchronous function that returns the file size in bytes\n * function getFileSizeInBytes(file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,\n *     function(err, results) {\n *         if (err) {\n *             console.log(err);\n *         } else {\n *             console.log(results);\n *             // results is now the original array of files sorted by\n *             // file size (ascending by default), e.g.\n *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n *         }\n *     }\n * );\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {\n *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n *         if (getFileSizeErr) return callback(getFileSizeErr);\n *         callback(null, fileSize);\n *     });\n * }, function(err, results) {\n *         if (err) {\n *             console.log(err);\n *         } else {\n *             console.log(results);\n *             // results is now the original array of files sorted by\n *             // file size (ascending by default), e.g.\n *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n *         }\n *     }\n * );\n *\n * // descending order\n * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {\n *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n *         if (getFileSizeErr) {\n *             return callback(getFileSizeErr);\n *         }\n *         callback(null, fileSize * -1);\n *     });\n * }, function(err, results) {\n *         if (err) {\n *             console.log(err);\n *         } else {\n *             console.log(results);\n *             // results is now the original array of files sorted by\n *             // file size (ascending by default), e.g.\n *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']\n *         }\n *     }\n * );\n *\n * // Error handling\n * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,\n *     function(err, results) {\n *         if (err) {\n *             console.log(err);\n *             // [ Error: ENOENT: no such file or directory ]\n *         } else {\n *             console.log(results);\n *         }\n *     }\n * );\n *\n * // Using Promises\n * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n *     // results is now the original array of files sorted by\n *     // file size (ascending by default), e.g.\n *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error handling\n * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * (async () => {\n *     try {\n *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n *         console.log(results);\n *         // results is now the original array of files sorted by\n *         // file size (ascending by default), e.g.\n *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * })();\n *\n * // Error handling\n * async () => {\n *     try {\n *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n *         console.log(results);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */ function sortBy(coll, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return map$1(coll, (x, iterCb)=>{\n        _iteratee(x, (err, criteria)=>{\n            if (err) return iterCb(err);\n            iterCb(err, {\n                value: x,\n                criteria\n            });\n        });\n    }, (err, results)=>{\n        if (err) return callback(err);\n        callback(null, results.sort(comparator).map((v)=>v.value));\n    });\n    function comparator(left, right) {\n        var a = left.criteria, b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\nvar sortBy$1 = awaitify(sortBy, 3);\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} asyncFn - The async function to limit in time.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n * of the control flow functions.\n * Invoke this function with the same parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */ function timeout(asyncFn, milliseconds, info) {\n    var fn = wrapAsync(asyncFn);\n    return initialParams((args, callback)=>{\n        var timedOut = false;\n        var timer;\n        function timeoutCallback() {\n            var name = asyncFn.name || \"anonymous\";\n            var error = new Error('Callback function \"' + name + '\" timed out.');\n            error.code = \"ETIMEDOUT\";\n            if (info) {\n                error.info = info;\n            }\n            timedOut = true;\n            callback(error);\n        }\n        args.push((...cbArgs)=>{\n            if (!timedOut) {\n                callback(...cbArgs);\n                clearTimeout(timer);\n            }\n        });\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        fn(...args);\n    });\n}\nfunction range(size) {\n    var result = Array(size);\n    while(size--){\n        result[size] = size;\n    }\n    return result;\n}\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n * @returns {Promise} a promise, if no callback is provided\n */ function timesLimit(count, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(range(count), limit, _iteratee, callback);\n}\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @returns {Promise} a promise, if no callback is provided\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */ function times(n, iteratee, callback) {\n    return timesLimit(n, Infinity, iteratee, callback);\n}\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @returns {Promise} a promise, if no callback is provided\n */ function timesSeries(n, iteratee, callback) {\n    return timesLimit(n, 1, iteratee, callback);\n}\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in parallel, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n *\n * // helper function that returns human-readable size format from bytes\n * function formatBytes(bytes, decimals = 2) {\n *   // implementation not included for brevity\n *   return humanReadbleFilesize;\n * }\n *\n * const fileList = ['file1.txt','file2.txt','file3.txt'];\n *\n * // asynchronous function that returns the file size, transformed to human-readable format\n * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n * function transformFileSize(acc, value, key, callback) {\n *     fs.stat(value, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         acc[key] = formatBytes(stat.size);\n *         callback(null);\n *     });\n * }\n *\n * // Using callbacks\n * async.transform(fileList, transformFileSize, function(err, result) {\n *     if(err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n *     }\n * });\n *\n * // Using Promises\n * async.transform(fileList, transformFileSize)\n * .then(result => {\n *     console.log(result);\n *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * (async () => {\n *     try {\n *         let result = await async.transform(fileList, transformFileSize);\n *         console.log(result);\n *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * })();\n *\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n *\n * // helper function that returns human-readable size format from bytes\n * function formatBytes(bytes, decimals = 2) {\n *   // implementation not included for brevity\n *   return humanReadbleFilesize;\n * }\n *\n * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };\n *\n * // asynchronous function that returns the file size, transformed to human-readable format\n * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n * function transformFileSize(acc, value, key, callback) {\n *     fs.stat(value, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         acc[key] = formatBytes(stat.size);\n *         callback(null);\n *     });\n * }\n *\n * // Using callbacks\n * async.transform(fileMap, transformFileSize, function(err, result) {\n *     if(err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n *     }\n * });\n *\n * // Using Promises\n * async.transform(fileMap, transformFileSize)\n * .then(result => {\n *     console.log(result);\n *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.transform(fileMap, transformFileSize);\n *         console.log(result);\n *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */ function transform(coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3 && typeof accumulator === \"function\") {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = Array.isArray(coll) ? [] : {};\n    }\n    callback = once(callback || promiseCallback());\n    var _iteratee = wrapAsync(iteratee);\n    eachOf$1(coll, (v, k, cb)=>{\n        _iteratee(accumulator, v, k, cb);\n    }, (err)=>callback(err, accumulator));\n    return callback[PROMISE_SYMBOL];\n}\n/**\n * It runs each task in series but stops whenever any of the functions were\n * successful. If one of the tasks were successful, the `callback` will be\n * passed the result of the successful task. If all tasks fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name tryEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to\n * run, each function is passed a `callback(err, result)` it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {Function} [callback] - An optional callback which is called when one\n * of the tasks has succeeded, or all have failed. It receives the `err` and\n * `result` arguments of the last attempt at completing the `task`. Invoked with\n * (err, results).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n * async.tryEach([\n *     function getDataFromFirstWebsite(callback) {\n *         // Try getting the data from the first website\n *         callback(err, data);\n *     },\n *     function getDataFromSecondWebsite(callback) {\n *         // First website failed,\n *         // Try getting the data from the backup website\n *         callback(err, data);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     Now do something with the data.\n * });\n *\n */ function tryEach(tasks, callback) {\n    var error = null;\n    var result;\n    return eachSeries$1(tasks, (task, taskCb)=>{\n        wrapAsync(task)((err, ...args)=>{\n            if (err === false) return taskCb(err);\n            if (args.length < 2) {\n                [result] = args;\n            } else {\n                result = args;\n            }\n            error = err;\n            taskCb(err ? null : {});\n        });\n    }, ()=>callback(error, result));\n}\nvar tryEach$1 = awaitify(tryEach);\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {AsyncFunction} fn - the memoized function\n * @returns {AsyncFunction} a function that calls the original unmemoized function\n */ function unmemoize(fn) {\n    return (...args)=>{\n        return (fn.unmemoized || fn)(...args);\n    };\n}\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `iteratee`. Invoked with (callback).\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function test(cb) { cb(null, count < 5); },\n *     function iter(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */ function whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback);\n    var _fn = wrapAsync(iteratee);\n    var _test = wrapAsync(test);\n    var results = [];\n    function next(err, ...rest) {\n        if (err) return callback(err);\n        results = rest;\n        if (err === false) return;\n        _test(check);\n    }\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (err === false) return;\n        if (!truth) return callback(null, ...results);\n        _fn(next);\n    }\n    return _test(check);\n}\nvar whilst$1 = awaitify(whilst, 3);\n/**\n * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `iteratee`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `iteratee`. Invoked with (callback).\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if a callback is not passed\n *\n * @example\n * const results = []\n * let finished = false\n * async.until(function test(cb) {\n *     cb(null, finished)\n * }, function iter(next) {\n *     fetchPage(url, (err, body) => {\n *         if (err) return next(err)\n *         results = results.concat(body.objects)\n *         finished = !!body.next\n *         next(err)\n *     })\n * }, function done (err) {\n *     // all pages have been fetched\n * })\n */ function until(test, iteratee, callback) {\n    const _test = wrapAsync(test);\n    return whilst$1((cb)=>_test((err, truth)=>cb(err, !truth)), iteratee, callback);\n}\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */ function waterfall(tasks, callback) {\n    callback = once(callback);\n    if (!Array.isArray(tasks)) return callback(new Error(\"First argument to waterfall must be an array of functions\"));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n    function nextTask(args) {\n        var task = wrapAsync(tasks[taskIndex++]);\n        task(...args, onlyOnce(next));\n    }\n    function next(err, ...args) {\n        if (err === false) return;\n        if (err || taskIndex === tasks.length) {\n            return callback(err, ...args);\n        }\n        nextTask(args);\n    }\n    nextTask([]);\n}\nvar waterfall$1 = awaitify(waterfall);\n/**\n * An \"async function\" in the context of Async is an asynchronous function with\n * a variable number of parameters, with the final parameter being a callback.\n * (`function (arg1, arg2, ..., callback) {}`)\n * The final callback is of the form `callback(err, results...)`, which must be\n * called once the function is completed.  The callback should be called with a\n * Error as its first argument to signal that an error occurred.\n * Otherwise, if no error occurred, it should be called with `null` as the first\n * argument, and any additional `result` arguments that may apply, to signal\n * successful completion.\n * The callback must be called exactly once, ideally on a later tick of the\n * JavaScript event loop.\n *\n * This type of function is also referred to as a \"Node-style async function\",\n * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n * library are themselves CPS/Node-style async functions, or functions that\n * return CPS/Node-style async functions.\n *\n * Wherever we accept a Node-style async function, we also directly accept an\n * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n * In this case, the `async` function will not be passed a final callback\n * argument, and any thrown error will be used as the `err` argument of the\n * implicit callback, and the return value will be used as the `result` value.\n * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n * argument, and a `resolved` value becomes the `result`.)\n *\n * Note, due to JavaScript limitations, we can only detect native `async`\n * functions and not transpilied implementations.\n * Your environment must have `async`/`await` support for this to work.\n * (e.g. Node > v7.6, or a recent version of a modern browser).\n * If you are using `async` functions through a transpiler (e.g. Babel), you\n * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n * because the `async function` will be compiled to an ordinary function that\n * returns a promise.\n *\n * @typedef {Function} AsyncFunction\n * @static\n */ var index = {\n    apply,\n    applyEach,\n    applyEachSeries,\n    asyncify,\n    auto,\n    autoInject,\n    cargo: cargo$1,\n    cargoQueue: cargo,\n    compose,\n    concat: concat$1,\n    concatLimit: concatLimit$1,\n    concatSeries: concatSeries$1,\n    constant: constant$1,\n    detect: detect$1,\n    detectLimit: detectLimit$1,\n    detectSeries: detectSeries$1,\n    dir,\n    doUntil,\n    doWhilst: doWhilst$1,\n    each,\n    eachLimit: eachLimit$1,\n    eachOf: eachOf$1,\n    eachOfLimit: eachOfLimit$1,\n    eachOfSeries: eachOfSeries$1,\n    eachSeries: eachSeries$1,\n    ensureAsync,\n    every: every$1,\n    everyLimit: everyLimit$1,\n    everySeries: everySeries$1,\n    filter: filter$1,\n    filterLimit: filterLimit$1,\n    filterSeries: filterSeries$1,\n    forever: forever$1,\n    groupBy,\n    groupByLimit: groupByLimit$1,\n    groupBySeries,\n    log,\n    map: map$1,\n    mapLimit: mapLimit$1,\n    mapSeries: mapSeries$1,\n    mapValues,\n    mapValuesLimit: mapValuesLimit$1,\n    mapValuesSeries,\n    memoize,\n    nextTick,\n    parallel,\n    parallelLimit,\n    priorityQueue,\n    queue,\n    race: race$1,\n    reduce: reduce$1,\n    reduceRight,\n    reflect,\n    reflectAll,\n    reject: reject$1,\n    rejectLimit: rejectLimit$1,\n    rejectSeries: rejectSeries$1,\n    retry,\n    retryable,\n    seq,\n    series,\n    setImmediate: setImmediate$1,\n    some: some$1,\n    someLimit: someLimit$1,\n    someSeries: someSeries$1,\n    sortBy: sortBy$1,\n    timeout,\n    times,\n    timesLimit,\n    timesSeries,\n    transform,\n    tryEach: tryEach$1,\n    unmemoize,\n    until,\n    waterfall: waterfall$1,\n    whilst: whilst$1,\n    // aliases\n    all: every$1,\n    allLimit: everyLimit$1,\n    allSeries: everySeries$1,\n    any: some$1,\n    anyLimit: someLimit$1,\n    anySeries: someSeries$1,\n    find: detect$1,\n    findLimit: detectLimit$1,\n    findSeries: detectSeries$1,\n    flatMap: concat$1,\n    flatMapLimit: concatLimit$1,\n    flatMapSeries: concatSeries$1,\n    forEach: each,\n    forEachSeries: eachSeries$1,\n    forEachLimit: eachLimit$1,\n    forEachOf: eachOf$1,\n    forEachOfSeries: eachOfSeries$1,\n    forEachOfLimit: eachOfLimit$1,\n    inject: reduce$1,\n    foldl: reduce$1,\n    foldr: reduceRight,\n    select: filter$1,\n    selectLimit: filterLimit$1,\n    selectSeries: filterSeries$1,\n    wrapSync: asyncify,\n    during: whilst$1,\n    doDuring: doWhilst$1\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXN5bmMvZGlzdC9hc3luYy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0Q0MsR0FDRCxTQUFTQSxNQUFNQyxFQUFFLEVBQUUsR0FBR0MsSUFBSTtJQUN0QixPQUFPLENBQUMsR0FBR0MsV0FBYUYsTUFBTUMsU0FBUUM7QUFDMUM7QUFFQSxTQUFTQyxjQUFlSCxFQUFFO0lBQ3RCLE9BQU8sU0FBVSxHQUFHQyxLQUFJLFlBQVksR0FBWjtRQUNwQixJQUFJRyxXQUFXSCxLQUFLSSxHQUFHO1FBQ3ZCLE9BQU9MLEdBQUdNLElBQUksQ0FBQyxJQUFJLEVBQUVMLE1BQU1HO0lBQy9CO0FBQ0o7QUFFQSx3QkFBd0IsR0FFeEIsSUFBSUcsb0JBQW9CLE9BQU9DLG1CQUFtQixjQUFjQTtBQUNoRSxJQUFJQyxrQkFBa0IsT0FBT0MsaUJBQWlCLGNBQWNBO0FBQzVELElBQUlDLGNBQWMsT0FBT0MsWUFBWSxZQUFZLE9BQU9BLFFBQVFDLFFBQVEsS0FBSztBQUU3RSxTQUFTQyxTQUFTZCxFQUFFO0lBQ2hCZSxXQUFXZixJQUFJO0FBQ25CO0FBRUEsU0FBU2dCLEtBQUtDLEtBQUs7SUFDZixPQUFPLENBQUNqQixJQUFJLEdBQUdDLE9BQVNnQixNQUFNLElBQU1qQixNQUFNQztBQUM5QztBQUVBLElBQUlpQjtBQUVKLElBQUlYLG1CQUFtQjtJQUNuQlcsV0FBV1Y7QUFDZixPQUFPLElBQUlDLGlCQUFpQjtJQUN4QlMsV0FBV1I7QUFDZixPQUFPLElBQUlDLGFBQWE7SUFDcEJPLFdBQVdOLFFBQVFDLFFBQVE7QUFDL0IsT0FBTztJQUNISyxXQUFXSjtBQUNmO0FBRUEsSUFBSUss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O0lBQ1pDLFFBQVFLO0lBQ1JDO0lBQ0F6QjtJQUNBbUM7SUFDQUc7SUFDQUM7SUFDQUcsU0FBU0M7SUFDVEM7SUFDQUk7SUFDQUMsV0FBV0c7SUFDWFAsUUFBUUU7SUFFUixVQUFVO0lBQ1ZPLEtBQUsxSTtJQUNMMkksVUFBVXpJO0lBQ1YwSSxXQUFXeEk7SUFDWHlJLEtBQUszQztJQUNMNEMsVUFBVTFDO0lBQ1YyQyxXQUFXekM7SUFDWDBDLE1BQU0zSztJQUNONEssV0FBVzFLO0lBQ1gySyxZQUFZeks7SUFDWjBLLFNBQVMxTDtJQUNUMkwsY0FBYzVMO0lBQ2Q2TCxlQUFlMUw7SUFDZjVJLFNBQVN3SztJQUNUK0osZUFBZTNKO0lBQ2Y0SixjQUFjOUo7SUFDZCtKLFdBQVdoVztJQUNYaVcsaUJBQWlCN1Y7SUFDakI4VixnQkFBZ0IxVztJQUNoQjJXLFFBQVFoTjtJQUNSaU4sT0FBT2pOO0lBQ1BrTixPQUFPN0Y7SUFDUDhGLFFBQVFsSjtJQUNSbUosYUFBYWpKO0lBQ2JrSixjQUFjaEo7SUFDZGlKLFVBQVUzYztJQUNWNGMsUUFBUS9CO0lBQ1JnQyxVQUFVaEw7QUFDZDtBQUV5aEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYWJ2aWRpeC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9hc3luYy9kaXN0L2FzeW5jLm1qcz9mY2RmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlcyBhIGNvbnRpbnVhdGlvbiBmdW5jdGlvbiB3aXRoIHNvbWUgYXJndW1lbnRzIGFscmVhZHkgYXBwbGllZC5cbiAqXG4gKiBVc2VmdWwgYXMgYSBzaG9ydGhhbmQgd2hlbiBjb21iaW5lZCB3aXRoIG90aGVyIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMuIEFueVxuICogYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gYXJlIGFkZGVkIHRvIHRoZSBhcmd1bWVudHNcbiAqIG9yaWdpbmFsbHkgcGFzc2VkIHRvIGFwcGx5LlxuICpcbiAqIEBuYW1lIGFwcGx5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseSBhbGxcbiAqIGFyZ3VtZW50cyB0by4gSW52b2tlcyB3aXRoIChhcmd1bWVudHMuLi4pLlxuICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMuLi4gLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhdXRvbWF0aWNhbGx5IGFwcGx5XG4gKiB3aGVuIHRoZSBjb250aW51YXRpb24gaXMgY2FsbGVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgcGFydGlhbGx5LWFwcGxpZWQgZnVuY3Rpb25cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gdXNpbmcgYXBwbHlcbiAqIGFzeW5jLnBhcmFsbGVsKFtcbiAqICAgICBhc3luYy5hcHBseShmcy53cml0ZUZpbGUsICd0ZXN0ZmlsZTEnLCAndGVzdDEnKSxcbiAqICAgICBhc3luYy5hcHBseShmcy53cml0ZUZpbGUsICd0ZXN0ZmlsZTInLCAndGVzdDInKVxuICogXSk7XG4gKlxuICpcbiAqIC8vIHRoZSBzYW1lIHByb2Nlc3Mgd2l0aG91dCB1c2luZyBhcHBseVxuICogYXN5bmMucGFyYWxsZWwoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGZzLndyaXRlRmlsZSgndGVzdGZpbGUxJywgJ3Rlc3QxJywgY2FsbGJhY2spO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgZnMud3JpdGVGaWxlKCd0ZXN0ZmlsZTInLCAndGVzdDInLCBjYWxsYmFjayk7XG4gKiAgICAgfVxuICogXSk7XG4gKlxuICogLy8gSXQncyBwb3NzaWJsZSB0byBwYXNzIGFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBhcmd1bWVudHMgd2hlbiBjYWxsaW5nIHRoZVxuICogLy8gY29udGludWF0aW9uOlxuICpcbiAqIG5vZGU+IHZhciBmbiA9IGFzeW5jLmFwcGx5KHN5cy5wdXRzLCAnb25lJyk7XG4gKiBub2RlPiBmbigndHdvJywgJ3RocmVlJyk7XG4gKiBvbmVcbiAqIHR3b1xuICogdGhyZWVcbiAqL1xuZnVuY3Rpb24gYXBwbHkoZm4sIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gKC4uLmNhbGxBcmdzKSA9PiBmbiguLi5hcmdzLC4uLmNhbGxBcmdzKTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbFBhcmFtcyAoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MvKiwgY2FsbGJhY2sqLykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhcmdzLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cblxudmFyIGhhc1F1ZXVlTWljcm90YXNrID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nICYmIHF1ZXVlTWljcm90YXNrO1xudmFyIGhhc1NldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgc2V0SW1tZWRpYXRlO1xudmFyIGhhc05leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBmYWxsYmFjayhmbikge1xuICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiB3cmFwKGRlZmVyKSB7XG4gICAgcmV0dXJuIChmbiwgLi4uYXJncykgPT4gZGVmZXIoKCkgPT4gZm4oLi4uYXJncykpO1xufVxuXG52YXIgX2RlZmVyJDE7XG5cbmlmIChoYXNRdWV1ZU1pY3JvdGFzaykge1xuICAgIF9kZWZlciQxID0gcXVldWVNaWNyb3Rhc2s7XG59IGVsc2UgaWYgKGhhc1NldEltbWVkaWF0ZSkge1xuICAgIF9kZWZlciQxID0gc2V0SW1tZWRpYXRlO1xufSBlbHNlIGlmIChoYXNOZXh0VGljaykge1xuICAgIF9kZWZlciQxID0gcHJvY2Vzcy5uZXh0VGljaztcbn0gZWxzZSB7XG4gICAgX2RlZmVyJDEgPSBmYWxsYmFjaztcbn1cblxudmFyIHNldEltbWVkaWF0ZSQxID0gd3JhcChfZGVmZXIkMSk7XG5cbi8qKlxuICogVGFrZSBhIHN5bmMgZnVuY3Rpb24gYW5kIG1ha2UgaXQgYXN5bmMsIHBhc3NpbmcgaXRzIHJldHVybiB2YWx1ZSB0byBhXG4gKiBjYWxsYmFjay4gVGhpcyBpcyB1c2VmdWwgZm9yIHBsdWdnaW5nIHN5bmMgZnVuY3Rpb25zIGludG8gYSB3YXRlcmZhbGwsXG4gKiBzZXJpZXMsIG9yIG90aGVyIGFzeW5jIGZ1bmN0aW9ucy4gQW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGdlbmVyYXRlZFxuICogZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb24gKGV4Y2VwdCBmb3IgdGhlIGZpbmFsXG4gKiBjYWxsYmFjayBhcmd1bWVudCkuIEVycm9ycyB0aHJvd24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLlxuICpcbiAqIElmIHRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gYGFzeW5jaWZ5YCByZXR1cm5zIGEgUHJvbWlzZSwgdGhhdCBwcm9taXNlcydzXG4gKiByZXNvbHZlZC9yZWplY3RlZCBzdGF0ZSB3aWxsIGJlIHVzZWQgdG8gY2FsbCB0aGUgY2FsbGJhY2ssIHJhdGhlciB0aGFuIHNpbXBseVxuICogdGhlIHN5bmNocm9ub3VzIHJldHVybiB2YWx1ZS5cbiAqXG4gKiBUaGlzIGFsc28gbWVhbnMgeW91IGNhbiBhc3luY2lmeSBFUzIwMTcgYGFzeW5jYCBmdW5jdGlvbnMuXG4gKlxuICogQG5hbWUgYXN5bmNpZnlcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyB3cmFwU3luY1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBUaGUgc3luY2hyb25vdXMgZnVuY3Rpb24sIG9yIFByb21pc2UtcmV0dXJuaW5nXG4gKiBmdW5jdGlvbiB0byBjb252ZXJ0IHRvIGFuIHtAbGluayBBc3luY0Z1bmN0aW9ufS5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBBbiBhc3luY2hyb25vdXMgd3JhcHBlciBvZiB0aGUgYGZ1bmNgLiBUbyBiZVxuICogaW52b2tlZCB3aXRoIGAoYXJncy4uLiwgY2FsbGJhY2spYC5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gcGFzc2luZyBhIHJlZ3VsYXIgc3luY2hyb25vdXMgZnVuY3Rpb25cbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgYXN5bmMuYXBwbHkoZnMucmVhZEZpbGUsIGZpbGVuYW1lLCBcInV0ZjhcIiksXG4gKiAgICAgYXN5bmMuYXN5bmNpZnkoSlNPTi5wYXJzZSksXG4gKiAgICAgZnVuY3Rpb24gKGRhdGEsIG5leHQpIHtcbiAqICAgICAgICAgLy8gZGF0YSBpcyB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdGhlIHRleHQuXG4gKiAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHBhcnNpbmcgZXJyb3IsIGl0IHdvdWxkIGhhdmUgYmVlbiBjYXVnaHQuXG4gKiAgICAgfVxuICogXSwgY2FsbGJhY2spO1xuICpcbiAqIC8vIHBhc3NpbmcgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBwcm9taXNlXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCBmaWxlbmFtZSwgXCJ1dGY4XCIpLFxuICogICAgIGFzeW5jLmFzeW5jaWZ5KGZ1bmN0aW9uIChjb250ZW50cykge1xuICogICAgICAgICByZXR1cm4gZGIubW9kZWwuY3JlYXRlKGNvbnRlbnRzKTtcbiAqICAgICB9KSxcbiAqICAgICBmdW5jdGlvbiAobW9kZWwsIG5leHQpIHtcbiAqICAgICAgICAgLy8gYG1vZGVsYCBpcyB0aGUgaW5zdGFudGlhdGVkIG1vZGVsIG9iamVjdC5cbiAqICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yLCB0aGlzIGZ1bmN0aW9uIHdvdWxkIGJlIHNraXBwZWQuXG4gKiAgICAgfVxuICogXSwgY2FsbGJhY2spO1xuICpcbiAqIC8vIGVzMjAxNyBleGFtcGxlLCB0aG91Z2ggYGFzeW5jaWZ5YCBpcyBub3QgbmVlZGVkIGlmIHlvdXIgSlMgZW52aXJvbm1lbnRcbiAqIC8vIHN1cHBvcnRzIGFzeW5jIGZ1bmN0aW9ucyBvdXQgb2YgdGhlIGJveFxuICogdmFyIHEgPSBhc3luYy5xdWV1ZShhc3luYy5hc3luY2lmeShhc3luYyBmdW5jdGlvbihmaWxlKSB7XG4gKiAgICAgdmFyIGludGVybWVkaWF0ZVN0ZXAgPSBhd2FpdCBwcm9jZXNzRmlsZShmaWxlKTtcbiAqICAgICByZXR1cm4gYXdhaXQgc29tZVByb21pc2UoaW50ZXJtZWRpYXRlU3RlcClcbiAqIH0pKTtcbiAqXG4gKiBxLnB1c2goZmlsZXMpO1xuICovXG5mdW5jdGlvbiBhc3luY2lmeShmdW5jKSB7XG4gICAgaWYgKGlzQXN5bmMoZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzLyosIGNhbGxiYWNrKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVByb21pc2UocHJvbWlzZSwgY2FsbGJhY2spXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiByZXN1bHQgaXMgUHJvbWlzZSBvYmplY3RcbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQcm9taXNlKHJlc3VsdCwgY2FsbGJhY2spXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVByb21pc2UocHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIG51bGwsIHZhbHVlKTtcbiAgICB9LCBlcnIgPT4ge1xuICAgICAgICBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgZXJyICYmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCBlcnIubWVzc2FnZSkgPyBlcnIgOiBuZXcgRXJyb3IoZXJyKSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnJvciwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZXRJbW1lZGlhdGUkMShlID0+IHsgdGhyb3cgZSB9LCBlcnIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNBc3luYyhmbikge1xuICAgIHJldHVybiBmbltTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQXN5bmNGdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzQXN5bmNHZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jR2VuZXJhdG9yJztcbn1cblxuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd3JhcEFzeW5jKGFzeW5jRm4pIHtcbiAgICBpZiAodHlwZW9mIGFzeW5jRm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgYSBmdW5jdGlvbicpXG4gICAgcmV0dXJuIGlzQXN5bmMoYXN5bmNGbikgPyBhc3luY2lmeShhc3luY0ZuKSA6IGFzeW5jRm47XG59XG5cbi8vIGNvbmRpdGlvbmFsbHkgcHJvbWlzaWZ5IGEgZnVuY3Rpb24uXG4vLyBvbmx5IHJldHVybiBhIHByb21pc2UgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG5mdW5jdGlvbiBhd2FpdGlmeSAoYXN5bmNGbiwgYXJpdHkpIHtcbiAgICBpZiAoIWFyaXR5KSBhcml0eSA9IGFzeW5jRm4ubGVuZ3RoO1xuICAgIGlmICghYXJpdHkpIHRocm93IG5ldyBFcnJvcignYXJpdHkgaXMgdW5kZWZpbmVkJylcbiAgICBmdW5jdGlvbiBhd2FpdGFibGUgKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyaXR5IC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luY0ZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYXJnc1thcml0eSAtIDFdID0gKGVyciwgLi4uY2JBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShjYkFyZ3MubGVuZ3RoID4gMSA/IGNiQXJncyA6IGNiQXJnc1swXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmNGbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXRhYmxlXG59XG5cbmZ1bmN0aW9uIGFwcGx5RWFjaCQxIChlYWNoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlFYWNoKGZucywgLi4uY2FsbEFyZ3MpIHtcbiAgICAgICAgY29uc3QgZ28gPSBhd2FpdGlmeShmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBlYWNoZm4oZm5zLCAoZm4sIGNiKSA9PiB7XG4gICAgICAgICAgICAgICAgd3JhcEFzeW5jKGZuKS5hcHBseSh0aGF0LCBjYWxsQXJncy5jb25jYXQoY2IpKTtcbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbztcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBfYXN5bmNNYXAoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGFyciA9IGFyciB8fCBbXTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciBjb3VudGVyID0gMDtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcblxuICAgIHJldHVybiBlYWNoZm4oYXJyLCAodmFsdWUsIF8sIGl0ZXJDYikgPT4ge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIF9pdGVyYXRlZSh2YWx1ZSwgKGVyciwgdikgPT4ge1xuICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2O1xuICAgICAgICAgICAgaXRlckNiKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGVyciA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlLmxlbmd0aCA+PSAwICYmXG4gICAgICAgIHZhbHVlLmxlbmd0aCAlIDEgPT09IDA7XG59XG5cbi8vIEEgdGVtcG9yYXJ5IHZhbHVlIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGxvb3Agc2hvdWxkIGJlIGJyb2tlbi5cbi8vIFNlZSAjMTA2NCwgIzEyOTNcbmNvbnN0IGJyZWFrTG9vcCA9IHt9O1xudmFyIGJyZWFrTG9vcCQxID0gYnJlYWtMb29wO1xuXG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgZnVuY3Rpb24gd3JhcHBlciAoLi4uYXJncykge1xuICAgICAgICBpZiAoZm4gPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgdmFyIGNhbGxGbiA9IGZuO1xuICAgICAgICBmbiA9IG51bGw7XG4gICAgICAgIGNhbGxGbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih3cmFwcGVyLCBmbik7XG4gICAgcmV0dXJuIHdyYXBwZXJcbn1cblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3IgKGNvbGwpIHtcbiAgICByZXR1cm4gY29sbFtTeW1ib2wuaXRlcmF0b3JdICYmIGNvbGxbU3ltYm9sLml0ZXJhdG9yXSgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheUl0ZXJhdG9yKGNvbGwpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBsZW4gPSBjb2xsLmxlbmd0aDtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuICsraSA8IGxlbiA/IHt2YWx1ZTogY29sbFtpXSwga2V5OiBpfSA6IG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFUzIwMTVJdGVyYXRvcihpdGVyYXRvcikge1xuICAgIHZhciBpID0gLTE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoaXRlbS5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgcmV0dXJuIHt2YWx1ZTogaXRlbS52YWx1ZSwga2V5OiBpfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdEl0ZXJhdG9yKG9iaikge1xuICAgIHZhciBva2V5cyA9IG9iaiA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBsZW4gPSBva2V5cy5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBrZXkgPSBva2V5c1srK2ldO1xuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaSA8IGxlbiA/IHt2YWx1ZTogb2JqW2tleV0sIGtleX0gOiBudWxsO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yKGNvbGwpIHtcbiAgICBpZiAoaXNBcnJheUxpa2UoY29sbCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCk7XG4gICAgfVxuXG4gICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbCk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yID8gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIDogY3JlYXRlT2JqZWN0SXRlcmF0b3IoY29sbCk7XG59XG5cbmZ1bmN0aW9uIG9ubHlPbmNlKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChmbiA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLlwiKTtcbiAgICAgICAgdmFyIGNhbGxGbiA9IGZuO1xuICAgICAgICBmbiA9IG51bGw7XG4gICAgICAgIGNhbGxGbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xufVxuXG4vLyBmb3IgYXN5bmMgZ2VuZXJhdG9yc1xuZnVuY3Rpb24gYXN5bmNFYWNoT2ZMaW1pdChnZW5lcmF0b3IsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCBhd2FpdGluZyA9IGZhbHNlO1xuICAgIGxldCBydW5uaW5nID0gMDtcbiAgICBsZXQgaWR4ID0gMDtcblxuICAgIGZ1bmN0aW9uIHJlcGxlbmlzaCgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygncmVwbGVuaXNoJylcbiAgICAgICAgaWYgKHJ1bm5pbmcgPj0gbGltaXQgfHwgYXdhaXRpbmcgfHwgZG9uZSkgcmV0dXJuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3JlcGxlbmlzaCBhd2FpdGluZycpXG4gICAgICAgIGF3YWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgZ2VuZXJhdG9yLm5leHQoKS50aGVuKCh7dmFsdWUsIGRvbmU6IGl0ZXJEb25lfSkgPT4ge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZ290IHZhbHVlJywgdmFsdWUpXG4gICAgICAgICAgICBpZiAoY2FuY2VsZWQgfHwgZG9uZSkgcmV0dXJuXG4gICAgICAgICAgICBhd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGl0ZXJEb25lKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkb25lIG5leHRDYicpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydW5uaW5nKys7XG4gICAgICAgICAgICBpdGVyYXRlZSh2YWx1ZSwgaWR4LCBpdGVyYXRlZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlkeCsrO1xuICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgIH0pLmNhdGNoKGhhbmRsZUVycm9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVyciwgcmVzdWx0KSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2l0ZXJhdGVlQ2FsbGJhY2snKVxuICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgIGlmIChjYW5jZWxlZCkgcmV0dXJuXG4gICAgICAgIGlmIChlcnIpIHJldHVybiBoYW5kbGVFcnJvcihlcnIpXG5cbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ID09PSBicmVha0xvb3AkMSB8fCAoZG9uZSAmJiBydW5uaW5nIDw9IDApKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RvbmUgaXRlckNiJylcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXBsZW5pc2goKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm5cbiAgICAgICAgYXdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgcmVwbGVuaXNoKCk7XG59XG5cbnZhciBlYWNoT2ZMaW1pdCQyID0gKGxpbWl0KSA9PiB7XG4gICAgcmV0dXJuIChvYmosIGl0ZXJhdGVlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2NvbmN1cnJlbmN5IGxpbWl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMScpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBc3luY0dlbmVyYXRvcihvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNFYWNoT2ZMaW1pdChvYmosIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXN5bmNJdGVyYWJsZShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNFYWNoT2ZMaW1pdChvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCksIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRFbGVtID0gY3JlYXRlSXRlcmF0b3Iob2JqKTtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBydW5uaW5nID0gMDtcbiAgICAgICAgdmFyIGxvb3BpbmcgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZCkgcmV0dXJuXG4gICAgICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gYnJlYWtMb29wJDEgfHwgKGRvbmUgJiYgcnVubmluZyA8PSAwKSkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFsb29waW5nKSB7XG4gICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgbG9vcGluZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmICFkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBuZXh0RWxlbSgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZShlbGVtLnZhbHVlLCBlbGVtLmtleSwgb25seU9uY2UoaXRlcmF0ZWVDYWxsYmFjaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9vcGluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BlYWNoT2ZgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaE9mTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hPZl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn1cbiAqIEBhbGlhcyBmb3JFYWNoT2ZMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2hcbiAqIGl0ZW0gaW4gYGNvbGxgLiBUaGUgYGtleWAgaXMgdGhlIGl0ZW0ncyBrZXksIG9yIGluZGV4IGluIHRoZSBjYXNlIG9mIGFuXG4gKiBhcnJheS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGVhY2hPZkxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZWFjaE9mTGltaXQkMihsaW1pdCkoY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spO1xufVxuXG52YXIgZWFjaE9mTGltaXQkMSA9IGF3YWl0aWZ5KGVhY2hPZkxpbWl0LCA0KTtcblxuLy8gZWFjaE9mIGltcGxlbWVudGF0aW9uIG9wdGltaXplZCBmb3IgYXJyYXktbGlrZXNcbmZ1bmN0aW9uIGVhY2hPZkFycmF5TGlrZShjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgIGNvbXBsZXRlZCA9IDAsXG4gICAgICAgIHtsZW5ndGh9ID0gY29sbCxcbiAgICAgICAgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yQ2FsbGJhY2soZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5jZWxlZCA9PT0gdHJ1ZSkgcmV0dXJuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gZWxzZSBpZiAoKCsrY29tcGxldGVkID09PSBsZW5ndGgpIHx8IHZhbHVlID09PSBicmVha0xvb3AkMSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgaXRlcmF0ZWUoY29sbFtpbmRleF0sIGluZGV4LCBvbmx5T25jZShpdGVyYXRvckNhbGxiYWNrKSk7XG4gICAgfVxufVxuXG4vLyBhIGdlbmVyaWMgdmVyc2lvbiBvZiBlYWNoT2Ygd2hpY2ggY2FuIGhhbmRsZSBhcnJheSwgb2JqZWN0LCBhbmQgaXRlcmF0b3IgY2FzZXMuXG5mdW5jdGlvbiBlYWNoT2ZHZW5lcmljIChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZWFjaE9mTGltaXQkMShjb2xsLCBJbmZpbml0eSwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBMaWtlIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSwgZXhjZXB0IHRoYXQgaXQgcGFzc2VzIHRoZSBrZXkgKG9yIGluZGV4KSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50XG4gKiB0byB0aGUgaXRlcmF0ZWUuXG4gKlxuICogQG5hbWUgZWFjaE9mXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgZm9yRWFjaE9mXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2hcbiAqIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGRldi5qc29uIGlzIGEgZmlsZSBjb250YWluaW5nIGEgdmFsaWQganNvbiBvYmplY3QgY29uZmlnIGZvciBkZXYgZW52aXJvbm1lbnRcbiAqIC8vIGRldi5qc29uIGlzIGEgZmlsZSBjb250YWluaW5nIGEgdmFsaWQganNvbiBvYmplY3QgY29uZmlnIGZvciB0ZXN0IGVudmlyb25tZW50XG4gKiAvLyBwcm9kLmpzb24gaXMgYSBmaWxlIGNvbnRhaW5pbmcgYSB2YWxpZCBqc29uIG9iamVjdCBjb25maWcgZm9yIHByb2QgZW52aXJvbm1lbnRcbiAqIC8vIGludmFsaWQuanNvbiBpcyBhIGZpbGUgd2l0aCBhIG1hbGZvcm1lZCBqc29uIG9iamVjdFxuICpcbiAqIGxldCBjb25maWdzID0ge307IC8vZ2xvYmFsIHZhcmlhYmxlXG4gKiBsZXQgdmFsaWRDb25maWdGaWxlTWFwID0ge2RldjogJ2Rldi5qc29uJywgdGVzdDogJ3Rlc3QuanNvbicsIHByb2Q6ICdwcm9kLmpzb24nfTtcbiAqIGxldCBpbnZhbGlkQ29uZmlnRmlsZU1hcCA9IHtkZXY6ICdkZXYuanNvbicsIHRlc3Q6ICd0ZXN0Lmpzb24nLCBpbnZhbGlkOiAnaW52YWxpZC5qc29uJ307XG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgcmVhZHMgYSBqc29uIGZpbGUgYW5kIHBhcnNlcyB0aGUgY29udGVudHMgYXMganNvbiBvYmplY3RcbiAqIGZ1bmN0aW9uIHBhcnNlRmlsZShmaWxlLCBrZXksIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMucmVhZEZpbGUoZmlsZSwgXCJ1dGY4XCIsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsYmFjayhlcnIpO1xuICogICAgICAgICB0cnkge1xuICogICAgICAgICAgICAgY29uZmlnc1trZXldID0gSlNPTi5wYXJzZShkYXRhKTtcbiAqICAgICAgICAgfSBjYXRjaCAoZSkge1xuICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGNhbGxiYWNrKCk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy5mb3JFYWNoT2YodmFsaWRDb25maWdGaWxlTWFwLCBwYXJzZUZpbGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBjb25zb2xlLmxvZyhjb25maWdzKTtcbiAqICAgICAgICAgLy8gY29uZmlncyBpcyBub3cgYSBtYXAgb2YgSlNPTiBkYXRhLCBlLmcuXG4gKiAgICAgICAgIC8vIHsgZGV2OiAvL3BhcnNlZCBkZXYuanNvbiwgdGVzdDogLy9wYXJzZWQgdGVzdC5qc29uLCBwcm9kOiAvL3BhcnNlZCBwcm9kLmpzb259XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy9FcnJvciBoYW5kaW5nXG4gKiBhc3luYy5mb3JFYWNoT2YoaW52YWxpZENvbmZpZ0ZpbGVNYXAsIHBhcnNlRmlsZSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICogICAgICAgICAvLyBKU09OIHBhcnNlIGVycm9yIGV4Y2VwdGlvblxuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGNvbmZpZ3MpO1xuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5mb3JFYWNoT2YodmFsaWRDb25maWdGaWxlTWFwLCBwYXJzZUZpbGUpXG4gKiAudGhlbiggKCkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGNvbmZpZ3MpO1xuICogICAgIC8vIGNvbmZpZ3MgaXMgbm93IGEgbWFwIG9mIEpTT04gZGF0YSwgZS5nLlxuICogICAgIC8vIHsgZGV2OiAvL3BhcnNlZCBkZXYuanNvbiwgdGVzdDogLy9wYXJzZWQgdGVzdC5qc29uLCBwcm9kOiAvL3BhcnNlZCBwcm9kLmpzb259XG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvL0Vycm9yIGhhbmRpbmdcbiAqIGFzeW5jLmZvckVhY2hPZihpbnZhbGlkQ29uZmlnRmlsZU1hcCwgcGFyc2VGaWxlKVxuICogLnRoZW4oICgpID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhjb25maWdzKTtcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAqICAgICAvLyBKU09OIHBhcnNlIGVycm9yIGV4Y2VwdGlvblxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMuZm9yRWFjaE9mKHZhbGlkQ29uZmlnRmlsZU1hcCwgcGFyc2VGaWxlKTtcbiAqICAgICAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gKiAgICAgICAgIC8vIGNvbmZpZ3MgaXMgbm93IGEgbWFwIG9mIEpTT04gZGF0YSwgZS5nLlxuICogICAgICAgICAvLyB7IGRldjogLy9wYXJzZWQgZGV2Lmpzb24sIHRlc3Q6IC8vcGFyc2VkIHRlc3QuanNvbiwgcHJvZDogLy9wYXJzZWQgcHJvZC5qc29ufVxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqIC8vRXJyb3IgaGFuZGluZ1xuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5mb3JFYWNoT2YoaW52YWxpZENvbmZpZ0ZpbGVNYXAsIHBhcnNlRmlsZSk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGNvbmZpZ3MpO1xuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgIC8vIEpTT04gcGFyc2UgZXJyb3IgZXhjZXB0aW9uXG4gKiAgICAgfVxuICogfVxuICpcbiAqL1xuZnVuY3Rpb24gZWFjaE9mKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBlYWNoT2ZJbXBsZW1lbnRhdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGwpID8gZWFjaE9mQXJyYXlMaWtlIDogZWFjaE9mR2VuZXJpYztcbiAgICByZXR1cm4gZWFjaE9mSW1wbGVtZW50YXRpb24oY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spO1xufVxuXG52YXIgZWFjaE9mJDEgPSBhd2FpdGlmeShlYWNoT2YsIDMpO1xuXG4vKipcbiAqIFByb2R1Y2VzIGEgbmV3IGNvbGxlY3Rpb24gb2YgdmFsdWVzIGJ5IG1hcHBpbmcgZWFjaCB2YWx1ZSBpbiBgY29sbGAgdGhyb3VnaFxuICogdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSBgY29sbGBcbiAqIGFuZCBhIGNhbGxiYWNrIGZvciB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nLiBFYWNoIG9mIHRoZXNlIGNhbGxiYWNrc1xuICogdGFrZXMgMiBhcmd1bWVudHM6IGFuIGBlcnJvcmAsIGFuZCB0aGUgdHJhbnNmb3JtZWQgaXRlbSBmcm9tIGBjb2xsYC4gSWZcbiAqIGBpdGVyYXRlZWAgcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZVxuICogYG1hcGAgZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBOb3RlLCB0aGF0IHNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW5cbiAqIHBhcmFsbGVsLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZVxuICogaW4gb3JkZXIuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIGFycmF5IHdpbGwgYmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4gKiBvcmlnaW5hbCBgY29sbGAuXG4gKlxuICogSWYgYG1hcGAgaXMgcGFzc2VkIGFuIE9iamVjdCwgdGhlIHJlc3VsdHMgd2lsbCBiZSBhbiBBcnJheS4gIFRoZSByZXN1bHRzXG4gKiB3aWxsIHJvdWdobHkgYmUgaW4gdGhlIG9yZGVyIG9mIHRoZSBvcmlnaW5hbCBPYmplY3RzJyBrZXlzIChidXQgdGhpcyBjYW5cbiAqIHZhcnkgYWNyb3NzIEphdmFTY3JpcHQgZW5naW5lcykuXG4gKlxuICogQG5hbWUgbWFwXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIEFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZmlsZTEudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDEwMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gZmlsZTIudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDIwMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gZmlsZTMudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDMwMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gZmlsZTQudHh0IGRvZXMgbm90IGV4aXN0XG4gKlxuICogY29uc3QgZmlsZUxpc3QgPSBbJ2ZpbGUxLnR4dCcsJ2ZpbGUyLnR4dCcsJ2ZpbGUzLnR4dCddO1xuICogY29uc3Qgd2l0aE1pc3NpbmdGaWxlTGlzdCA9IFsnZmlsZTEudHh0JywnZmlsZTIudHh0JywnZmlsZTQudHh0J107XG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZmlsZSBzaXplIGluIGJ5dGVzXG4gKiBmdW5jdGlvbiBnZXRGaWxlU2l6ZUluQnl0ZXMoZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5zdGF0KGZpbGUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCBzdGF0LnNpemUpO1xuICogICAgIH0pO1xuICogfVxuICpcbiAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMubWFwKGZpbGVMaXN0LCBnZXRGaWxlU2l6ZUluQnl0ZXMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgLy8gcmVzdWx0cyBpcyBub3cgYW4gYXJyYXkgb2YgdGhlIGZpbGUgc2l6ZSBpbiBieXRlcyBmb3IgZWFjaCBmaWxlLCBlLmcuXG4gKiAgICAgICAgIC8vIFsgMTAwMCwgMjAwMCwgMzAwMF1cbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMubWFwKHdpdGhNaXNzaW5nRmlsZUxpc3QsIGdldEZpbGVTaXplSW5CeXRlcywgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgaWYgKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5tYXAoZmlsZUxpc3QsIGdldEZpbGVTaXplSW5CeXRlcylcbiAqIC50aGVuKCByZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiB0aGUgZmlsZSBzaXplIGluIGJ5dGVzIGZvciBlYWNoIGZpbGUsIGUuZy5cbiAqICAgICAvLyBbIDEwMDAsIDIwMDAsIDMwMDBdXG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jLm1hcCh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gKiAudGhlbiggcmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMubWFwKGZpbGVMaXN0LCBnZXRGaWxlU2l6ZUluQnl0ZXMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgLy8gcmVzdWx0cyBpcyBub3cgYW4gYXJyYXkgb2YgdGhlIGZpbGUgc2l6ZSBpbiBieXRlcyBmb3IgZWFjaCBmaWxlLCBlLmcuXG4gKiAgICAgICAgIC8vIFsgMTAwMCwgMjAwMCwgMzAwMF1cbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMubWFwKHdpdGhNaXNzaW5nRmlsZUxpc3QsIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgfVxuICogfVxuICpcbiAqL1xuZnVuY3Rpb24gbWFwIChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2FzeW5jTWFwKGVhY2hPZiQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgbWFwJDEgPSBhd2FpdGlmeShtYXAsIDMpO1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyB0byBlYWNoIGZ1bmN0aW9uIGluIHRoZSBhcnJheSwgY2FsbGluZ1xuICogYGNhbGxiYWNrYCBhZnRlciBhbGwgZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBJZiB5b3Ugb25seSBwcm92aWRlIHRoZSBmaXJzdFxuICogYXJndW1lbnQsIGBmbnNgLCB0aGVuIGl0IHdpbGwgcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggbGV0cyB5b3UgcGFzcyBpbiB0aGVcbiAqIGFyZ3VtZW50cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwuIElmIG1vcmUgYXJndW1lbnRzIGFyZVxuICogcHJvdmlkZWQsIGBjYWxsYmFja2AgaXMgcmVxdWlyZWQgd2hpbGUgYGFyZ3NgIGlzIHN0aWxsIG9wdGlvbmFsLiBUaGUgcmVzdWx0c1xuICogZm9yIGVhY2ggb2YgdGhlIGFwcGxpZWQgYXN5bmMgZnVuY3Rpb25zIGFyZSBwYXNzZWQgdG8gdGhlIGZpbmFsIGNhbGxiYWNrXG4gKiBhcyBhbiBhcnJheS5cbiAqXG4gKiBAbmFtZSBhcHBseUVhY2hcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGZucyAtIEEgY29sbGVjdGlvbiBvZiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zXG4gKiB0byBhbGwgY2FsbCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50c1xuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gLSBhbnkgbnVtYmVyIG9mIHNlcGFyYXRlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZVxuICogZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gdGhlIGZpbmFsIGFyZ3VtZW50IHNob3VsZCBiZSB0aGUgY2FsbGJhY2ssXG4gKiBjYWxsZWQgd2hlbiBhbGwgZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkIHByb2Nlc3NpbmcuXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gLSBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBubyBhcmdzIG90aGVyIHRoYW5cbiAqIGFuIG9wdGlvbmFsIGNhbGxiYWNrLCB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGBhcmdzYCB0byBlYWNoXG4gKiBvZiB0aGUgZnVuY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqXG4gKiBjb25zdCBhcHBsaWVkRm4gPSBhc3luYy5hcHBseUVhY2goW2VuYWJsZVNlYXJjaCwgdXBkYXRlU2NoZW1hXSwgJ2J1Y2tldCcpXG4gKlxuICogYXBwbGllZEZuKChlcnIsIHJlc3VsdHMpID0+IHtcbiAqICAgICAvLyByZXN1bHRzWzBdIGlzIHRoZSByZXN1bHRzIGZvciBgZW5hYmxlU2VhcmNoYFxuICogICAgIC8vIHJlc3VsdHNbMV0gaXMgdGhlIHJlc3VsdHMgZm9yIGB1cGRhdGVTY2hlbWFgXG4gKiB9KTtcbiAqXG4gKiAvLyBwYXJ0aWFsIGFwcGxpY2F0aW9uIGV4YW1wbGU6XG4gKiBhc3luYy5lYWNoKFxuICogICAgIGJ1Y2tldHMsXG4gKiAgICAgYXN5bmMgKGJ1Y2tldCkgPT4gYXN5bmMuYXBwbHlFYWNoKFtlbmFibGVTZWFyY2gsIHVwZGF0ZVNjaGVtYV0sIGJ1Y2tldCkoKSxcbiAqICAgICBjYWxsYmFja1xuICogKTtcbiAqL1xudmFyIGFwcGx5RWFjaCA9IGFwcGx5RWFjaCQxKG1hcCQxKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGVhY2hPZmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hPZl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn1cbiAqIEBhbGlhcyBmb3JFYWNoT2ZTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGVhY2hPZlNlcmllcyhjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZWFjaE9mTGltaXQkMShjb2xsLCAxLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgZWFjaE9mU2VyaWVzJDEgPSBhd2FpdGlmeShlYWNoT2ZTZXJpZXMsIDMpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgbWFwYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBpdGVtLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheSBvZiB0aGVcbiAqIHRyYW5zZm9ybWVkIGl0ZW1zIGZyb20gdGhlIGBjb2xsYC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIG1hcFNlcmllcyAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9hc3luY01hcChlYWNoT2ZTZXJpZXMkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIG1hcFNlcmllcyQxID0gYXdhaXRpZnkobWFwU2VyaWVzLCAzKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGFwcGx5RWFjaGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hcHBseUVhY2h9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBhcHBseUVhY2hTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmFwcGx5RWFjaF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmFwcGx5RWFjaH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGZucyAtIEEgY29sbGVjdGlvbiBvZiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIHRvIGFsbFxuICogY2FsbCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50c1xuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gLSBhbnkgbnVtYmVyIG9mIHNlcGFyYXRlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZVxuICogZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gdGhlIGZpbmFsIGFyZ3VtZW50IHNob3VsZCBiZSB0aGUgY2FsbGJhY2ssXG4gKiBjYWxsZWQgd2hlbiBhbGwgZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkIHByb2Nlc3NpbmcuXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gLSBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCBpcyB0aGUgcmVzdWx0IG9mXG4gKiBhcHBsaW5nIHRoZSBgYXJnc2AgdG8gdGhlIGxpc3Qgb2YgZnVuY3Rpb25zLiAgSXQgdGFrZXMgbm8gYXJncywgb3RoZXIgdGhhblxuICogYSBjYWxsYmFjay5cbiAqL1xudmFyIGFwcGx5RWFjaFNlcmllcyA9IGFwcGx5RWFjaCQxKG1hcFNlcmllcyQxKTtcblxuY29uc3QgUFJPTUlTRV9TWU1CT0wgPSBTeW1ib2woJ3Byb21pc2VDYWxsYmFjaycpO1xuXG5mdW5jdGlvbiBwcm9taXNlQ2FsbGJhY2sgKCkge1xuICAgIGxldCByZXNvbHZlLCByZWplY3Q7XG4gICAgZnVuY3Rpb24gY2FsbGJhY2sgKGVyciwgLi4uYXJncykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgcmVzb2x2ZShhcmdzLmxlbmd0aCA+IDEgPyBhcmdzIDogYXJnc1swXSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tbUFJPTUlTRV9TWU1CT0xdID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSByZXMsXG4gICAgICAgIHJlamVjdCA9IHJlajtcbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFja1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3Qgb3JkZXIgZm9yIHJ1bm5pbmcgdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufXMgaW4gYHRhc2tzYCwgYmFzZWQgb25cbiAqIHRoZWlyIHJlcXVpcmVtZW50cy4gRWFjaCBmdW5jdGlvbiBjYW4gb3B0aW9uYWxseSBkZXBlbmQgb24gb3RoZXIgZnVuY3Rpb25zXG4gKiBiZWluZyBjb21wbGV0ZWQgZmlyc3QsIGFuZCBlYWNoIGZ1bmN0aW9uIGlzIHJ1biBhcyBzb29uIGFzIGl0cyByZXF1aXJlbWVudHNcbiAqIGFyZSBzYXRpc2ZpZWQuXG4gKlxuICogSWYgYW55IG9mIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2ssIHRoZSBgYXV0b2Agc2VxdWVuY2VcbiAqIHdpbGwgc3RvcC4gRnVydGhlciB0YXNrcyB3aWxsIG5vdCBleGVjdXRlIChzbyBhbnkgb3RoZXIgZnVuY3Rpb25zIGRlcGVuZGluZ1xuICogb24gaXQgd2lsbCBub3QgcnVuKSwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlXG4gKiBlcnJvci5cbiAqXG4gKiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGFsc28gcmVjZWl2ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiBmdW5jdGlvbnMgd2hpY2hcbiAqIGhhdmUgY29tcGxldGVkIHNvIGZhciBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHRoZXkgaGF2ZSBkZXBlbmRlbmNpZXMuIElmIGFcbiAqIHRhc2sgZnVuY3Rpb24gaGFzIG5vIGRlcGVuZGVuY2llcywgaXQgd2lsbCBvbmx5IGJlIHBhc3NlZCBhIGNhbGxiYWNrLlxuICpcbiAqIEBuYW1lIGF1dG9cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdC4gRWFjaCBvZiBpdHMgcHJvcGVydGllcyBpcyBlaXRoZXIgYVxuICogZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2YgcmVxdWlyZW1lbnRzLCB3aXRoIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn0gaXRzZWxmIHRoZSBsYXN0IGl0ZW1cbiAqIGluIHRoZSBhcnJheS4gVGhlIG9iamVjdCdzIGtleSBvZiBhIHByb3BlcnR5IHNlcnZlcyBhcyB0aGUgbmFtZSBvZiB0aGUgdGFza1xuICogZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yXG4gKiBvdGhlciB0YXNrcy4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIG9uZSBvciB0d28gYXJndW1lbnRzOlxuICogKiBhIGByZXN1bHRzYCBvYmplY3QsIGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzbHkgZXhlY3V0ZWRcbiAqICAgZnVuY3Rpb25zLCBvbmx5IHBhc3NlZCBpZiB0aGUgdGFzayBoYXMgYW55IGRlcGVuZGVuY2llcyxcbiAqICogYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCBmdW5jdGlvbiwgd2hpY2ggbXVzdCBiZSBjYWxsZWQgd2hlbiBmaW5pc2hlZCxcbiAqICAgcGFzc2luZyBhbiBgZXJyb3JgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24nc1xuICogICBleGVjdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSAtIEFuIG9wdGlvbmFsIGBpbnRlZ2VyYCBmb3JcbiAqIGRldGVybWluaW5nIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0YXNrcyB0aGF0IGNhbiBiZSBydW4gaW4gcGFyYWxsZWwuIEJ5XG4gKiBkZWZhdWx0LCBhcyBtYW55IGFzIHBvc3NpYmxlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogdGhlIHRhc2tzIGhhdmUgYmVlbiBjb21wbGV0ZWQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYCBhcmd1bWVudCBpZiBhbnkgYHRhc2tzYFxuICogcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjay4gUmVzdWx0cyBhcmUgYWx3YXlzIHJldHVybmVkOyBob3dldmVyLCBpZiBhblxuICogZXJyb3Igb2NjdXJzLCBubyBmdXJ0aGVyIGB0YXNrc2Agd2lsbCBiZSBwZXJmb3JtZWQsIGFuZCB0aGUgcmVzdWx0cyBvYmplY3RcbiAqIHdpbGwgb25seSBjb250YWluIHBhcnRpYWwgcmVzdWx0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBub3QgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vVXNpbmcgQ2FsbGJhY2tzXG4gKiBhc3luYy5hdXRvKHtcbiAqICAgICBnZXRfZGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheScpO1xuICogICAgIH0sXG4gKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gY3JlYXRlIGEgZGlyZWN0b3J5IHRvIHN0b3JlIGEgZmlsZSBpblxuICogICAgICAgICAvLyB0aGlzIGlzIHJ1biBhdCB0aGUgc2FtZSB0aW1lIGFzIGdldHRpbmcgdGhlIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpO1xuICogICAgIH0sXG4gKiAgICAgd3JpdGVfZmlsZTogWydnZXRfZGF0YScsICdtYWtlX2ZvbGRlcicsIGZ1bmN0aW9uKHJlc3VsdHMsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cyxcbiAqICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnlcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZpbGVuYW1lJyk7XG4gKiAgICAgfV0sXG4gKiAgICAgZW1haWxfbGluazogWyd3cml0ZV9maWxlJywgZnVuY3Rpb24ocmVzdWx0cywgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gb25jZSB0aGUgZmlsZSBpcyB3cml0dGVuIGxldCdzIGVtYWlsIGEgbGluayB0byBpdC4uLlxuICogICAgICAgICBjYWxsYmFjayhudWxsLCB7J2ZpbGUnOnJlc3VsdHMud3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAqICAgICB9XVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgaWYgKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICB9XG4gKiAgICAgY29uc29sZS5sb2coJ3Jlc3VsdHMgPSAnLCByZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzID0ge1xuICogICAgIC8vICAgICBnZXRfZGF0YTogWydkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheSddXG4gKiAgICAgLy8gICAgIG1ha2VfZm9sZGVyOyAnZm9sZGVyJyxcbiAqICAgICAvLyAgICAgd3JpdGVfZmlsZTogJ2ZpbGVuYW1lJ1xuICogICAgIC8vICAgICBlbWFpbF9saW5rOiB7IGZpbGU6ICdmaWxlbmFtZScsIGVtYWlsOiAndXNlckBleGFtcGxlLmNvbScgfVxuICogICAgIC8vIH1cbiAqIH0pO1xuICpcbiAqIC8vVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaW4gZ2V0X2RhdGEnKTtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheScpO1xuICogICAgIH0sXG4gKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBtYWtlX2ZvbGRlcicpO1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSB0byBzdG9yZSBhIGZpbGUgaW5cbiAqICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmb2xkZXInKTtcbiAqICAgICB9LFxuICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBvbmNlIHRoZXJlIGlzIHNvbWUgZGF0YSBhbmQgdGhlIGRpcmVjdG9yeSBleGlzdHMsXG4gKiAgICAgICAgIC8vIHdyaXRlIHRoZSBkYXRhIHRvIGEgZmlsZSBpbiB0aGUgZGlyZWN0b3J5XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICogICAgIH1dLFxuICogICAgIGVtYWlsX2xpbms6IFsnd3JpdGVfZmlsZScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIG9uY2UgdGhlIGZpbGUgaXMgd3JpdHRlbiBsZXQncyBlbWFpbCBhIGxpbmsgdG8gaXQuLi5cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgeydmaWxlJzpyZXN1bHRzLndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7XG4gKiAgICAgfV1cbiAqIH0pLnRoZW4ocmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ3Jlc3VsdHMgPSAnLCByZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzID0ge1xuICogICAgIC8vICAgICBnZXRfZGF0YTogWydkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheSddXG4gKiAgICAgLy8gICAgIG1ha2VfZm9sZGVyOyAnZm9sZGVyJyxcbiAqICAgICAvLyAgICAgd3JpdGVfZmlsZTogJ2ZpbGVuYW1lJ1xuICogICAgIC8vICAgICBlbWFpbF9saW5rOiB7IGZpbGU6ICdmaWxlbmFtZScsIGVtYWlsOiAndXNlckBleGFtcGxlLmNvbScgfVxuICogICAgIC8vIH1cbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ2VyciA9ICcsIGVycik7XG4gKiB9KTtcbiAqXG4gKiAvL1VzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5hdXRvKHtcbiAqICAgICAgICAgICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gZ2V0IHNvbWUgZGF0YVxuICogICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheScpO1xuICogICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgIG1ha2VfZm9sZGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gY3JlYXRlIGEgZGlyZWN0b3J5IHRvIHN0b3JlIGEgZmlsZSBpblxuICogICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgcnVuIGF0IHRoZSBzYW1lIHRpbWUgYXMgZ2V0dGluZyB0aGUgZGF0YVxuICogICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmb2xkZXInKTtcbiAqICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgICB3cml0ZV9maWxlOiBbJ2dldF9kYXRhJywgJ21ha2VfZm9sZGVyJywgZnVuY3Rpb24ocmVzdWx0cywgY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICAvLyBvbmNlIHRoZXJlIGlzIHNvbWUgZGF0YSBhbmQgdGhlIGRpcmVjdG9yeSBleGlzdHMsXG4gKiAgICAgICAgICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnlcbiAqICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTtcbiAqICAgICAgICAgICAgIH1dLFxuICogICAgICAgICAgICAgZW1haWxfbGluazogWyd3cml0ZV9maWxlJywgZnVuY3Rpb24ocmVzdWx0cywgY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uXG4gKiAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeydmaWxlJzpyZXN1bHRzLndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7XG4gKiAgICAgICAgICAgICB9XVxuICogICAgICAgICB9KTtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ3Jlc3VsdHMgPSAnLCByZXN1bHRzKTtcbiAqICAgICAgICAgLy8gcmVzdWx0cyA9IHtcbiAqICAgICAgICAgLy8gICAgIGdldF9kYXRhOiBbJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5J11cbiAqICAgICAgICAgLy8gICAgIG1ha2VfZm9sZGVyOyAnZm9sZGVyJyxcbiAqICAgICAgICAgLy8gICAgIHdyaXRlX2ZpbGU6ICdmaWxlbmFtZSdcbiAqICAgICAgICAgLy8gICAgIGVtYWlsX2xpbms6IHsgZmlsZTogJ2ZpbGVuYW1lJywgZW1haWw6ICd1c2VyQGV4YW1wbGUuY29tJyB9XG4gKiAgICAgICAgIC8vIH1cbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGF1dG8odGFza3MsIGNvbmN1cnJlbmN5LCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY29uY3VycmVuY3kgIT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIGNvbmN1cnJlbmN5IGlzIG9wdGlvbmFsLCBzaGlmdCB0aGUgYXJncy5cbiAgICAgICAgY2FsbGJhY2sgPSBjb25jdXJyZW5jeTtcbiAgICAgICAgY29uY3VycmVuY3kgPSBudWxsO1xuICAgIH1cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgcHJvbWlzZUNhbGxiYWNrKCkpO1xuICAgIHZhciBudW1UYXNrcyA9IE9iamVjdC5rZXlzKHRhc2tzKS5sZW5ndGg7XG4gICAgaWYgKCFudW1UYXNrcykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICAgIGlmICghY29uY3VycmVuY3kpIHtcbiAgICAgICAgY29uY3VycmVuY3kgPSBudW1UYXNrcztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgIHZhciBydW5uaW5nVGFza3MgPSAwO1xuICAgIHZhciBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIHZhciBoYXNFcnJvciA9IGZhbHNlO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB2YXIgcmVhZHlUYXNrcyA9IFtdO1xuXG4gICAgLy8gZm9yIGN5Y2xlIGRldGVjdGlvbjpcbiAgICB2YXIgcmVhZHlUb0NoZWNrID0gW107IC8vIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIGlkZW50aWZpZWQgYXMgcmVhY2hhYmxlXG4gICAgLy8gd2l0aG91dCB0aGUgcG9zc2liaWxpdHkgb2YgcmV0dXJuaW5nIHRvIGFuIGFuY2VzdG9yIHRhc2tcbiAgICB2YXIgdW5jaGVja2VkRGVwZW5kZW5jaWVzID0ge307XG5cbiAgICBPYmplY3Qua2V5cyh0YXNrcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICB2YXIgdGFzayA9IHRhc2tzW2tleV07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXNrKSkge1xuICAgICAgICAgICAgLy8gbm8gZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICBlbnF1ZXVlVGFzayhrZXksIFt0YXNrXSk7XG4gICAgICAgICAgICByZWFkeVRvQ2hlY2sucHVzaChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IHRhc2suc2xpY2UoMCwgdGFzay5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0RlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcy5sZW5ndGg7XG4gICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHtcbiAgICAgICAgICAgIGVucXVldWVUYXNrKGtleSwgdGFzayk7XG4gICAgICAgICAgICByZWFkeVRvQ2hlY2sucHVzaChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVuY2hlY2tlZERlcGVuZGVuY2llc1trZXldID0gcmVtYWluaW5nRGVwZW5kZW5jaWVzO1xuXG4gICAgICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoKGRlcGVuZGVuY3lOYW1lID0+IHtcbiAgICAgICAgICAgIGlmICghdGFza3NbZGVwZW5kZW5jeU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3luYy5hdXRvIHRhc2sgYCcgKyBrZXkgK1xuICAgICAgICAgICAgICAgICAgICAnYCBoYXMgYSBub24tZXhpc3RlbnQgZGVwZW5kZW5jeSBgJyArXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lOYW1lICsgJ2AgaW4gJyArXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5qb2luKCcsICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZExpc3RlbmVyKGRlcGVuZGVuY3lOYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nRGVwZW5kZW5jaWVzLS07XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0RlcGVuZGVuY2llcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhrZXksIHRhc2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNoZWNrRm9yRGVhZGxvY2tzKCk7XG4gICAgcHJvY2Vzc1F1ZXVlKCk7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlVGFzayhrZXksIHRhc2spIHtcbiAgICAgICAgcmVhZHlUYXNrcy5wdXNoKCgpID0+IHJ1blRhc2soa2V5LCB0YXNrKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuICAgICAgICBpZiAoY2FuY2VsZWQpIHJldHVyblxuICAgICAgICBpZiAocmVhZHlUYXNrcy5sZW5ndGggPT09IDAgJiYgcnVubmluZ1Rhc2tzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUocmVhZHlUYXNrcy5sZW5ndGggJiYgcnVubmluZ1Rhc2tzIDwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgIHZhciBydW4gPSByZWFkeVRhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICBydW4oKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIodGFza05hbWUsIGZuKSB7XG4gICAgICAgIHZhciB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXTtcbiAgICAgICAgaWYgKCF0YXNrTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFza0xpc3RlbmVycy5wdXNoKGZuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0YXNrQ29tcGxldGUodGFza05hbWUpIHtcbiAgICAgICAgdmFyIHRhc2tMaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbdGFza05hbWVdIHx8IFtdO1xuICAgICAgICB0YXNrTGlzdGVuZXJzLmZvckVhY2goZm4gPT4gZm4oKSk7XG4gICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcnVuVGFzayhrZXksIHRhc2spIHtcbiAgICAgICAgaWYgKGhhc0Vycm9yKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IG9ubHlPbmNlKChlcnIsIC4uLnJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgcnVubmluZ1Rhc2tzLS07XG4gICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIFtyZXN1bHRdID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlc3VsdHMpLmZvckVhY2gocmtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gcmVzdWx0c1tya2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxlZCkgcmV0dXJuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBzYWZlUmVzdWx0cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB0YXNrQ29tcGxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcnVubmluZ1Rhc2tzKys7XG4gICAgICAgIHZhciB0YXNrRm4gPSB3cmFwQXN5bmModGFza1t0YXNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgaWYgKHRhc2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGFza0ZuKHJlc3VsdHMsIHRhc2tDYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXNrRm4odGFza0NhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrRm9yRGVhZGxvY2tzKCkge1xuICAgICAgICAvLyBLYWhuJ3MgYWxnb3JpdGhtXG4gICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvcG9sb2dpY2FsX3NvcnRpbmcjS2Fobi4yN3NfYWxnb3JpdGhtXG4gICAgICAgIC8vIGh0dHA6Ly9jb25uYWxsZS5ibG9nc3BvdC5jb20vMjAxMy8xMC90b3BvbG9naWNhbC1zb3J0aW5na2Fobi1hbGdvcml0aG0uaHRtbFxuICAgICAgICB2YXIgY3VycmVudFRhc2s7XG4gICAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgICAgd2hpbGUgKHJlYWR5VG9DaGVjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcmVhZHlUb0NoZWNrLnBvcCgpO1xuICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICAgICAgZ2V0RGVwZW5kZW50cyhjdXJyZW50VGFzaykuZm9yRWFjaChkZXBlbmRlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgtLXVuY2hlY2tlZERlcGVuZGVuY2llc1tkZXBlbmRlbnRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGRlcGVuZGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY291bnRlciAhPT0gbnVtVGFza3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnYXN5bmMuYXV0byBjYW5ub3QgZXhlY3V0ZSB0YXNrcyBkdWUgdG8gYSByZWN1cnNpdmUgZGVwZW5kZW5jeSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREZXBlbmRlbnRzKHRhc2tOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXModGFza3MpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSB0YXNrc1trZXldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFzaykgJiYgdGFzay5pbmRleE9mKHRhc2tOYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrW1BST01JU0VfU1lNQk9MXVxufVxuXG52YXIgRk5fQVJHUyA9IC9eKD86YXN5bmNcXHMrKT8oPzpmdW5jdGlvbik/XFxzKlxcdypcXHMqXFwoXFxzKihbXildKylcXHMqXFwpKD86XFxzKnspLztcbnZhciBBUlJPV19GTl9BUkdTID0gL14oPzphc3luY1xccyspP1xcKD9cXHMqKFteKT1dKylcXHMqXFwpPyg/Olxccyo9PikvO1xudmFyIEZOX0FSR19TUExJVCA9IC8sLztcbnZhciBGTl9BUkcgPSAvKD0uKyk/KFxccyopJC87XG5cbmZ1bmN0aW9uIHN0cmlwQ29tbWVudHMoc3RyaW5nKSB7XG4gICAgbGV0IHN0cmlwcGVkID0gJyc7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBsZXQgZW5kQmxvY2tDb21tZW50ID0gc3RyaW5nLmluZGV4T2YoJyovJyk7XG4gICAgd2hpbGUgKGluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICBpZiAoc3RyaW5nW2luZGV4XSA9PT0gJy8nICYmIHN0cmluZ1tpbmRleCsxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAvLyBpbmxpbmUgY29tbWVudFxuICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gc3RyaW5nLmluZGV4T2YoJ1xcbicsIGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gKGVuZEluZGV4ID09PSAtMSkgPyBzdHJpbmcubGVuZ3RoIDogZW5kSW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZiAoKGVuZEJsb2NrQ29tbWVudCAhPT0gLTEpICYmIChzdHJpbmdbaW5kZXhdID09PSAnLycpICYmIChzdHJpbmdbaW5kZXgrMV0gPT09ICcqJykpIHtcbiAgICAgICAgICAgIC8vIGJsb2NrIGNvbW1lbnRcbiAgICAgICAgICAgIGxldCBlbmRJbmRleCA9IHN0cmluZy5pbmRleE9mKCcqLycsIGluZGV4KTtcbiAgICAgICAgICAgIGlmIChlbmRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGVuZEluZGV4ICsgMjtcbiAgICAgICAgICAgICAgICBlbmRCbG9ja0NvbW1lbnQgPSBzdHJpbmcuaW5kZXhPZignKi8nLCBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmlwcGVkICs9IHN0cmluZ1tpbmRleF07XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmlwcGVkICs9IHN0cmluZ1tpbmRleF07XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJpcHBlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJhbXMoZnVuYykge1xuICAgIGNvbnN0IHNyYyA9IHN0cmlwQ29tbWVudHMoZnVuYy50b1N0cmluZygpKTtcbiAgICBsZXQgbWF0Y2ggPSBzcmMubWF0Y2goRk5fQVJHUyk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBtYXRjaCA9IHNyYy5tYXRjaChBUlJPV19GTl9BUkdTKTtcbiAgICB9XG4gICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcGFyc2UgYXJncyBpbiBhdXRvSW5qZWN0XFxuU291cmNlOlxcbicgKyBzcmMpXG4gICAgbGV0IFssIGFyZ3NdID0gbWF0Y2g7XG4gICAgcmV0dXJuIGFyZ3NcbiAgICAgICAgLnJlcGxhY2UoL1xccy9nLCAnJylcbiAgICAgICAgLnNwbGl0KEZOX0FSR19TUExJVClcbiAgICAgICAgLm1hcCgoYXJnKSA9PiBhcmcucmVwbGFjZShGTl9BUkcsICcnKS50cmltKCkpO1xufVxuXG4vKipcbiAqIEEgZGVwZW5kZW5jeS1pbmplY3RlZCB2ZXJzaW9uIG9mIHRoZSBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99IGZ1bmN0aW9uLiBEZXBlbmRlbnRcbiAqIHRhc2tzIGFyZSBzcGVjaWZpZWQgYXMgcGFyYW1ldGVycyB0byB0aGUgZnVuY3Rpb24sIGFmdGVyIHRoZSB1c3VhbCBjYWxsYmFja1xuICogcGFyYW1ldGVyLCB3aXRoIHRoZSBwYXJhbWV0ZXIgbmFtZXMgbWF0Y2hpbmcgdGhlIG5hbWVzIG9mIHRoZSB0YXNrcyBpdFxuICogZGVwZW5kcyBvbi4gVGhpcyBjYW4gcHJvdmlkZSBldmVuIG1vcmUgcmVhZGFibGUgdGFzayBncmFwaHMgd2hpY2ggY2FuIGJlXG4gKiBlYXNpZXIgdG8gbWFpbnRhaW4uXG4gKlxuICogSWYgYSBmaW5hbCBjYWxsYmFjayBpcyBzcGVjaWZpZWQsIHRoZSB0YXNrIHJlc3VsdHMgYXJlIHNpbWlsYXJseSBpbmplY3RlZCxcbiAqIHNwZWNpZmllZCBhcyBuYW1lZCBwYXJhbWV0ZXJzIGFmdGVyIHRoZSBpbml0aWFsIGVycm9yIHBhcmFtZXRlci5cbiAqXG4gKiBUaGUgYXV0b0luamVjdCBmdW5jdGlvbiBpcyBwdXJlbHkgc3ludGFjdGljIHN1Z2FyIGFuZCBpdHMgc2VtYW50aWNzIGFyZVxuICogb3RoZXJ3aXNlIGVxdWl2YWxlbnQgdG8gW2FzeW5jLmF1dG9de0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hdXRvfS5cbiAqXG4gKiBAbmFtZSBhdXRvSW5qZWN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b31cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdCwgZWFjaCBvZiB3aG9zZSBwcm9wZXJ0aWVzIGlzIGFuIHtAbGluayBBc3luY0Z1bmN0aW9ufSBvZlxuICogdGhlIGZvcm0gJ2Z1bmMoW2RlcGVuZGVuY2llcy4uLl0sIGNhbGxiYWNrKS4gVGhlIG9iamVjdCdzIGtleSBvZiBhIHByb3BlcnR5XG4gKiBzZXJ2ZXMgYXMgdGhlIG5hbWUgb2YgdGhlIHRhc2sgZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkXG4gKiB3aGVuIHNwZWNpZnlpbmcgcmVxdWlyZW1lbnRzIGZvciBvdGhlciB0YXNrcy5cbiAqICogVGhlIGBjYWxsYmFja2AgcGFyYW1ldGVyIGlzIGEgYGNhbGxiYWNrKGVyciwgcmVzdWx0KWAgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqICAgd2hlbiBmaW5pc2hlZCwgcGFzc2luZyBhbiBgZXJyb3JgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgdGhlIHJlc3VsdCBvZlxuICogICB0aGUgZnVuY3Rpb24ncyBleGVjdXRpb24uIFRoZSByZW1haW5pbmcgcGFyYW1ldGVycyBuYW1lIG90aGVyIHRhc2tzIG9uXG4gKiAgIHdoaWNoIHRoZSB0YXNrIGlzIGRlcGVuZGVudCwgYW5kIHRoZSByZXN1bHRzIGZyb20gdGhvc2UgdGFza3MgYXJlIHRoZVxuICogICBhcmd1bWVudHMgb2YgdGhvc2UgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIHRoZSB0YXNrcyBoYXZlIGJlZW4gY29tcGxldGVkLiBJdCByZWNlaXZlcyB0aGUgYGVycmAgYXJndW1lbnQgaWYgYW55IGB0YXNrc2BcbiAqIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2ssIGFuZCBhIGByZXN1bHRzYCBvYmplY3Qgd2l0aCBhbnkgY29tcGxldGVkXG4gKiB0YXNrIHJlc3VsdHMsIHNpbWlsYXIgdG8gYGF1dG9gLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vICBUaGUgZXhhbXBsZSBmcm9tIGBhdXRvYCBjYW4gYmUgcmV3cml0dGVuIGFzIGZvbGxvd3M6XG4gKiBhc3luYy5hdXRvSW5qZWN0KHtcbiAqICAgICBnZXRfZGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheScpO1xuICogICAgIH0sXG4gKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gY3JlYXRlIGEgZGlyZWN0b3J5IHRvIHN0b3JlIGEgZmlsZSBpblxuICogICAgICAgICAvLyB0aGlzIGlzIHJ1biBhdCB0aGUgc2FtZSB0aW1lIGFzIGdldHRpbmcgdGhlIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpO1xuICogICAgIH0sXG4gKiAgICAgd3JpdGVfZmlsZTogZnVuY3Rpb24oZ2V0X2RhdGEsIG1ha2VfZm9sZGVyLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBvbmNlIHRoZXJlIGlzIHNvbWUgZGF0YSBhbmQgdGhlIGRpcmVjdG9yeSBleGlzdHMsXG4gKiAgICAgICAgIC8vIHdyaXRlIHRoZSBkYXRhIHRvIGEgZmlsZSBpbiB0aGUgZGlyZWN0b3J5XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICogICAgIH0sXG4gKiAgICAgZW1haWxfbGluazogZnVuY3Rpb24od3JpdGVfZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gb25jZSB0aGUgZmlsZSBpcyB3cml0dGVuIGxldCdzIGVtYWlsIGEgbGluayB0byBpdC4uLlxuICogICAgICAgICAvLyB3cml0ZV9maWxlIGNvbnRhaW5zIHRoZSBmaWxlbmFtZSByZXR1cm5lZCBieSB3cml0ZV9maWxlLlxuICogICAgICAgICBjYWxsYmFjayhudWxsLCB7J2ZpbGUnOndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7XG4gKiAgICAgfVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2VyciA9ICcsIGVycik7XG4gKiAgICAgY29uc29sZS5sb2coJ2VtYWlsX2xpbmsgPSAnLCByZXN1bHRzLmVtYWlsX2xpbmspO1xuICogfSk7XG4gKlxuICogLy8gSWYgeW91IGFyZSB1c2luZyBhIEpTIG1pbmlmaWVyIHRoYXQgbWFuZ2xlcyBwYXJhbWV0ZXIgbmFtZXMsIGBhdXRvSW5qZWN0YFxuICogLy8gd2lsbCBub3Qgd29yayB3aXRoIHBsYWluIGZ1bmN0aW9ucywgc2luY2UgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsIGJlXG4gKiAvLyBjb2xsYXBzZWQgdG8gYSBzaW5nbGUgbGV0dGVyIGlkZW50aWZpZXIuICBUbyB3b3JrIGFyb3VuZCB0aGlzLCB5b3UgY2FuXG4gKiAvLyBleHBsaWNpdGx5IHNwZWNpZnkgdGhlIG5hbWVzIG9mIHRoZSBwYXJhbWV0ZXJzIHlvdXIgdGFzayBmdW5jdGlvbiBuZWVkc1xuICogLy8gaW4gYW4gYXJyYXksIHNpbWlsYXIgdG8gQW5ndWxhci5qcyBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAqXG4gKiAvLyBUaGlzIHN0aWxsIGhhcyBhbiBhZHZhbnRhZ2Ugb3ZlciBwbGFpbiBgYXV0b2AsIHNpbmNlIHRoZSByZXN1bHRzIGEgdGFza1xuICogLy8gZGVwZW5kcyBvbiBhcmUgc3RpbGwgc3ByZWFkIGludG8gYXJndW1lbnRzLlxuICogYXN5bmMuYXV0b0luamVjdCh7XG4gKiAgICAgLy8uLi5cbiAqICAgICB3cml0ZV9maWxlOiBbJ2dldF9kYXRhJywgJ21ha2VfZm9sZGVyJywgZnVuY3Rpb24oZ2V0X2RhdGEsIG1ha2VfZm9sZGVyLCBjYWxsYmFjaykge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTtcbiAqICAgICB9XSxcbiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCB7J2ZpbGUnOndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7XG4gKiAgICAgfV1cbiAqICAgICAvLy4uLlxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2VyciA9ICcsIGVycik7XG4gKiAgICAgY29uc29sZS5sb2coJ2VtYWlsX2xpbmsgPSAnLCByZXN1bHRzLmVtYWlsX2xpbmspO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGF1dG9JbmplY3QodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG5ld1Rhc2tzID0ge307XG5cbiAgICBPYmplY3Qua2V5cyh0YXNrcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICB2YXIgdGFza0ZuID0gdGFza3Nba2V5XTtcbiAgICAgICAgdmFyIHBhcmFtcztcbiAgICAgICAgdmFyIGZuSXNBc3luYyA9IGlzQXN5bmModGFza0ZuKTtcbiAgICAgICAgdmFyIGhhc05vRGVwcyA9XG4gICAgICAgICAgICAoIWZuSXNBc3luYyAmJiB0YXNrRm4ubGVuZ3RoID09PSAxKSB8fFxuICAgICAgICAgICAgKGZuSXNBc3luYyAmJiB0YXNrRm4ubGVuZ3RoID09PSAwKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXNrRm4pKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBbLi4udGFza0ZuXTtcbiAgICAgICAgICAgIHRhc2tGbiA9IHBhcmFtcy5wb3AoKTtcblxuICAgICAgICAgICAgbmV3VGFza3Nba2V5XSA9IHBhcmFtcy5jb25jYXQocGFyYW1zLmxlbmd0aCA+IDAgPyBuZXdUYXNrIDogdGFza0ZuKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNOb0RlcHMpIHtcbiAgICAgICAgICAgIC8vIG5vIGRlcGVuZGVuY2llcywgdXNlIHRoZSBmdW5jdGlvbiBhcy1pc1xuICAgICAgICAgICAgbmV3VGFza3Nba2V5XSA9IHRhc2tGbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcnNlUGFyYW1zKHRhc2tGbik7XG4gICAgICAgICAgICBpZiAoKHRhc2tGbi5sZW5ndGggPT09IDAgJiYgIWZuSXNBc3luYykgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF1dG9JbmplY3QgdGFzayBmdW5jdGlvbnMgcmVxdWlyZSBleHBsaWNpdCBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGNhbGxiYWNrIHBhcmFtXG4gICAgICAgICAgICBpZiAoIWZuSXNBc3luYykgcGFyYW1zLnBvcCgpO1xuXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChuZXdUYXNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5ld1Rhc2socmVzdWx0cywgdGFza0NiKSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJncyA9IHBhcmFtcy5tYXAobmFtZSA9PiByZXN1bHRzW25hbWVdKTtcbiAgICAgICAgICAgIG5ld0FyZ3MucHVzaCh0YXNrQ2IpO1xuICAgICAgICAgICAgd3JhcEFzeW5jKHRhc2tGbikoLi4ubmV3QXJncyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhdXRvKG5ld1Rhc2tzLCBjYWxsYmFjayk7XG59XG5cbi8vIFNpbXBsZSBkb3VibHkgbGlua2VkIGxpc3QgKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWJseV9saW5rZWRfbGlzdCkgaW1wbGVtZW50YXRpb25cbi8vIHVzZWQgZm9yIHF1ZXVlcy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIHRoYXQgdGhlIG5vZGUgcHJvdmlkZWQgYnkgdGhlIHVzZXIgY2FuIGJlIG1vZGlmaWVkXG4vLyB0byBhZGp1c3QgdGhlIG5leHQgYW5kIGxhc3QgcHJvcGVydGllcy4gV2UgaW1wbGVtZW50IG9ubHkgdGhlIG1pbmltYWwgZnVuY3Rpb25hbGl0eVxuLy8gZm9yIHF1ZXVlIHN1cHBvcnQuXG5jbGFzcyBETEwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmVtb3ZlTGluayhub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnByZXYpIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICBlbHNlIHRoaXMuaGVhZCA9IG5vZGUubmV4dDtcbiAgICAgICAgaWYgKG5vZGUubmV4dCkgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgICAgIGVsc2UgdGhpcy50YWlsID0gbm9kZS5wcmV2O1xuXG4gICAgICAgIG5vZGUucHJldiA9IG5vZGUubmV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGVtcHR5ICgpIHtcbiAgICAgICAgd2hpbGUodGhpcy5oZWFkKSB0aGlzLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGluc2VydEFmdGVyKG5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgbmV3Tm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgbmV3Tm9kZS5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICBpZiAobm9kZS5uZXh0KSBub2RlLm5leHQucHJldiA9IG5ld05vZGU7XG4gICAgICAgIGVsc2UgdGhpcy50YWlsID0gbmV3Tm9kZTtcbiAgICAgICAgbm9kZS5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICB9XG5cbiAgICBpbnNlcnRCZWZvcmUobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICBuZXdOb2RlLnByZXYgPSBub2RlLnByZXY7XG4gICAgICAgIG5ld05vZGUubmV4dCA9IG5vZGU7XG4gICAgICAgIGlmIChub2RlLnByZXYpIG5vZGUucHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgZWxzZSB0aGlzLmhlYWQgPSBuZXdOb2RlO1xuICAgICAgICBub2RlLnByZXYgPSBuZXdOb2RlO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSAxO1xuICAgIH1cblxuICAgIHVuc2hpZnQobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5oZWFkKSB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQsIG5vZGUpO1xuICAgICAgICBlbHNlIHNldEluaXRpYWwodGhpcywgbm9kZSk7XG4gICAgfVxuXG4gICAgcHVzaChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnRhaWwpIHRoaXMuaW5zZXJ0QWZ0ZXIodGhpcy50YWlsLCBub2RlKTtcbiAgICAgICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpO1xuICAgIH1cblxuICAgIHNoaWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkICYmIHRoaXMucmVtb3ZlTGluayh0aGlzLmhlYWQpO1xuICAgIH1cblxuICAgIHBvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFpbCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy50YWlsKTtcbiAgICB9XG5cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXNdXG4gICAgfVxuXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICAgICAgdmFyIGN1ciA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cikge1xuICAgICAgICAgICAgeWllbGQgY3VyLmRhdGE7XG4gICAgICAgICAgICBjdXIgPSBjdXIubmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZSAodGVzdEZuKSB7XG4gICAgICAgIHZhciBjdXJyID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZShjdXJyKSB7XG4gICAgICAgICAgICB2YXIge25leHR9ID0gY3VycjtcbiAgICAgICAgICAgIGlmICh0ZXN0Rm4oY3VycikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpbmsoY3Vycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWwoZGxsLCBub2RlKSB7XG4gICAgZGxsLmxlbmd0aCA9IDE7XG4gICAgZGxsLmhlYWQgPSBkbGwudGFpbCA9IG5vZGU7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlJDEod29ya2VyLCBjb25jdXJyZW5jeSwgcGF5bG9hZCkge1xuICAgIGlmIChjb25jdXJyZW5jeSA9PSBudWxsKSB7XG4gICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICB9XG4gICAgZWxzZSBpZihjb25jdXJyZW5jeSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ29uY3VycmVuY3kgbXVzdCBub3QgYmUgemVybycpO1xuICAgIH1cblxuICAgIHZhciBfd29ya2VyID0gd3JhcEFzeW5jKHdvcmtlcik7XG4gICAgdmFyIG51bVJ1bm5pbmcgPSAwO1xuICAgIHZhciB3b3JrZXJzTGlzdCA9IFtdO1xuICAgIGNvbnN0IGV2ZW50cyA9IHtcbiAgICAgICAgZXJyb3I6IFtdLFxuICAgICAgICBkcmFpbjogW10sXG4gICAgICAgIHNhdHVyYXRlZDogW10sXG4gICAgICAgIHVuc2F0dXJhdGVkOiBbXSxcbiAgICAgICAgZW1wdHk6IFtdXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICBldmVudHNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25jZSAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlQW5kUmVtb3ZlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIG9mZihldmVudCwgaGFuZGxlQW5kUmVtb3ZlKTtcbiAgICAgICAgICAgIGhhbmRsZXIoLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50c1tldmVudF0ucHVzaChoYW5kbGVBbmRSZW1vdmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFldmVudCkgcmV0dXJuIE9iamVjdC5rZXlzKGV2ZW50cykuZm9yRWFjaChldiA9PiBldmVudHNbZXZdID0gW10pXG4gICAgICAgIGlmICghaGFuZGxlcikgcmV0dXJuIGV2ZW50c1tldmVudF0gPSBbXVxuICAgICAgICBldmVudHNbZXZlbnRdID0gZXZlbnRzW2V2ZW50XS5maWx0ZXIoZXYgPT4gZXYgIT09IGhhbmRsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaWdnZXIgKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGV2ZW50c1tldmVudF0uZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoLi4uYXJncykpO1xuICAgIH1cblxuICAgIHZhciBwcm9jZXNzaW5nU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gX2luc2VydChkYXRhLCBpbnNlcnRBdEZyb250LCByZWplY3RPbkVycm9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciByZXMsIHJlajtcbiAgICAgICAgZnVuY3Rpb24gcHJvbWlzZUNhbGxiYWNrIChlcnIsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGVycm9yLCBsZXQgdGhlIGdsb2JhbCBlcnJvciBoYW5kbGVyXG4gICAgICAgICAgICAvLyBkZWFsIHdpdGggaXRcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3RPbkVycm9yID8gcmVqKGVycikgOiByZXMoKVxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHJldHVybiByZXMoYXJnc1swXSlcbiAgICAgICAgICAgIHJlcyhhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVtID0gcS5fY3JlYXRlVGFza0l0ZW0oXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVqZWN0T25FcnJvciA/IHByb21pc2VDYWxsYmFjayA6XG4gICAgICAgICAgICAgICAgKGNhbGxiYWNrIHx8IHByb21pc2VDYWxsYmFjaylcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaW5zZXJ0QXRGcm9udCkge1xuICAgICAgICAgICAgcS5fdGFza3MudW5zaGlmdChpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHEuX3Rhc2tzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByb2Nlc3NpbmdTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlamVjdE9uRXJyb3IgfHwgIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgcmVqID0gcmVqZWN0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVDQih0YXNrcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgLi4uYXJncykge1xuICAgICAgICAgICAgbnVtUnVubmluZyAtPSAxO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhc2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NbaV07XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB3b3JrZXJzTGlzdC5pbmRleE9mKHRhc2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjayhlcnIsIC4uLmFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2Vycm9yJywgZXJyLCB0YXNrLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bVJ1bm5pbmcgPD0gKHEuY29uY3VycmVuY3kgLSBxLmJ1ZmZlcikgKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcigndW5zYXR1cmF0ZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcignZHJhaW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9tYXliZURyYWluKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwICYmIHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoKCkgPT4gdHJpZ2dlcignZHJhaW4nKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50TWV0aG9kID0gKG5hbWUpID0+IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBvbmNlKG5hbWUsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIG9mZihuYW1lKTtcbiAgICAgICAgb24obmFtZSwgaGFuZGxlcik7XG5cbiAgICB9O1xuXG4gICAgdmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIHZhciBxID0ge1xuICAgICAgICBfdGFza3M6IG5ldyBETEwoKSxcbiAgICAgICAgX2NyZWF0ZVRhc2tJdGVtIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAqW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgICAgICAgICAgeWllbGQqIHEuX3Rhc2tzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIGJ1ZmZlcjogY29uY3VycmVuY3kgLyA0LFxuICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgcGF1c2VkOiBmYWxzZSxcbiAgICAgICAgcHVzaCAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9tYXliZURyYWluKGRhdGEpKSByZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoZGF0dW0gPT4gX2luc2VydChkYXR1bSwgZmFsc2UsIGZhbHNlLCBjYWxsYmFjaykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2luc2VydChkYXRhLCBmYWxzZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVzaEFzeW5jIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX21heWJlRHJhaW4oZGF0YSkpIHJldHVyblxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcChkYXR1bSA9PiBfaW5zZXJ0KGRhdHVtLCBmYWxzZSwgdHJ1ZSwgY2FsbGJhY2spKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9pbnNlcnQoZGF0YSwgZmFsc2UsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAga2lsbCAoKSB7XG4gICAgICAgICAgICBvZmYoKTtcbiAgICAgICAgICAgIHEuX3Rhc2tzLmVtcHR5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2hpZnQgKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmIChfbWF5YmVEcmFpbihkYXRhKSkgcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKGRhdHVtID0+IF9pbnNlcnQoZGF0dW0sIHRydWUsIGZhbHNlLCBjYWxsYmFjaykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2luc2VydChkYXRhLCB0cnVlLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICB1bnNoaWZ0QXN5bmMgKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmIChfbWF5YmVEcmFpbihkYXRhKSkgcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKGRhdHVtID0+IF9pbnNlcnQoZGF0dW0sIHRydWUsIHRydWUsIGNhbGxiYWNrKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfaW5zZXJ0KGRhdGEsIHRydWUsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlICh0ZXN0Rm4pIHtcbiAgICAgICAgICAgIHEuX3Rhc2tzLnJlbW92ZSh0ZXN0Rm4pO1xuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzICgpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIHRyeWluZyB0byBzdGFydCB0b28gbWFueSBwcm9jZXNzaW5nIG9wZXJhdGlvbnMuIFRoaXMgY2FuIG9jY3VyXG4gICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyByZXNvbHZlIHN5bmNocm9ub3VzbHkgKCMxMjY3KS5cbiAgICAgICAgICAgIGlmIChpc1Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUoIXEucGF1c2VkICYmIG51bVJ1bm5pbmcgPCBxLmNvbmN1cnJlbmN5ICYmIHEuX3Rhc2tzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgdmFyIHRhc2tzID0gW10sIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHEuX3Rhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXlsb2FkKSBsID0gTWF0aC5taW4obCwgcS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHEuX3Rhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChub2RlLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG51bVJ1bm5pbmcgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmIChxLl90YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcignZW1wdHknKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobnVtUnVubmluZyA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdzYXR1cmF0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5T25jZShfY3JlYXRlQ0IodGFza3MpKTtcbiAgICAgICAgICAgICAgICBfd29ya2VyKGRhdGEsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBsZW5ndGggKCkge1xuICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgcnVubmluZyAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtUnVubmluZztcbiAgICAgICAgfSxcbiAgICAgICAgd29ya2Vyc0xpc3QgKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnNMaXN0O1xuICAgICAgICB9LFxuICAgICAgICBpZGxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aCArIG51bVJ1bm5pbmcgPT09IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHBhdXNlICgpIHtcbiAgICAgICAgICAgIHEucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdW1lICgpIHtcbiAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICBxLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEocS5wcm9jZXNzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gZGVmaW5lIHRoZXNlIGFzIGZpeGVkIHByb3BlcnRpZXMsIHNvIHBlb3BsZSBnZXQgdXNlZnVsIGVycm9ycyB3aGVuIHVwZGF0aW5nXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocSwge1xuICAgICAgICBzYXR1cmF0ZWQ6IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBldmVudE1ldGhvZCgnc2F0dXJhdGVkJylcbiAgICAgICAgfSxcbiAgICAgICAgdW5zYXR1cmF0ZWQ6IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBldmVudE1ldGhvZCgndW5zYXR1cmF0ZWQnKVxuICAgICAgICB9LFxuICAgICAgICBlbXB0eToge1xuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50TWV0aG9kKCdlbXB0eScpXG4gICAgICAgIH0sXG4gICAgICAgIGRyYWluOiB7XG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZXZlbnRNZXRob2QoJ2RyYWluJylcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBldmVudE1ldGhvZCgnZXJyb3InKVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBxO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgY2FyZ29gIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBjYXJnbyB3aWxsIGJlIHByb2Nlc3NlZCBhbHRvZ2V0aGVyICh1cCB0byB0aGUgYHBheWxvYWRgIGxpbWl0KS4gSWYgdGhlXG4gKiBgd29ya2VyYCBpcyBpbiBwcm9ncmVzcywgdGhlIHRhc2sgaXMgcXVldWVkIHVudGlsIGl0IGJlY29tZXMgYXZhaWxhYmxlLiBPbmNlXG4gKiB0aGUgYHdvcmtlcmAgaGFzIGNvbXBsZXRlZCBzb21lIHRhc2tzLCBlYWNoIGNhbGxiYWNrIG9mIHRob3NlIHRhc2tzIGlzXG4gKiBjYWxsZWQuIENoZWNrIG91dCBbdGhlc2VdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vNmJiZDM2ZjRjZjViMzVhMGYxMWE5NmRjZDJlOTc3MTFmZmMyZmIzNy82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDM4MmY2MjYyNjMzMDYzNjY2MjMwMmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM5MzczNDY2MmQzMzMzMzkzNzYzMzYzNDY0NjMzODM1MzgyZTY3Njk2NikgW2FuaW1hdGlvbnNdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vZjQ4MTBlMDBlMWM1ZjVmOGFkZGJlM2U5ZjQ5MDY0ZmQ1ZDEwMjY5OS82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDMxMmYzODM0NjMzOTMyMzAzNjM2MmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM4MzEzNDY2MmQzOTY0MzM2NDMwMzIzNDMxMzM2MjY2NjQyZTY3Njk2NilcbiAqIGZvciBob3cgYGNhcmdvYCBhbmQgYHF1ZXVlYCB3b3JrLlxuICpcbiAqIFdoaWxlIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IHBhc3NlcyBvbmx5IG9uZSB0YXNrIHRvIG9uZSBvZiBhIGdyb3VwIG9mIHdvcmtlcnNcbiAqIGF0IGEgdGltZSwgY2FyZ28gcGFzc2VzIGFuIGFycmF5IG9mIHRhc2tzIHRvIGEgc2luZ2xlIHdvcmtlciwgcmVwZWF0aW5nXG4gKiB3aGVuIHRoZSB3b3JrZXIgaXMgZmluaXNoZWQuXG4gKlxuICogQG5hbWUgY2FyZ29cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhbiBhcnJheVxuICogb2YgcXVldWVkIHRhc2tzLiBJbnZva2VkIHdpdGggYCh0YXNrcywgY2FsbGJhY2spYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGF5bG9hZD1JbmZpbml0eV0gLSBBbiBvcHRpb25hbCBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nXG4gKiBob3cgbWFueSB0YXNrcyBzaG91bGQgYmUgcHJvY2Vzc2VkIHBlciByb3VuZDsgaWYgb21pdHRlZCwgdGhlIGRlZmF1bHQgaXNcbiAqIHVubGltaXRlZC5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgY2FyZ28gb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW5cbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIGNhcmdvIGFuZCBpbm5lciBxdWV1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gY3JlYXRlIGEgY2FyZ28gb2JqZWN0IHdpdGggcGF5bG9hZCAyXG4gKiB2YXIgY2FyZ28gPSBhc3luYy5jYXJnbyhmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAqICAgICBmb3IgKHZhciBpPTA7IGk8dGFza3MubGVuZ3RoOyBpKyspIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrc1tpXS5uYW1lKTtcbiAqICAgICB9XG4gKiAgICAgY2FsbGJhY2soKTtcbiAqIH0sIDIpO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zXG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICogfSk7XG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKiBhd2FpdCBjYXJnby5wdXNoKHtuYW1lOiAnYmF6J30pO1xuICogY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmF6Jyk7XG4gKi9cbmZ1bmN0aW9uIGNhcmdvJDEod29ya2VyLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHF1ZXVlJDEod29ya2VyLCAxLCBwYXlsb2FkKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYGNhcmdvUXVldWVgIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBjYXJnb1F1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIHRvZ2V0aGVyICh1cCB0byB0aGUgYHBheWxvYWRgIGxpbWl0KSBpbiBgY29uY3VycmVuY3lgIHBhcmFsbGVsIHdvcmtlcnMuXG4gKiBJZiB0aGUgYWxsIGB3b3JrZXJzYCBhcmUgaW4gcHJvZ3Jlc3MsIHRoZSB0YXNrIGlzIHF1ZXVlZCB1bnRpbCBvbmUgYmVjb21lcyBhdmFpbGFibGUuIE9uY2VcbiAqIGEgYHdvcmtlcmAgaGFzIGNvbXBsZXRlZCBzb21lIHRhc2tzLCBlYWNoIGNhbGxiYWNrIG9mIHRob3NlIHRhc2tzIGlzXG4gKiBjYWxsZWQuIENoZWNrIG91dCBbdGhlc2VdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vNmJiZDM2ZjRjZjViMzVhMGYxMWE5NmRjZDJlOTc3MTFmZmMyZmIzNy82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDM4MmY2MjYyNjMzMDYzNjY2MjMwMmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM5MzczNDY2MmQzMzMzMzkzNzYzMzYzNDY0NjMzODM1MzgyZTY3Njk2NikgW2FuaW1hdGlvbnNdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vZjQ4MTBlMDBlMWM1ZjVmOGFkZGJlM2U5ZjQ5MDY0ZmQ1ZDEwMjY5OS82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDMxMmYzODM0NjMzOTMyMzAzNjM2MmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM4MzEzNDY2MmQzOTY0MzM2NDMwMzIzNDMxMzM2MjY2NjQyZTY3Njk2NilcbiAqIGZvciBob3cgYGNhcmdvYCBhbmQgYHF1ZXVlYCB3b3JrLlxuICpcbiAqIFdoaWxlIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IHBhc3NlcyBvbmx5IG9uZSB0YXNrIHRvIG9uZSBvZiBhIGdyb3VwIG9mIHdvcmtlcnNcbiAqIGF0IGEgdGltZSwgYW5kIFtgY2FyZ29gXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuY2FyZ299IHBhc3NlcyBhbiBhcnJheSBvZiB0YXNrcyB0byBhIHNpbmdsZSB3b3JrZXIsXG4gKiB0aGUgY2FyZ29RdWV1ZSBwYXNzZXMgYW4gYXJyYXkgb2YgdGFza3MgdG8gbXVsdGlwbGUgcGFyYWxsZWwgd29ya2Vycy5cbiAqXG4gKiBAbmFtZSBjYXJnb1F1ZXVlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfVxuICogQHNlZSBbYXN5bmMuY2FyZ29de0BsaW5rIG1vZHVsZTpDb250cm9sRkxvdy5jYXJnb31cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gd29ya2VyIC0gQW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIGFuIGFycmF5XG4gKiBvZiBxdWV1ZWQgdGFza3MuIEludm9rZWQgd2l0aCBgKHRhc2tzLCBjYWxsYmFjaylgLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW5jeT0xXSAtIEFuIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnlcbiAqIGB3b3JrZXJgIGZ1bmN0aW9ucyBzaG91bGQgYmUgcnVuIGluIHBhcmFsbGVsLiAgSWYgb21pdHRlZCwgdGhlIGNvbmN1cnJlbmN5XG4gKiBkZWZhdWx0cyB0byBgMWAuICBJZiB0aGUgY29uY3VycmVuY3kgaXMgYDBgLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcGFyYW0ge251bWJlcn0gW3BheWxvYWQ9SW5maW5pdHldIC0gQW4gb3B0aW9uYWwgYGludGVnZXJgIGZvciBkZXRlcm1pbmluZ1xuICogaG93IG1hbnkgdGFza3Mgc2hvdWxkIGJlIHByb2Nlc3NlZCBwZXIgcm91bmQ7IGlmIG9taXR0ZWQsIHRoZSBkZWZhdWx0IGlzXG4gKiB1bmxpbWl0ZWQuXG4gKiBAcmV0dXJucyB7bW9kdWxlOkNvbnRyb2xGbG93LlF1ZXVlT2JqZWN0fSBBIGNhcmdvUXVldWUgb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW5cbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIGNhcmdvUXVldWUgYW5kIGlubmVyIHF1ZXVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBjcmVhdGUgYSBjYXJnb1F1ZXVlIG9iamVjdCB3aXRoIHBheWxvYWQgMiBhbmQgY29uY3VycmVuY3kgMlxuICogdmFyIGNhcmdvUXVldWUgPSBhc3luYy5jYXJnb1F1ZXVlKGZ1bmN0aW9uKHRhc2tzLCBjYWxsYmFjaykge1xuICogICAgIGZvciAodmFyIGk9MDsgaTx0YXNrcy5sZW5ndGg7IGkrKykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaGVsbG8gJyArIHRhc2tzW2ldLm5hbWUpO1xuICogICAgIH1cbiAqICAgICBjYWxsYmFjaygpO1xuICogfSwgMiwgMik7XG4gKlxuICogLy8gYWRkIHNvbWUgaXRlbXNcbiAqIGNhcmdvUXVldWUucHVzaCh7bmFtZTogJ2Zvbyd9LCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBmb28nKTtcbiAqIH0pO1xuICogY2FyZ29RdWV1ZS5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKiBjYXJnb1F1ZXVlLnB1c2goe25hbWU6ICdiYXonfSwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmF6Jyk7XG4gKiB9KTtcbiAqIGNhcmdvUXVldWUucHVzaCh7bmFtZTogJ2Jvbyd9LCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBib28nKTtcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBjYXJnbyh3b3JrZXIsIGNvbmN1cnJlbmN5LCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHF1ZXVlJDEod29ya2VyLCBjb25jdXJyZW5jeSwgcGF5bG9hZCk7XG59XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGAgaW50byBhIHNpbmdsZSB2YWx1ZSB1c2luZyBhbiBhc3luYyBgaXRlcmF0ZWVgIHRvIHJldHVybiBlYWNoXG4gKiBzdWNjZXNzaXZlIHN0ZXAuIGBtZW1vYCBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBvbmx5IG9wZXJhdGVzIGluIHNlcmllcy5cbiAqXG4gKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgbWF5IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgYSBjYWxsIHRvIHRoaXMgZnVuY3Rpb25cbiAqIGludG8gYSBwYXJhbGxlbCBtYXAsIGFuZCB0aGVuIHVzZSB0aGUgbm9ybWFsIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBvbiB0aGVcbiAqIHJlc3VsdHMuIFRoaXMgZnVuY3Rpb24gaXMgZm9yIHNpdHVhdGlvbnMgd2hlcmUgZWFjaCBzdGVwIGluIHRoZSByZWR1Y3Rpb25cbiAqIG5lZWRzIHRvIGJlIGFzeW5jOyBpZiB5b3UgY2FuIGdldCB0aGUgZGF0YSBiZWZvcmUgcmVkdWNpbmcgaXQsIHRoZW4gaXQnc1xuICogcHJvYmFibHkgYSBnb29kIGlkZWEgdG8gZG8gc28uXG4gKlxuICogQG5hbWUgcmVkdWNlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgaW5qZWN0XG4gKiBAYWxpYXMgZm9sZGxcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Kn0gbWVtbyAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggaXRlbSBpbiB0aGVcbiAqIGFycmF5IHRvIHByb2R1Y2UgdGhlIG5leHQgc3RlcCBpbiB0aGUgcmVkdWN0aW9uLlxuICogVGhlIGBpdGVyYXRlZWAgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIG5leHQgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi5cbiAqIElmIHRoZSBpdGVyYXRlZSBjb21wbGV0ZXMgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGVcbiAqIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBJbnZva2VkIHdpdGggKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHJlZHVjZWQgdmFsdWUuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBmaWxlMS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMi50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMjAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMy50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMzAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlNC50eHQgZG9lcyBub3QgZXhpc3RcbiAqXG4gKiBjb25zdCBmaWxlTGlzdCA9IFsnZmlsZTEudHh0JywnZmlsZTIudHh0JywnZmlsZTMudHh0J107XG4gKiBjb25zdCB3aXRoTWlzc2luZ0ZpbGVMaXN0ID0gWydmaWxlMS50eHQnLCdmaWxlMi50eHQnLCdmaWxlMy50eHQnLCAnZmlsZTQudHh0J107XG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlIGZpbGUgc2l6ZSBpbiBieXRlc1xuICogLy8gZmlsZSBzaXplIGlzIGFkZGVkIHRvIHRoZSBtZW1vaXplZCB2YWx1ZSwgdGhlbiByZXR1cm5lZFxuICogZnVuY3Rpb24gZ2V0RmlsZVNpemVJbkJ5dGVzKG1lbW8sIGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWVtbyArIHN0YXQuc2l6ZSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy5yZWR1Y2UoZmlsZUxpc3QsIDAsIGdldEZpbGVTaXplSW5CeXRlcywgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8gNjAwMFxuICogICAgICAgICAvLyB3aGljaCBpcyB0aGUgc3VtIG9mIHRoZSBmaWxlIHNpemVzIG9mIHRoZSB0aHJlZSBmaWxlc1xuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYy5yZWR1Y2Uod2l0aE1pc3NpbmdGaWxlTGlzdCwgMCwgZ2V0RmlsZVNpemVJbkJ5dGVzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5yZWR1Y2UoZmlsZUxpc3QsIDAsIGdldEZpbGVTaXplSW5CeXRlcylcbiAqIC50aGVuKCByZXN1bHQgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gNjAwMFxuICogICAgIC8vIHdoaWNoIGlzIHRoZSBzdW0gb2YgdGhlIGZpbGUgc2l6ZXMgb2YgdGhlIHRocmVlIGZpbGVzXG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jLnJlZHVjZSh3aXRoTWlzc2luZ0ZpbGVMaXN0LCAwLCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMucmVkdWNlKGZpbGVMaXN0LCAwLCBnZXRGaWxlU2l6ZUluQnl0ZXMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyA2MDAwXG4gKiAgICAgICAgIC8vIHdoaWNoIGlzIHRoZSBzdW0gb2YgdGhlIGZpbGUgc2l6ZXMgb2YgdGhlIHRocmVlIGZpbGVzXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMucmVkdWNlKHdpdGhNaXNzaW5nRmlsZUxpc3QsIDAsIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiByZWR1Y2UoY29sbCwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICByZXR1cm4gZWFjaE9mU2VyaWVzJDEoY29sbCwgKHgsIGksIGl0ZXJDYikgPT4ge1xuICAgICAgICBfaXRlcmF0ZWUobWVtbywgeCwgKGVyciwgdikgPT4ge1xuICAgICAgICAgICAgbWVtbyA9IHY7XG4gICAgICAgICAgICBpdGVyQ2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZXJyID0+IGNhbGxiYWNrKGVyciwgbWVtbykpO1xufVxudmFyIHJlZHVjZSQxID0gYXdhaXRpZnkocmVkdWNlLCA0KTtcblxuLyoqXG4gKiBWZXJzaW9uIG9mIHRoZSBjb21wb3NlIGZ1bmN0aW9uIHRoYXQgaXMgbW9yZSBuYXR1cmFsIHRvIHJlYWQuIEVhY2ggZnVuY3Rpb25cbiAqIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzIGZ1bmN0aW9uLiBJdCBpcyB0aGUgZXF1aXZhbGVudCBvZlxuICogW2NvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfSB3aXRoIHRoZSBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gKlxuICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gKlxuICogQG5hbWUgc2VxXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5jb21wb3NlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuY29tcG9zZX1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7Li4uQXN5bmNGdW5jdGlvbn0gZnVuY3Rpb25zIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgY29tcG9zZXMgdGhlIGBmdW5jdGlvbnNgIGluIG9yZGVyXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFJlcXVpcmVzIGxvZGFzaCAob3IgdW5kZXJzY29yZSksIGV4cHJlc3MzIGFuZCBkcmVzZW5kZSdzIG9ybTIuXG4gKiAvLyBQYXJ0IG9mIGFuIGFwcCwgdGhhdCBmZXRjaGVzIGNhdHMgb2YgdGhlIGxvZ2dlZCB1c2VyLlxuICogLy8gVGhpcyBleGFtcGxlIHVzZXMgYHNlcWAgZnVuY3Rpb24gdG8gYXZvaWQgb3Zlcm5lc3RpbmcgYW5kIGVycm9yXG4gKiAvLyBoYW5kbGluZyBjbHV0dGVyLlxuICogYXBwLmdldCgnL2NhdHMnLCBmdW5jdGlvbihyZXF1ZXN0LCByZXNwb25zZSkge1xuICogICAgIHZhciBVc2VyID0gcmVxdWVzdC5tb2RlbHMuVXNlcjtcbiAqICAgICBhc3luYy5zZXEoXG4gKiAgICAgICAgIFVzZXIuZ2V0LmJpbmQoVXNlciksICAvLyAnVXNlci5nZXQnIGhhcyBzaWduYXR1cmUgKGlkLCBjYWxsYmFjayhlcnIsIGRhdGEpKVxuICogICAgICAgICBmdW5jdGlvbih1c2VyLCBmbikge1xuICogICAgICAgICAgICAgdXNlci5nZXRDYXRzKGZuKTsgICAgICAvLyAnZ2V0Q2F0cycgaGFzIHNpZ25hdHVyZSAoY2FsbGJhY2soZXJyLCBkYXRhKSlcbiAqICAgICAgICAgfVxuICogICAgICkocmVxLnNlc3Npb24udXNlcl9pZCwgZnVuY3Rpb24gKGVyciwgY2F0cykge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gKiAgICAgICAgICAgICByZXNwb25zZS5qc29uKHsgc3RhdHVzOiAnZXJyb3InLCBtZXNzYWdlOiBlcnIubWVzc2FnZSB9KTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oeyBzdGF0dXM6ICdvaycsIG1lc3NhZ2U6ICdDYXRzIGZvdW5kJywgZGF0YTogY2F0cyB9KTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHNlcSguLi5mdW5jdGlvbnMpIHtcbiAgICB2YXIgX2Z1bmN0aW9ucyA9IGZ1bmN0aW9ucy5tYXAod3JhcEFzeW5jKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2IgPSBwcm9taXNlQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZHVjZSQxKF9mdW5jdGlvbnMsIGFyZ3MsIChuZXdhcmdzLCBmbiwgaXRlckNiKSA9PiB7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdCgoZXJyLCAuLi5uZXh0YXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZXJDYihlcnIsIG5leHRhcmdzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVyciwgcmVzdWx0cykgPT4gY2IoZXJyLCAuLi5yZXN1bHRzKSk7XG5cbiAgICAgICAgcmV0dXJuIGNiW1BST01JU0VfU1lNQk9MXVxuICAgIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIGlzIGEgY29tcG9zaXRpb24gb2YgdGhlIHBhc3NlZCBhc3luY2hyb25vdXNcbiAqIGZ1bmN0aW9ucy4gRWFjaCBmdW5jdGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0XG4gKiBmb2xsb3dzLiBDb21wb3NpbmcgZnVuY3Rpb25zIGBmKClgLCBgZygpYCwgYW5kIGBoKClgIHdvdWxkIHByb2R1Y2UgdGhlIHJlc3VsdFxuICogb2YgYGYoZyhoKCkpKWAsIG9ubHkgdGhpcyB2ZXJzaW9uIHVzZXMgY2FsbGJhY2tzIHRvIG9idGFpbiB0aGUgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBJZiB0aGUgbGFzdCBhcmd1bWVudCB0byB0aGUgY29tcG9zZWQgZnVuY3Rpb24gaXMgbm90IGEgZnVuY3Rpb24sIGEgcHJvbWlzZVxuICogaXMgcmV0dXJuZWQgd2hlbiB5b3UgY2FsbCBpdC5cbiAqXG4gKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAqXG4gKiBAbmFtZSBjb21wb3NlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0gey4uLkFzeW5jRnVuY3Rpb259IGZ1bmN0aW9ucyAtIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb25zIHRvIGNvbXBvc2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2VkXG4gKiBhc3luY2hyb25vdXMgYGZ1bmN0aW9uc2BcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gYWRkMShuLCBjYWxsYmFjaykge1xuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCBuICsgMSk7XG4gKiAgICAgfSwgMTApO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIG11bDMobiwgY2FsbGJhY2spIHtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbiAqIDMpO1xuICogICAgIH0sIDEwKTtcbiAqIH1cbiAqXG4gKiB2YXIgYWRkMW11bDMgPSBhc3luYy5jb21wb3NlKG11bDMsIGFkZDEpO1xuICogYWRkMW11bDMoNCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgMTVcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBjb21wb3NlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VxKC4uLmFyZ3MucmV2ZXJzZSgpKTtcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gbWFwTGltaXQgKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2FzeW5jTWFwKGVhY2hPZkxpbWl0JDIobGltaXQpLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgbWFwTGltaXQkMSA9IGF3YWl0aWZ5KG1hcExpbWl0LCA0KTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGNvbmNhdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGNvbmNhdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5jb25jYXRde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQGFsaWFzIGZsYXRNYXBMaW1pdFxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLFxuICogd2hpY2ggc2hvdWxkIHVzZSBhbiBhcnJheSBhcyBpdHMgcmVzdWx0LiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXlcbiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMgQSBQcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gY29uY2F0TGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHJldHVybiBtYXBMaW1pdCQxKGNvbGwsIGxpbWl0LCAodmFsLCBpdGVyQ2IpID0+IHtcbiAgICAgICAgX2l0ZXJhdGVlKHZhbCwgKGVyciwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGl0ZXJDYihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJDYihlcnIsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9LCAoZXJyLCBtYXBSZXN1bHRzKSA9PiB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBSZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWFwUmVzdWx0c1tpXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoLi4ubWFwUmVzdWx0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgIH0pO1xufVxudmFyIGNvbmNhdExpbWl0JDEgPSBhd2FpdGlmeShjb25jYXRMaW1pdCwgNCk7XG5cbi8qKlxuICogQXBwbGllcyBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBgY29sbGAsIGNvbmNhdGVuYXRpbmcgdGhlIHJlc3VsdHMuIFJldHVybnNcbiAqIHRoZSBjb25jYXRlbmF0ZWQgbGlzdC4gVGhlIGBpdGVyYXRlZWBzIGFyZSBjYWxsZWQgaW4gcGFyYWxsZWwsIGFuZCB0aGVcbiAqIHJlc3VsdHMgYXJlIGNvbmNhdGVuYXRlZCBhcyB0aGV5IHJldHVybi4gVGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSByZXR1cm5lZCBpblxuICogdGhlIG9yaWdpbmFsIG9yZGVyIG9mIGBjb2xsYCBwYXNzZWQgdG8gdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uXG4gKlxuICogQG5hbWUgY29uY2F0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQGFsaWFzIGZsYXRNYXBcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCxcbiAqIHdoaWNoIHNob3VsZCB1c2UgYW4gYXJyYXkgYXMgaXRzIHJlc3VsdC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGRpcjEgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMS50eHQsIGZpbGUyLnR4dFxuICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gKiAvLyBkaXIzIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTUudHh0XG4gKiAvLyBkaXI0IGRvZXMgbm90IGV4aXN0XG4gKlxuICogbGV0IGRpcmVjdG9yeUxpc3QgPSBbJ2RpcjEnLCdkaXIyJywnZGlyMyddO1xuICogbGV0IHdpdGhNaXNzaW5nRGlyZWN0b3J5TGlzdCA9IFsnZGlyMScsJ2RpcjInLCdkaXIzJywgJ2RpcjQnXTtcbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLmNvbmNhdChkaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgIGlmIChlcnIpIHtcbiAqICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgfSBlbHNlIHtcbiAqICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAvLyBbICdmaWxlMS50eHQnLCAnZmlsZTIudHh0JywgJ2ZpbGUzLnR4dCcsICdmaWxlNC50eHQnLCBmaWxlNS50eHQgXVxuICogICAgfVxuICogfSk7XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jLmNvbmNhdCh3aXRoTWlzc2luZ0RpcmVjdG9yeUxpc3QsIGZzLnJlYWRkaXIsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgaWYgKGVycikge1xuICogICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICAgICAvLyBzaW5jZSBkaXI0IGRvZXMgbm90IGV4aXN0XG4gKiAgICB9IGVsc2Uge1xuICogICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLmNvbmNhdChkaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyKVxuICogLnRoZW4ocmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gWyAnZmlsZTEudHh0JywgJ2ZpbGUyLnR4dCcsICdmaWxlMy50eHQnLCAnZmlsZTQudHh0JywgZmlsZTUudHh0IF1cbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMuY29uY2F0KHdpdGhNaXNzaW5nRGlyZWN0b3J5TGlzdCwgZnMucmVhZGRpcilcbiAqIC50aGVuKHJlc3VsdHMgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgLy8gc2luY2UgZGlyNCBkb2VzIG5vdCBleGlzdFxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLmNvbmNhdChkaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIFsgJ2ZpbGUxLnR4dCcsICdmaWxlMi50eHQnLCAnZmlsZTMudHh0JywgJ2ZpbGU0LnR4dCcsIGZpbGU1LnR4dCBdXG4gKiAgICAgfSBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5jb25jYXQod2l0aE1pc3NpbmdEaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgfSBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgICAgIC8vIHNpbmNlIGRpcjQgZG9lcyBub3QgZXhpc3RcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBjb25jYXQoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGNvbmNhdExpbWl0JDEoY29sbCwgSW5maW5pdHksIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBjb25jYXQkMSA9IGF3YWl0aWZ5KGNvbmNhdCwgMyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2Bjb25jYXRgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgY29uY2F0U2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5jb25jYXRde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQGFsaWFzIGZsYXRNYXBTZXJpZXNcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhbiBhcnJheSBhbiBhcnJheSBvZiByZXN1bHRzLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdFNlcmllcyhjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY29uY2F0TGltaXQkMShjb2xsLCAxLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgY29uY2F0U2VyaWVzJDEgPSBhd2FpdGlmeShjb25jYXRTZXJpZXMsIDMpO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gY2FsbGVkLCBjYWxscy1iYWNrIHdpdGggdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAqIFVzZWZ1bCBhcyB0aGUgZmlyc3QgZnVuY3Rpb24gaW4gYSBbYHdhdGVyZmFsbGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53YXRlcmZhbGx9LCBvciBmb3IgcGx1Z2dpbmcgdmFsdWVzIGluIHRvXG4gKiBbYGF1dG9gXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uXG4gKlxuICogQG5hbWUgY29uc3RhbnRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgaW52b2tlXG4gKiBjYWxsYmFjayB3aXRoLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gaW52b2tlZCwgYXV0b21hdGljYWxseVxuICogaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcHJldmlvdXMgZ2l2ZW4gYXJndW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmNvbnN0YW50KDQyKSxcbiAqICAgICBmdW5jdGlvbiAodmFsdWUsIG5leHQpIHtcbiAqICAgICAgICAgLy8gdmFsdWUgPT09IDQyXG4gKiAgICAgfSxcbiAqICAgICAvLy4uLlxuICogXSwgY2FsbGJhY2spO1xuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgYXN5bmMuY29uc3RhbnQoZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBmcy5yZWFkRmlsZSxcbiAqICAgICBmdW5jdGlvbiAoZmlsZURhdGEsIG5leHQpIHtcbiAqICAgICAgICAgLy8uLi5cbiAqICAgICB9XG4gKiAgICAgLy8uLi5cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiBhc3luYy5hdXRvKHtcbiAqICAgICBob3N0bmFtZTogYXN5bmMuY29uc3RhbnQoXCJodHRwczovL3NlcnZlci5uZXQvXCIpLFxuICogICAgIHBvcnQ6IGZpbmRGcmVlUG9ydCxcbiAqICAgICBsYXVuY2hTZXJ2ZXI6IFtcImhvc3RuYW1lXCIsIFwicG9ydFwiLCBmdW5jdGlvbiAob3B0aW9ucywgY2IpIHtcbiAqICAgICAgICAgc3RhcnRTZXJ2ZXIob3B0aW9ucywgY2IpO1xuICogICAgIH1dLFxuICogICAgIC8vLi4uXG4gKiB9LCBjYWxsYmFjayk7XG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50JDEoLi4uYXJncykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uaWdub3JlZEFyZ3MvKiwgY2FsbGJhY2sqLykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBpZ25vcmVkQXJncy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVUZXN0ZXIoY2hlY2ssIGdldFJlc3VsdCkge1xuICAgIHJldHVybiAoZWFjaGZuLCBhcnIsIF9pdGVyYXRlZSwgY2IpID0+IHtcbiAgICAgICAgdmFyIHRlc3RQYXNzZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRlc3RSZXN1bHQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGVlID0gd3JhcEFzeW5jKF9pdGVyYXRlZSk7XG4gICAgICAgIGVhY2hmbihhcnIsICh2YWx1ZSwgXywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGl0ZXJhdGVlKHZhbHVlLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIHx8IGVyciA9PT0gZmFsc2UpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrKHJlc3VsdCkgJiYgIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdFBhc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RSZXN1bHQgPSBnZXRSZXN1bHQodHJ1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYnJlYWtMb29wJDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgIGNiKG51bGwsIHRlc3RQYXNzZWQgPyB0ZXN0UmVzdWx0IDogZ2V0UmVzdWx0KGZhbHNlKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gYGNvbGxgIHRoYXQgcGFzc2VzIGFuIGFzeW5jIHRydXRoIHRlc3QuIFRoZVxuICogYGl0ZXJhdGVlYCBpcyBhcHBsaWVkIGluIHBhcmFsbGVsLCBtZWFuaW5nIHRoZSBmaXJzdCBpdGVyYXRlZSB0byByZXR1cm5cbiAqIGB0cnVlYCB3aWxsIGZpcmUgdGhlIGRldGVjdCBgY2FsbGJhY2tgIHdpdGggdGhhdCByZXN1bHQuIFRoYXQgbWVhbnMgdGhlXG4gKiByZXN1bHQgbWlnaHQgbm90IGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBvcmlnaW5hbCBgY29sbGAgKGluIHRlcm1zIG9mIG9yZGVyKVxuICogdGhhdCBwYXNzZXMgdGhlIHRlc3QuXG5cbiAqIElmIG9yZGVyIHdpdGhpbiB0aGUgb3JpZ2luYWwgYGNvbGxgIGlzIGltcG9ydGFudCwgdGhlbiBsb29rIGF0XG4gKiBbYGRldGVjdFNlcmllc2Bde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3RTZXJpZXN9LlxuICpcbiAqIEBuYW1lIGRldGVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGZpbmRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgcmVzdWx0LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3RcbiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gKiAvLyBkaXIyIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTMudHh0LCBmaWxlNC50eHRcbiAqIC8vIGRpcjMgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlNS50eHRcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBmaWxlIGV4aXN0c1xuICogZnVuY3Rpb24gZmlsZUV4aXN0cyhmaWxlLCBjYWxsYmFjaykge1xuICogICAgZnMuYWNjZXNzKGZpbGUsIGZzLmNvbnN0YW50cy5GX09LLCAoZXJyKSA9PiB7XG4gKiAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycik7XG4gKiAgICB9KTtcbiAqIH1cbiAqXG4gKiBhc3luYy5kZXRlY3QoWydmaWxlMy50eHQnLCdmaWxlMi50eHQnLCdkaXIxL2ZpbGUxLnR4dCddLCBmaWxlRXhpc3RzLFxuICogICAgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgIC8vIGRpcjEvZmlsZTEudHh0XG4gKiAgICAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgdGhlIGZpcnN0IGZpbGUgaW4gdGhlIGxpc3QgdGhhdCBleGlzdHNcbiAqICAgIH1cbiAqKTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMuZGV0ZWN0KFsnZmlsZTMudHh0JywnZmlsZTIudHh0JywnZGlyMS9maWxlMS50eHQnXSwgZmlsZUV4aXN0cylcbiAqIC50aGVuKHJlc3VsdCA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAvLyBkaXIxL2ZpbGUxLnR4dFxuICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzIHRoZSBmaXJzdCBmaWxlIGluIHRoZSBsaXN0IHRoYXQgZXhpc3RzXG4gKiB9KS5jYXRjaChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5kZXRlY3QoWydmaWxlMy50eHQnLCdmaWxlMi50eHQnLCdkaXIxL2ZpbGUxLnR4dCddLCBmaWxlRXhpc3RzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8gZGlyMS9maWxlMS50eHRcbiAqICAgICAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgdGhlIGZpbGUgaW4gdGhlIGxpc3QgdGhhdCBleGlzdHNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGRldGVjdChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRlc3Rlcihib29sID0+IGJvb2wsIChyZXMsIGl0ZW0pID0+IGl0ZW0pKGVhY2hPZiQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgZGV0ZWN0JDEgPSBhd2FpdGlmeShkZXRlY3QsIDMpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZGV0ZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIGRldGVjdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5kZXRlY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9XG4gKiBAYWxpYXMgZmluZExpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0XG4gKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGRldGVjdExpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRlc3Rlcihib29sID0+IGJvb2wsIChyZXMsIGl0ZW0pID0+IGl0ZW0pKGVhY2hPZkxpbWl0JDIobGltaXQpLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgZGV0ZWN0TGltaXQkMSA9IGF3YWl0aWZ5KGRldGVjdExpbWl0LCA0KTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGRldGVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBkZXRlY3RTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH1cbiAqIEBhbGlhcyBmaW5kU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0XG4gKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGRldGVjdFNlcmllcyhjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRlc3Rlcihib29sID0+IGJvb2wsIChyZXMsIGl0ZW0pID0+IGl0ZW0pKGVhY2hPZkxpbWl0JDIoMSksIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cblxudmFyIGRldGVjdFNlcmllcyQxID0gYXdhaXRpZnkoZGV0ZWN0U2VyaWVzLCAzKTtcblxuZnVuY3Rpb24gY29uc29sZUZ1bmMobmFtZSkge1xuICAgIHJldHVybiAoZm4sIC4uLmFyZ3MpID0+IHdyYXBBc3luYyhmbikoLi4uYXJncywgKGVyciwgLi4ucmVzdWx0QXJncykgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVtuYW1lXSkgeyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIHJlc3VsdEFyZ3MuZm9yRWFjaCh4ID0+IGNvbnNvbGVbbmFtZV0oeCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuLyoqXG4gKiBMb2dzIHRoZSByZXN1bHQgb2YgYW4gW2Bhc3luY2AgZnVuY3Rpb25de0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHRoZVxuICogYGNvbnNvbGVgIHVzaW5nIGBjb25zb2xlLmRpcmAgdG8gZGlzcGxheSB0aGUgcHJvcGVydGllcyBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIE9ubHkgd29ya3MgaW4gTm9kZS5qcyBvciBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgYGNvbnNvbGUuZGlyYCBhbmRcbiAqIGBjb25zb2xlLmVycm9yYCAoc3VjaCBhcyBGRiBhbmQgQ2hyb21lKS5cbiAqIElmIG11bHRpcGxlIGFyZ3VtZW50cyBhcmUgcmV0dXJuZWQgZnJvbSB0aGUgYXN5bmMgZnVuY3Rpb24sXG4gKiBgY29uc29sZS5kaXJgIGlzIGNhbGxlZCBvbiBlYWNoIGFyZ3VtZW50IGluIG9yZGVyLlxuICpcbiAqIEBuYW1lIGRpclxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseVxuICogYWxsIGFyZ3VtZW50cyB0by5cbiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBpbiBhIG1vZHVsZVxuICogdmFyIGhlbGxvID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCB7aGVsbG86IG5hbWV9KTtcbiAqICAgICB9LCAxMDAwKTtcbiAqIH07XG4gKlxuICogLy8gaW4gdGhlIG5vZGUgcmVwbFxuICogbm9kZT4gYXN5bmMuZGlyKGhlbGxvLCAnd29ybGQnKTtcbiAqIHtoZWxsbzogJ3dvcmxkJ31cbiAqL1xudmFyIGRpciA9IGNvbnNvbGVGdW5jKCdkaXInKTtcblxuLyoqXG4gKiBUaGUgcG9zdC1jaGVjayB2ZXJzaW9uIG9mIFtgd2hpbHN0YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0uIFRvIHJlZmxlY3QgdGhlIGRpZmZlcmVuY2UgaW5cbiAqIHRoZSBvcmRlciBvZiBvcGVyYXRpb25zLCB0aGUgYXJndW1lbnRzIGB0ZXN0YCBhbmQgYGl0ZXJhdGVlYCBhcmUgc3dpdGNoZWQuXG4gKlxuICogYGRvV2hpbHN0YCBpcyB0byBgd2hpbHN0YCBhcyBgZG8gd2hpbGVgIGlzIHRvIGB3aGlsZWAgaW4gcGxhaW4gSmF2YVNjcmlwdC5cbiAqXG4gKiBAbmFtZSBkb1doaWxzdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMud2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZSBgdGVzdGBcbiAqIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGFmdGVyIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKC4uLmFyZ3MsIGNhbGxiYWNrKSwgd2hlcmUgYC4uLmFyZ3NgIGFyZSB0aGVcbiAqIG5vbi1lcnJvciBhcmdzIGZyb20gdGhlIHByZXZpb3VzIGNhbGxiYWNrIG9mIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLlxuICogYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsXG4gKiBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pO1xuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGRvV2hpbHN0KGl0ZXJhdGVlLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2spO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcbiAgICB2YXIgcmVzdWx0cztcblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICByZXN1bHRzID0gYXJncztcbiAgICAgICAgX3Rlc3QoLi4uYXJncywgY2hlY2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrKGVyciwgdHJ1dGgpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIGlmICghdHJ1dGgpIHJldHVybiBjYWxsYmFjayhudWxsLCAuLi5yZXN1bHRzKTtcbiAgICAgICAgX2ZuKG5leHQpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGVjayhudWxsLCB0cnVlKTtcbn1cblxudmFyIGRvV2hpbHN0JDEgPSBhd2FpdGlmeShkb1doaWxzdCwgMyk7XG5cbi8qKlxuICogTGlrZSBbJ2RvV2hpbHN0J117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fSwgZXhjZXB0IHRoZSBgdGVzdGAgaXMgaW52ZXJ0ZWQuIE5vdGUgdGhlXG4gKiBhcmd1bWVudCBvcmRlcmluZyBkaWZmZXJzIGZyb20gYHVudGlsYC5cbiAqXG4gKiBAbmFtZSBkb1VudGlsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5kb1doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWVcbiAqIGB0ZXN0YCBmYWlscy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGFmdGVyIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKC4uLmFyZ3MsIGNhbGxiYWNrKSwgd2hlcmUgYC4uLmFyZ3NgIGFyZSB0aGVcbiAqIG5vbi1lcnJvciBhcmdzIGZyb20gdGhlIHByZXZpb3VzIGNhbGxiYWNrIG9mIGBpdGVyYXRlZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdFxuICogZnVuY3Rpb24gaGFzIHBhc3NlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2BcbiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzXG4gKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZG9VbnRpbChpdGVyYXRlZSwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcbiAgICByZXR1cm4gZG9XaGlsc3QkMShpdGVyYXRlZSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgY2IgPSBhcmdzLnBvcCgpO1xuICAgICAgICBfdGVzdCguLi5hcmdzLCAoZXJyLCB0cnV0aCkgPT4gY2IgKGVyciwgIXRydXRoKSk7XG4gICAgfSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBfd2l0aG91dEluZGV4KGl0ZXJhdGVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSA9PiBpdGVyYXRlZSh2YWx1ZSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGZ1bmN0aW9uIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwgaW4gcGFyYWxsZWwuXG4gKiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aCBhbiBpdGVtIGZyb20gdGhlIGxpc3QsIGFuZCBhIGNhbGxiYWNrIGZvciB3aGVuXG4gKiBpdCBoYXMgZmluaXNoZWQuIElmIHRoZSBgaXRlcmF0ZWVgIHBhc3NlcyBhbiBlcnJvciB0byBpdHMgYGNhbGxiYWNrYCwgdGhlXG4gKiBtYWluIGBjYWxsYmFja2AgKGZvciB0aGUgYGVhY2hgIGZ1bmN0aW9uKSBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGVcbiAqIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoYXQgc2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIHBhcmFsbGVsLFxuICogdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlIGluIG9yZGVyLlxuICpcbiAqIEBuYW1lIGVhY2hcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBmb3JFYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG9cbiAqIGVhY2ggaXRlbSBpbiBgY29sbGAuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZmAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGRpcjEgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMS50eHQsIGZpbGUyLnR4dFxuICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gKiAvLyBkaXIzIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTUudHh0XG4gKiAvLyBkaXI0IGRvZXMgbm90IGV4aXN0XG4gKlxuICogY29uc3QgZmlsZUxpc3QgPSBbICdkaXIxL2ZpbGUyLnR4dCcsICdkaXIyL2ZpbGUzLnR4dCcsICdkaXIvZmlsZTUudHh0J107XG4gKiBjb25zdCB3aXRoTWlzc2luZ0ZpbGVMaXN0ID0gWydkaXIxL2ZpbGUxLnR4dCcsICdkaXI0L2ZpbGUyLnR4dCddO1xuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGRlbGV0ZXMgYSBmaWxlXG4gKiBjb25zdCBkZWxldGVGaWxlID0gZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgICBmcy51bmxpbmsoZmlsZSwgY2FsbGJhY2spO1xuICogfTtcbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLmVhY2goZmlsZUxpc3QsIGRlbGV0ZUZpbGUsIGZ1bmN0aW9uKGVycikge1xuICogICAgIGlmKCBlcnIgKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ0FsbCBmaWxlcyBoYXZlIGJlZW4gZGVsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMuZWFjaCh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBkZWxldGVGaWxlLCBmdW5jdGlvbihlcnIpe1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICAvLyBzaW5jZSBkaXI0L2ZpbGUyLnR4dCBkb2VzIG5vdCBleGlzdFxuICogICAgIC8vIGRpcjEvZmlsZTEudHh0IGNvdWxkIGhhdmUgYmVlbiBkZWxldGVkXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMuZWFjaChmaWxlTGlzdCwgZGVsZXRlRmlsZSlcbiAqIC50aGVuKCAoKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ0FsbCBmaWxlcyBoYXZlIGJlZW4gZGVsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMuZWFjaChmaWxlTGlzdCwgZGVsZXRlRmlsZSlcbiAqIC50aGVuKCAoKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ0FsbCBmaWxlcyBoYXZlIGJlZW4gZGVsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICAvLyBzaW5jZSBkaXI0L2ZpbGUyLnR4dCBkb2VzIG5vdCBleGlzdFxuICogICAgIC8vIGRpcjEvZmlsZTEudHh0IGNvdWxkIGhhdmUgYmVlbiBkZWxldGVkXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGF3YWl0IGFzeW5jLmVhY2goZmlsZXMsIGRlbGV0ZUZpbGUpO1xuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgYXdhaXQgYXN5bmMuZWFjaCh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBkZWxldGVGaWxlKTtcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogICAgICAgICAvLyBzaW5jZSBkaXI0L2ZpbGUyLnR4dCBkb2VzIG5vdCBleGlzdFxuICogICAgICAgICAvLyBkaXIxL2ZpbGUxLnR4dCBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZFxuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGVhY2hMaW1pdCQyKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBlYWNoT2YkMShjb2xsLCBfd2l0aG91dEluZGV4KHdyYXBBc3luYyhpdGVyYXRlZSkpLCBjYWxsYmFjayk7XG59XG5cbnZhciBlYWNoID0gYXdhaXRpZnkoZWFjaExpbWl0JDIsIDMpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBlYWNoTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofVxuICogQGFsaWFzIGZvckVhY2hMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZkxpbWl0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICovXG5mdW5jdGlvbiBlYWNoTGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBlYWNoT2ZMaW1pdCQyKGxpbWl0KShjb2xsLCBfd2l0aG91dEluZGV4KHdyYXBBc3luYyhpdGVyYXRlZSkpLCBjYWxsYmFjayk7XG59XG52YXIgZWFjaExpbWl0JDEgPSBhd2FpdGlmeShlYWNoTGltaXQsIDQpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogTm90ZSwgdGhhdCB1bmxpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgaXRlcmF0ZWUgdG8gZWFjaCBpdGVtXG4gKiBpbiBzZXJpZXMgYW5kIHRoZXJlZm9yZSB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUgaW4gb3JkZXIuXG5cbiAqIEBuYW1lIGVhY2hTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofVxuICogQGFsaWFzIGZvckVhY2hTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS5cbiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZTZXJpZXNgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGVhY2hTZXJpZXMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGVhY2hMaW1pdCQxKGNvbGwsIDEsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBlYWNoU2VyaWVzJDEgPSBhd2FpdGlmeShlYWNoU2VyaWVzLCAzKTtcblxuLyoqXG4gKiBXcmFwIGFuIGFzeW5jIGZ1bmN0aW9uIGFuZCBlbnN1cmUgaXQgY2FsbHMgaXRzIGNhbGxiYWNrIG9uIGEgbGF0ZXIgdGljayBvZlxuICogdGhlIGV2ZW50IGxvb3AuICBJZiB0aGUgZnVuY3Rpb24gYWxyZWFkeSBjYWxscyBpdHMgY2FsbGJhY2sgb24gYSBuZXh0IHRpY2ssXG4gKiBubyBleHRyYSBkZWZlcnJhbCBpcyBhZGRlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIHByZXZlbnRpbmcgc3RhY2sgb3ZlcmZsb3dzXG4gKiAoYFJhbmdlRXJyb3I6IE1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkYCkgYW5kIGdlbmVyYWxseSBrZWVwaW5nXG4gKiBbWmFsZ29dKGh0dHA6Ly9ibG9nLml6cy5tZS9wb3N0LzU5MTQyNzQyMTQzL2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogY29udGFpbmVkLiBFUzIwMTcgYGFzeW5jYCBmdW5jdGlvbnMgYXJlIHJldHVybmVkIGFzLWlzIC0tIHRoZXkgYXJlIGltbXVuZVxuICogdG8gWmFsZ28ncyBjb3JydXB0aW5nIGluZmx1ZW5jZXMsIGFzIHRoZXkgYWx3YXlzIHJlc29sdmUgb24gYSBsYXRlciB0aWNrLlxuICpcbiAqIEBuYW1lIGVuc3VyZUFzeW5jXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIGFuIGFzeW5jIGZ1bmN0aW9uLCBvbmUgdGhhdCBleHBlY3RzIGEgbm9kZS1zdHlsZVxuICogY2FsbGJhY2sgYXMgaXRzIGxhc3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gUmV0dXJucyBhIHdyYXBwZWQgZnVuY3Rpb24gd2l0aCB0aGUgZXhhY3Qgc2FtZSBjYWxsXG4gKiBzaWduYXR1cmUgYXMgdGhlIGZ1bmN0aW9uIHBhc3NlZCBpbi5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc29tZXRpbWVzQXN5bmMoYXJnLCBjYWxsYmFjaykge1xuICogICAgIGlmIChjYWNoZVthcmddKSB7XG4gKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjYWNoZVthcmddKTsgLy8gdGhpcyB3b3VsZCBiZSBzeW5jaHJvbm91cyEhXG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgZG9Tb21lSU8oYXJnLCBjYWxsYmFjayk7IC8vIHRoaXMgSU8gd291bGQgYmUgYXN5bmNocm9ub3VzXG4gKiAgICAgfVxuICogfVxuICpcbiAqIC8vIHRoaXMgaGFzIGEgcmlzayBvZiBzdGFjayBvdmVyZmxvd3MgaWYgbWFueSByZXN1bHRzIGFyZSBjYWNoZWQgaW4gYSByb3dcbiAqIGFzeW5jLm1hcFNlcmllcyhhcmdzLCBzb21ldGltZXNBc3luYywgZG9uZSk7XG4gKlxuICogLy8gdGhpcyB3aWxsIGRlZmVyIHNvbWV0aW1lc0FzeW5jJ3MgY2FsbGJhY2sgaWYgbmVjZXNzYXJ5LFxuICogLy8gcHJldmVudGluZyBzdGFjayBvdmVyZmxvd3NcbiAqIGFzeW5jLm1hcFNlcmllcyhhcmdzLCBhc3luYy5lbnN1cmVBc3luYyhzb21ldGltZXNBc3luYyksIGRvbmUpO1xuICovXG5mdW5jdGlvbiBlbnN1cmVBc3luYyhmbikge1xuICAgIGlmIChpc0FzeW5jKGZuKSkgcmV0dXJuIGZuO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncy8qLCBjYWxsYmFjayovKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgICAgYXJncy5wdXNoKCguLi5pbm5lckFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoKCkgPT4gY2FsbGJhY2soLi4uaW5uZXJBcmdzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKC4uLmlubmVyQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgc3luYyA9IGZhbHNlO1xuICAgIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgZXZlcnkgZWxlbWVudCBpbiBgY29sbGAgc2F0aXNmaWVzIGFuIGFzeW5jIHRlc3QuIElmIGFueVxuICogaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGBmYWxzZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICpcbiAqIEBuYW1lIGV2ZXJ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgYWxsXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAqIGluIHRoZSBjb2xsZWN0aW9uIGluIHBhcmFsbGVsLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gcmVzdWx0IHZhbHVlLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgXG4gKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMgdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gKiAvLyBkaXIyIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTMudHh0LCBmaWxlNC50eHRcbiAqIC8vIGRpcjMgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlNS50eHRcbiAqIC8vIGRpcjQgZG9lcyBub3QgZXhpc3RcbiAqXG4gKiBjb25zdCBmaWxlTGlzdCA9IFsnZGlyMS9maWxlMS50eHQnLCdkaXIyL2ZpbGUzLnR4dCcsJ2RpcjMvZmlsZTUudHh0J107XG4gKiBjb25zdCB3aXRoTWlzc2luZ0ZpbGVMaXN0ID0gWydmaWxlMS50eHQnLCdmaWxlMi50eHQnLCdmaWxlNC50eHQnXTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBmaWxlIGV4aXN0c1xuICogZnVuY3Rpb24gZmlsZUV4aXN0cyhmaWxlLCBjYWxsYmFjaykge1xuICogICAgZnMuYWNjZXNzKGZpbGUsIGZzLmNvbnN0YW50cy5GX09LLCAoZXJyKSA9PiB7XG4gKiAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycik7XG4gKiAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLmV2ZXJ5KGZpbGVMaXN0LCBmaWxlRXhpc3RzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gdHJ1ZVxuICogICAgIC8vIHJlc3VsdCBpcyB0cnVlIHNpbmNlIGV2ZXJ5IGZpbGUgZXhpc3RzXG4gKiB9KTtcbiAqXG4gKiBhc3luYy5ldmVyeSh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBmaWxlRXhpc3RzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gZmFsc2VcbiAqICAgICAvLyByZXN1bHQgaXMgZmFsc2Ugc2luY2UgTk9UIGV2ZXJ5IGZpbGUgZXhpc3RzXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMuZXZlcnkoZmlsZUxpc3QsIGZpbGVFeGlzdHMpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIHRydWVcbiAqICAgICAvLyByZXN1bHQgaXMgdHJ1ZSBzaW5jZSBldmVyeSBmaWxlIGV4aXN0c1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIGFzeW5jLmV2ZXJ5KHdpdGhNaXNzaW5nRmlsZUxpc3QsIGZpbGVFeGlzdHMpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIGZhbHNlXG4gKiAgICAgLy8gcmVzdWx0IGlzIGZhbHNlIHNpbmNlIE5PVCBldmVyeSBmaWxlIGV4aXN0c1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLmV2ZXJ5KGZpbGVMaXN0LCBmaWxlRXhpc3RzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8gdHJ1ZVxuICogICAgICAgICAvLyByZXN1bHQgaXMgdHJ1ZSBzaW5jZSBldmVyeSBmaWxlIGV4aXN0c1xuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMuZXZlcnkod2l0aE1pc3NpbmdGaWxlTGlzdCwgZmlsZUV4aXN0cyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIGZhbHNlXG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyBmYWxzZSBzaW5jZSBOT1QgZXZlcnkgZmlsZSBleGlzdHNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGV2ZXJ5KGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfY3JlYXRlVGVzdGVyKGJvb2wgPT4gIWJvb2wsIHJlcyA9PiAhcmVzKShlYWNoT2YkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIGV2ZXJ5JDEgPSBhd2FpdGlmeShldmVyeSwgMyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BldmVyeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZXZlcnlMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZXZlcnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX1cbiAqIEBhbGlhcyBhbGxMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIGV2ZXJ5TGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfY3JlYXRlVGVzdGVyKGJvb2wgPT4gIWJvb2wsIHJlcyA9PiAhcmVzKShlYWNoT2ZMaW1pdCQyKGxpbWl0KSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIGV2ZXJ5TGltaXQkMSA9IGF3YWl0aWZ5KGV2ZXJ5TGltaXQsIDQpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZXZlcnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBldmVyeVNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZXZlcnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX1cbiAqIEBhbGlhcyBhbGxTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb24gaW4gc2VyaWVzLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gcmVzdWx0IHZhbHVlLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgXG4gKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMgdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqL1xuZnVuY3Rpb24gZXZlcnlTZXJpZXMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUZXN0ZXIoYm9vbCA9PiAhYm9vbCwgcmVzID0+ICFyZXMpKGVhY2hPZlNlcmllcyQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgZXZlcnlTZXJpZXMkMSA9IGF3YWl0aWZ5KGV2ZXJ5U2VyaWVzLCAzKTtcblxuZnVuY3Rpb24gZmlsdGVyQXJyYXkoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciB0cnV0aFZhbHVlcyA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgICBlYWNoZm4oYXJyLCAoeCwgaW5kZXgsIGl0ZXJDYikgPT4ge1xuICAgICAgICBpdGVyYXRlZSh4LCAoZXJyLCB2KSA9PiB7XG4gICAgICAgICAgICB0cnV0aFZhbHVlc1tpbmRleF0gPSAhIXY7XG4gICAgICAgICAgICBpdGVyQ2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZXJyID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHJ1dGhWYWx1ZXNbaV0pIHJlc3VsdHMucHVzaChhcnJbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJHZW5lcmljKGVhY2hmbiwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBlYWNoZm4oY29sbCwgKHgsIGluZGV4LCBpdGVyQ2IpID0+IHtcbiAgICAgICAgaXRlcmF0ZWUoeCwgKGVyciwgdikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGl0ZXJDYihlcnIpO1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe2luZGV4LCB2YWx1ZTogeH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlckNiKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpXG4gICAgICAgICAgICAubWFwKHYgPT4gdi52YWx1ZSkpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZmlsdGVyKGVhY2hmbiwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpbHRlciA9IGlzQXJyYXlMaWtlKGNvbGwpID8gZmlsdGVyQXJyYXkgOiBmaWx0ZXJHZW5lcmljO1xuICAgIHJldHVybiBmaWx0ZXIoZWFjaGZuLCBjb2xsLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBhcnJheSBvZiBhbGwgdGhlIHZhbHVlcyBpbiBgY29sbGAgd2hpY2ggcGFzcyBhbiBhc3luYyB0cnV0aFxuICogdGVzdC4gVGhpcyBvcGVyYXRpb24gaXMgcGVyZm9ybWVkIGluIHBhcmFsbGVsLCBidXQgdGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZVxuICogaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIG9yaWdpbmFsLlxuICpcbiAqIEBuYW1lIGZpbHRlclxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIHNlbGVjdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gKiAvLyBkaXIyIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTMudHh0LCBmaWxlNC50eHRcbiAqIC8vIGRpcjMgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlNS50eHRcbiAqXG4gKiBjb25zdCBmaWxlcyA9IFsnZGlyMS9maWxlMS50eHQnLCdkaXIyL2ZpbGUzLnR4dCcsJ2RpcjMvZmlsZTYudHh0J107XG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGEgZmlsZSBleGlzdHNcbiAqIGZ1bmN0aW9uIGZpbGVFeGlzdHMoZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgIGZzLmFjY2VzcyhmaWxlLCBmcy5jb25zdGFudHMuRl9PSywgKGVycikgPT4ge1xuICogICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpO1xuICogICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy5maWx0ZXIoZmlsZXMsIGZpbGVFeGlzdHMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgaWYoZXJyKSB7XG4gKiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgIH0gZWxzZSB7XG4gKiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgLy8gWyAnZGlyMS9maWxlMS50eHQnLCAnZGlyMi9maWxlMy50eHQnIF1cbiAqICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXNcbiAqICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5maWx0ZXIoZmlsZXMsIGZpbGVFeGlzdHMpXG4gKiAudGhlbihyZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyBbICdkaXIxL2ZpbGUxLnR4dCcsICdkaXIyL2ZpbGUzLnR4dCcgXVxuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHRoZSBleGlzdGluZyBmaWxlc1xuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLmZpbHRlcihmaWxlcywgZmlsZUV4aXN0cyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAvLyBbICdkaXIxL2ZpbGUxLnR4dCcsICdkaXIyL2ZpbGUzLnR4dCcgXVxuICogICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGZpbHRlciAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9maWx0ZXIoZWFjaE9mJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBmaWx0ZXIkMSA9IGF3YWl0aWZ5KGZpbHRlciwgMyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BmaWx0ZXJgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZmlsdGVyTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmZpbHRlcl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn1cbiAqIEBhbGlhcyBzZWxlY3RMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqL1xuZnVuY3Rpb24gZmlsdGVyTGltaXQgKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2ZpbHRlcihlYWNoT2ZMaW1pdCQyKGxpbWl0KSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIGZpbHRlckxpbWl0JDEgPSBhd2FpdGlmeShmaWx0ZXJMaW1pdCwgNCk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BmaWx0ZXJgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZmlsdGVyU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9XG4gKiBAYWxpYXMgc2VsZWN0U2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGBpdGVyYXRlZWAgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgLCB3aGljaCBtdXN0IGJlIGNhbGxlZFxuICogd2l0aCBhIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cylcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIGZpbHRlclNlcmllcyAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9maWx0ZXIoZWFjaE9mU2VyaWVzJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBmaWx0ZXJTZXJpZXMkMSA9IGF3YWl0aWZ5KGZpbHRlclNlcmllcywgMyk7XG5cbi8qKlxuICogQ2FsbHMgdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBgZm5gIHdpdGggYSBjYWxsYmFjayBwYXJhbWV0ZXIgdGhhdCBhbGxvd3MgaXRcbiAqIHRvIGNhbGwgaXRzZWxmIGFnYWluLCBpbiBzZXJpZXMsIGluZGVmaW5pdGVseS5cblxuICogSWYgYW4gZXJyb3IgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayB0aGVuIGBlcnJiYWNrYCBpcyBjYWxsZWQgd2l0aCB0aGVcbiAqIGVycm9yLCBhbmQgZXhlY3V0aW9uIHN0b3BzLCBvdGhlcndpc2UgaXQgd2lsbCBuZXZlciBiZSBjYWxsZWQuXG4gKlxuICogQG5hbWUgZm9yZXZlclxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIGFuIGFzeW5jIGZ1bmN0aW9uIHRvIGNhbGwgcmVwZWF0ZWRseS5cbiAqIEludm9rZWQgd2l0aCAobmV4dCkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyYmFja10gLSB3aGVuIGBmbmAgcGFzc2VzIGFuIGVycm9yIHRvIGl0J3MgY2FsbGJhY2ssXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkLCBhbmQgZXhlY3V0aW9uIHN0b3BzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgcmVqZWN0cyBpZiBhbiBlcnJvciBvY2N1cnMgYW5kIGFuIGVycmJhY2tcbiAqIGlzIG5vdCBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZm9yZXZlcihcbiAqICAgICBmdW5jdGlvbihuZXh0KSB7XG4gKiAgICAgICAgIC8vIG5leHQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gdGhpbmdzIHRoYXQgbmVlZCBhIGNhbGxiYWNrKGVyciBbLCB3aGF0ZXZlcl0pO1xuICogICAgICAgICAvLyBpdCB3aWxsIHJlc3VsdCBpbiB0aGlzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBhZ2Fpbi5cbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICAvLyBpZiBuZXh0IGlzIGNhbGxlZCB3aXRoIGEgdmFsdWUgaW4gaXRzIGZpcnN0IHBhcmFtZXRlciwgaXQgd2lsbCBhcHBlYXJcbiAqICAgICAgICAgLy8gaW4gaGVyZSBhcyAnZXJyJywgYW5kIGV4ZWN1dGlvbiB3aWxsIHN0b3AuXG4gKiAgICAgfVxuICogKTtcbiAqL1xuZnVuY3Rpb24gZm9yZXZlcihmbiwgZXJyYmFjaykge1xuICAgIHZhciBkb25lID0gb25seU9uY2UoZXJyYmFjayk7XG4gICAgdmFyIHRhc2sgPSB3cmFwQXN5bmMoZW5zdXJlQXN5bmMoZm4pKTtcblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7XG4gICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIHRhc2sobmV4dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG59XG52YXIgZm9yZXZlciQxID0gYXdhaXRpZnkoZm9yZXZlciwgMik7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2Bncm91cEJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmdyb3VwQnl9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGdyb3VwQnlMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZ3JvdXBCeV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmdyb3VwQnl9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBga2V5YCB0byBncm91cCB0aGUgdmFsdWUgdW5kZXIuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0IGlzIGFuIGBPYmplY3RgIHdob3Nlc1xuICogcHJvcGVydGllcyBhcmUgYXJyYXlzIG9mIHZhbHVlcyB3aGljaCByZXR1cm5lZCB0aGUgY29ycmVzcG9uZGluZyBrZXkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZ3JvdXBCeUxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICByZXR1cm4gbWFwTGltaXQkMShjb2xsLCBsaW1pdCwgKHZhbCwgaXRlckNiKSA9PiB7XG4gICAgICAgIF9pdGVyYXRlZSh2YWwsIChlcnIsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGl0ZXJDYihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJDYihlcnIsIHtrZXksIHZhbH0pO1xuICAgICAgICB9KTtcbiAgICB9LCAoZXJyLCBtYXBSZXN1bHRzKSA9PiB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gZnJvbSBNRE4sIGhhbmRsZSBvYmplY3QgaGF2aW5nIGFuIGBoYXNPd25Qcm9wZXJ0eWAgcHJvcFxuICAgICAgICB2YXIge2hhc093blByb3BlcnR5fSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBSZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWFwUmVzdWx0c1tpXSkge1xuICAgICAgICAgICAgICAgIHZhciB7a2V5fSA9IG1hcFJlc3VsdHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHt2YWx9ID0gbWFwUmVzdWx0c1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBbdmFsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgIH0pO1xufVxuXG52YXIgZ3JvdXBCeUxpbWl0JDEgPSBhd2FpdGlmeShncm91cEJ5TGltaXQsIDQpO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0LCB3aGVyZSBlYWNoIHZhbHVlIGNvcnJlc3BvbmRzIHRvIGFuIGFycmF5IG9mIGl0ZW1zLCBmcm9tXG4gKiBgY29sbGAsIHRoYXQgcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LiBUaGF0IGlzLCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0XG4gKiBjb3JyZXNwb25kIHRvIHRoZSB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBgaXRlcmF0ZWVgIGNhbGxiYWNrLlxuICpcbiAqIE5vdGU6IFNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsXG4gKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci5cbiAqIEhvd2V2ZXIsIHRoZSB2YWx1ZXMgZm9yIGVhY2gga2V5IGluIHRoZSBgcmVzdWx0YCB3aWxsIGJlIGluIHRoZSBzYW1lIG9yZGVyIGFzXG4gKiB0aGUgb3JpZ2luYWwgYGNvbGxgLiBGb3IgT2JqZWN0cywgdGhlIHZhbHVlcyB3aWxsIHJvdWdobHkgYmUgaW4gdGhlIG9yZGVyIG9mXG4gKiB0aGUgb3JpZ2luYWwgT2JqZWN0cycga2V5cyAoYnV0IHRoaXMgY2FuIHZhcnkgYWNyb3NzIEphdmFTY3JpcHQgZW5naW5lcykuXG4gKlxuICogQG5hbWUgZ3JvdXBCeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYGtleWAgdG8gZ3JvdXAgdGhlIHZhbHVlIHVuZGVyLlxuICogSW52b2tlZCB3aXRoICh2YWx1ZSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdCBpcyBhbiBgT2JqZWN0YCB3aG9zZXNcbiAqIHByb3BlcnRpZXMgYXJlIGFycmF5cyBvZiB2YWx1ZXMgd2hpY2ggcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGRpcjEgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMS50eHQsIGZpbGUyLnR4dFxuICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gKiAvLyBkaXIzIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTUudHh0XG4gKiAvLyBkaXI0IGRvZXMgbm90IGV4aXN0XG4gKlxuICogY29uc3QgZmlsZXMgPSBbJ2RpcjEvZmlsZTEudHh0JywnZGlyMicsJ2RpcjQnXVxuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGRldGVjdHMgZmlsZSB0eXBlIGFzIG5vbmUsIGZpbGUsIG9yIGRpcmVjdG9yeVxuICogZnVuY3Rpb24gZGV0ZWN0RmlsZShmaWxlLCBjYWxsYmFjaykge1xuICogICAgIGZzLnN0YXQoZmlsZSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAnbm9uZScpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdkaXJlY3RvcnknIDogJ2ZpbGUnKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiAvL1VzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMuZ3JvdXBCeShmaWxlcywgZGV0ZWN0RmlsZSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICBpZihlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9IGVsc2Uge1xuICpcdCAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyB7XG4gKiAgICAgICAgIC8vICAgICBmaWxlOiBbICdkaXIxL2ZpbGUxLnR4dCcgXSxcbiAqICAgICAgICAgLy8gICAgIG5vbmU6IFsgJ2RpcjQnIF0sXG4gKiAgICAgICAgIC8vICAgICBkaXJlY3Rvcnk6IFsgJ2RpcjInXVxuICogICAgICAgICAvLyB9XG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgZ3JvdXBlZCBieSB0eXBlXG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLmdyb3VwQnkoZmlsZXMsIGRldGVjdEZpbGUpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIHtcbiAqICAgICAvLyAgICAgZmlsZTogWyAnZGlyMS9maWxlMS50eHQnIF0sXG4gKiAgICAgLy8gICAgIG5vbmU6IFsgJ2RpcjQnIF0sXG4gKiAgICAgLy8gICAgIGRpcmVjdG9yeTogWyAnZGlyMiddXG4gKiAgICAgLy8gfVxuICogICAgIC8vIHJlc3VsdCBpcyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgZ3JvdXBlZCBieSB0eXBlXG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMuZ3JvdXBCeShmaWxlcywgZGV0ZWN0RmlsZSk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIHtcbiAqICAgICAgICAgLy8gICAgIGZpbGU6IFsgJ2RpcjEvZmlsZTEudHh0JyBdLFxuICogICAgICAgICAvLyAgICAgbm9uZTogWyAnZGlyNCcgXSxcbiAqICAgICAgICAgLy8gICAgIGRpcmVjdG9yeTogWyAnZGlyMiddXG4gKiAgICAgICAgIC8vIH1cbiAqICAgICAgICAgLy8gcmVzdWx0IGlzIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlcyBncm91cGVkIGJ5IHR5cGVcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGdyb3VwQnkgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBncm91cEJ5TGltaXQkMShjb2xsLCBJbmZpbml0eSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZ3JvdXBCeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZ3JvdXBCeVNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZ3JvdXBCeV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmdyb3VwQnl9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBga2V5YCB0byBncm91cCB0aGUgdmFsdWUgdW5kZXIuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0IGlzIGFuIGBPYmplY3RgIHdob3NlXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBncm91cEJ5U2VyaWVzIChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZ3JvdXBCeUxpbWl0JDEoY29sbCwgMSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIExvZ3MgdGhlIHJlc3VsdCBvZiBhbiBgYXN5bmNgIGZ1bmN0aW9uIHRvIHRoZSBgY29uc29sZWAuIE9ubHkgd29ya3MgaW5cbiAqIE5vZGUuanMgb3IgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBjb25zb2xlLmxvZ2AgYW5kIGBjb25zb2xlLmVycm9yYCAoc3VjaFxuICogYXMgRkYgYW5kIENocm9tZSkuIElmIG11bHRpcGxlIGFyZ3VtZW50cyBhcmUgcmV0dXJuZWQgZnJvbSB0aGUgYXN5bmNcbiAqIGZ1bmN0aW9uLCBgY29uc29sZS5sb2dgIGlzIGNhbGxlZCBvbiBlYWNoIGFyZ3VtZW50IGluIG9yZGVyLlxuICpcbiAqIEBuYW1lIGxvZ1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseVxuICogYWxsIGFyZ3VtZW50cyB0by5cbiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBpbiBhIG1vZHVsZVxuICogdmFyIGhlbGxvID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnaGVsbG8gJyArIG5hbWUpO1xuICogICAgIH0sIDEwMDApO1xuICogfTtcbiAqXG4gKiAvLyBpbiB0aGUgbm9kZSByZXBsXG4gKiBub2RlPiBhc3luYy5sb2coaGVsbG8sICd3b3JsZCcpO1xuICogJ2hlbGxvIHdvcmxkJ1xuICovXG52YXIgbG9nID0gY29uc29sZUZ1bmMoJ2xvZycpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgbWFwVmFsdWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcFZhbHVlc0xpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBWYWx1ZXNde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHZhbHVlIGFuZCBrZXlcbiAqIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nXG4gKiBvZiBlYWNoIGtleSBmcm9tIGBvYmpgLCB3aXRoIGVhY2ggdHJhbnNmb3JtZWQgdmFsdWUgb24gdGhlIHJpZ2h0LWhhbmQgc2lkZS5cbiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlc0xpbWl0KG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gICAgdmFyIG5ld09iaiA9IHt9O1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHJldHVybiBlYWNoT2ZMaW1pdCQyKGxpbWl0KShvYmosICh2YWwsIGtleSwgbmV4dCkgPT4ge1xuICAgICAgICBfaXRlcmF0ZWUodmFsLCBrZXksIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKTtcbiAgICAgICAgICAgIG5ld09ialtrZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgbmV4dChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBlcnIgPT4gY2FsbGJhY2soZXJyLCBuZXdPYmopKTtcbn1cblxudmFyIG1hcFZhbHVlc0xpbWl0JDEgPSBhd2FpdGlmeShtYXBWYWx1ZXNMaW1pdCwgNCk7XG5cbi8qKlxuICogQSByZWxhdGl2ZSBvZiBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LCBkZXNpZ25lZCBmb3IgdXNlIHdpdGggb2JqZWN0cy5cbiAqXG4gKiBQcm9kdWNlcyBhIG5ldyBPYmplY3QgYnkgbWFwcGluZyBlYWNoIHZhbHVlIG9mIGBvYmpgIHRocm91Z2ggdGhlIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgZWFjaCBgdmFsdWVgIGFuZCBga2V5YCBmcm9tIGBvYmpgIGFuZCBhXG4gKiBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFja3MgdGFrZXNcbiAqIHR3byBhcmd1bWVudHM6IGFuIGBlcnJvcmAsIGFuZCB0aGUgdHJhbnNmb3JtZWQgaXRlbSBmcm9tIGBvYmpgLiBJZiBgaXRlcmF0ZWVgXG4gKiBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlIGBtYXBWYWx1ZXNgXG4gKiBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoZSBvcmRlciBvZiB0aGUga2V5cyBpbiB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkLiAgVGhlIGtleXMgd2lsbFxuICogYmUgcm91Z2hseSBpbiB0aGUgb3JkZXIgdGhleSBjb21wbGV0ZSwgKGJ1dCB0aGlzIGlzIHZlcnkgZW5naW5lLXNwZWNpZmljKVxuICpcbiAqIEBuYW1lIG1hcFZhbHVlc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5XG4gKiBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZ1xuICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBmaWxlMS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMi50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMjAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMy50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMzAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlNC50eHQgZG9lcyBub3QgZXhpc3RcbiAqXG4gKiBjb25zdCBmaWxlTWFwID0ge1xuICogICAgIGYxOiAnZmlsZTEudHh0JyxcbiAqICAgICBmMjogJ2ZpbGUyLnR4dCcsXG4gKiAgICAgZjM6ICdmaWxlMy50eHQnXG4gKiB9O1xuICpcbiAqIGNvbnN0IHdpdGhNaXNzaW5nRmlsZU1hcCA9IHtcbiAqICAgICBmMTogJ2ZpbGUxLnR4dCcsXG4gKiAgICAgZjI6ICdmaWxlMi50eHQnLFxuICogICAgIGYzOiAnZmlsZTQudHh0J1xuICogfTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBmaWxlIHNpemUgaW4gYnl0ZXNcbiAqIGZ1bmN0aW9uIGdldEZpbGVTaXplSW5CeXRlcyhmaWxlLCBrZXksIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdC5zaXplKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLm1hcFZhbHVlcyhmaWxlTWFwLCBnZXRGaWxlU2l6ZUluQnl0ZXMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgaWYgKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyBub3cgYSBtYXAgb2YgZmlsZSBzaXplIGluIGJ5dGVzIGZvciBlYWNoIGZpbGUsIGUuZy5cbiAqICAgICAgICAgLy8ge1xuICogICAgICAgICAvLyAgICAgZjE6IDEwMDAsXG4gKiAgICAgICAgIC8vICAgICBmMjogMjAwMCxcbiAqICAgICAgICAgLy8gICAgIGYzOiAzMDAwXG4gKiAgICAgICAgIC8vIH1cbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBoYW5kbGluZ1xuICogYXN5bmMubWFwVmFsdWVzKHdpdGhNaXNzaW5nRmlsZU1hcCwgZ2V0RmlsZVNpemVJbkJ5dGVzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5tYXBWYWx1ZXMoZmlsZU1hcCwgZ2V0RmlsZVNpemVJbkJ5dGVzKVxuICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAvLyByZXN1bHQgaXMgbm93IGEgbWFwIG9mIGZpbGUgc2l6ZSBpbiBieXRlcyBmb3IgZWFjaCBmaWxlLCBlLmcuXG4gKiAgICAgLy8ge1xuICogICAgIC8vICAgICBmMTogMTAwMCxcbiAqICAgICAvLyAgICAgZjI6IDIwMDAsXG4gKiAgICAgLy8gICAgIGYzOiAzMDAwXG4gKiAgICAgLy8gfVxuICogfSkuY2F0Y2ggKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYy5tYXBWYWx1ZXMod2l0aE1pc3NpbmdGaWxlTWFwLCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogfSkuY2F0Y2ggKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMubWFwVmFsdWVzKGZpbGVNYXAsIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyBub3cgYSBtYXAgb2YgZmlsZSBzaXplIGluIGJ5dGVzIGZvciBlYWNoIGZpbGUsIGUuZy5cbiAqICAgICAgICAgLy8ge1xuICogICAgICAgICAvLyAgICAgZjE6IDEwMDAsXG4gKiAgICAgICAgIC8vICAgICBmMjogMjAwMCxcbiAqICAgICAgICAgLy8gICAgIGYzOiAzMDAwXG4gKiAgICAgICAgIC8vIH1cbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5tYXBWYWx1ZXMod2l0aE1pc3NpbmdGaWxlTWFwLCBnZXRGaWxlU2l6ZUluQnl0ZXMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgfVxuICogfVxuICpcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1hcFZhbHVlc0xpbWl0JDEob2JqLCBJbmZpbml0eSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgbWFwVmFsdWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcFZhbHVlc1Nlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubWFwVmFsdWVzXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5XG4gKiBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZ1xuICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBtYXBWYWx1ZXNTZXJpZXMob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbWFwVmFsdWVzTGltaXQkMShvYmosIDEsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cblxuLyoqXG4gKiBDYWNoZXMgdGhlIHJlc3VsdHMgb2YgYW4gYXN5bmMgZnVuY3Rpb24uIFdoZW4gY3JlYXRpbmcgYSBoYXNoIHRvIHN0b3JlXG4gKiBmdW5jdGlvbiByZXN1bHRzIGFnYWluc3QsIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkIGZyb20gdGhlIGhhc2ggYW5kIGFuXG4gKiBvcHRpb25hbCBoYXNoIGZ1bmN0aW9uIGNhbiBiZSB1c2VkLlxuICpcbiAqICoqTm90ZTogaWYgdGhlIGFzeW5jIGZ1bmN0aW9uIGVycnMsIHRoZSByZXN1bHQgd2lsbCBub3QgYmUgY2FjaGVkIGFuZFxuICogc3Vic2VxdWVudCBjYWxscyB3aWxsIGNhbGwgdGhlIHdyYXBwZWQgZnVuY3Rpb24uKipcbiAqXG4gKiBJZiBubyBoYXNoIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoYXNoIGtleSxcbiAqIHdoaWNoIG1heSB3b3JrIHJlYXNvbmFibHkgaWYgaXQgaXMgYSBzdHJpbmcgb3IgYSBkYXRhIHR5cGUgdGhhdCBjb252ZXJ0cyB0byBhXG4gKiBkaXN0aW5jdCBzdHJpbmcuIE5vdGUgdGhhdCBvYmplY3RzIGFuZCBhcnJheXMgd2lsbCBub3QgYmVoYXZlIHJlYXNvbmFibHkuXG4gKiBOZWl0aGVyIHdpbGwgY2FzZXMgd2hlcmUgdGhlIG90aGVyIGFyZ3VtZW50cyBhcmUgc2lnbmlmaWNhbnQuIEluIHN1Y2ggY2FzZXMsXG4gKiBzcGVjaWZ5IHlvdXIgb3duIGhhc2ggZnVuY3Rpb24uXG4gKlxuICogVGhlIGNhY2hlIG9mIHJlc3VsdHMgaXMgZXhwb3NlZCBhcyB0aGUgYG1lbW9gIHByb3BlcnR5IG9mIHRoZSBmdW5jdGlvblxuICogcmV0dXJuZWQgYnkgYG1lbW9pemVgLlxuICpcbiAqIEBuYW1lIG1lbW9pemVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIHByb3h5IGFuZCBjYWNoZSByZXN1bHRzIGZyb20uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNoZXIgLSBBbiBvcHRpb25hbCBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBhIGN1c3RvbSBoYXNoXG4gKiBmb3Igc3RvcmluZyByZXN1bHRzLiBJdCBoYXMgYWxsIHRoZSBhcmd1bWVudHMgYXBwbGllZCB0byBpdCBhcGFydCBmcm9tIHRoZVxuICogY2FsbGJhY2ssIGFuZCBtdXN0IGJlIHN5bmNocm9ub3VzLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IGEgbWVtb2l6ZWQgdmVyc2lvbiBvZiBgZm5gXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBzbG93X2ZuID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmdcbiAqICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICogfTtcbiAqIHZhciBmbiA9IGFzeW5jLm1lbW9pemUoc2xvd19mbik7XG4gKlxuICogLy8gZm4gY2FuIG5vdyBiZSB1c2VkIGFzIGlmIGl0IHdlcmUgc2xvd19mblxuICogZm4oJ3NvbWUgbmFtZScsIGZ1bmN0aW9uKCkge1xuICogICAgIC8vIGNhbGxiYWNrXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmbiwgaGFzaGVyID0gdiA9PiB2KSB7XG4gICAgdmFyIG1lbW8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBxdWV1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHZhciBtZW1vaXplZCA9IGluaXRpYWxQYXJhbXMoKGFyZ3MsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHZhciBrZXkgPSBoYXNoZXIoLi4uYXJncyk7XG4gICAgICAgIGlmIChrZXkgaW4gbWVtbykge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoKCkgPT4gY2FsbGJhY2sobnVsbCwgLi4ubWVtb1trZXldKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xuICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZXNba2V5XSA9IFtjYWxsYmFja107XG4gICAgICAgICAgICBfZm4oLi4uYXJncywgKGVyciwgLi4ucmVzdWx0QXJncykgPT4ge1xuICAgICAgICAgICAgICAgIC8vICMxNDY1IGRvbid0IG1lbW9pemUgaWYgYW4gZXJyb3Igb2NjdXJyZWRcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSByZXN1bHRBcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHFbaV0oZXJyLCAuLi5yZXN1bHRBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vO1xuICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG5cbi8qKlxuICogQ2FsbHMgYGNhbGxiYWNrYCBvbiBhIGxhdGVyIGxvb3AgYXJvdW5kIHRoZSBldmVudCBsb29wLiBJbiBOb2RlLmpzIHRoaXMganVzdFxuICogY2FsbHMgYHByb2Nlc3MubmV4dFRpY2tgLiAgSW4gdGhlIGJyb3dzZXIgaXQgd2lsbCB1c2UgYHNldEltbWVkaWF0ZWAgaWZcbiAqIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKWAsIHdoaWNoIG1lYW5zIG90aGVyIGhpZ2hlclxuICogcHJpb3JpdHkgZXZlbnRzIG1heSBwcmVjZWRlIHRoZSBleGVjdXRpb24gb2YgYGNhbGxiYWNrYC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBmb3IgYnJvd3Nlci1jb21wYXRpYmlsaXR5IHB1cnBvc2VzLlxuICpcbiAqIEBuYW1lIG5leHRUaWNrXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zZXRJbW1lZGlhdGVde0BsaW5rIG1vZHVsZTpVdGlscy5zZXRJbW1lZGlhdGV9XG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBhIGxhdGVyIGxvb3AgYXJvdW5kXG4gKiB0aGUgZXZlbnQgbG9vcC4gSW52b2tlZCB3aXRoIChhcmdzLi4uKS5cbiAqIEBwYXJhbSB7Li4uKn0gYXJncy4uLiAtIGFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAqIGNhbGxiYWNrIG9uIHRoZSBuZXh0IHRpY2suXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBjYWxsX29yZGVyID0gW107XG4gKiBhc3luYy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAqICAgICBjYWxsX29yZGVyLnB1c2goJ3R3bycpO1xuICogICAgIC8vIGNhbGxfb3JkZXIgbm93IGVxdWFscyBbJ29uZScsJ3R3byddXG4gKiB9KTtcbiAqIGNhbGxfb3JkZXIucHVzaCgnb25lJyk7XG4gKlxuICogYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gKiAgICAgLy8gYSwgYiwgYW5kIGMgZXF1YWwgMSwgMiwgYW5kIDNcbiAqIH0sIDEsIDIsIDMpO1xuICovXG52YXIgX2RlZmVyO1xuXG5pZiAoaGFzTmV4dFRpY2spIHtcbiAgICBfZGVmZXIgPSBwcm9jZXNzLm5leHRUaWNrO1xufSBlbHNlIGlmIChoYXNTZXRJbW1lZGlhdGUpIHtcbiAgICBfZGVmZXIgPSBzZXRJbW1lZGlhdGU7XG59IGVsc2Uge1xuICAgIF9kZWZlciA9IGZhbGxiYWNrO1xufVxuXG52YXIgbmV4dFRpY2sgPSB3cmFwKF9kZWZlcik7XG5cbnZhciBfcGFyYWxsZWwgPSBhd2FpdGlmeSgoZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spID0+IHtcbiAgICB2YXIgcmVzdWx0cyA9IGlzQXJyYXlMaWtlKHRhc2tzKSA/IFtdIDoge307XG5cbiAgICBlYWNoZm4odGFza3MsICh0YXNrLCBrZXksIHRhc2tDYikgPT4ge1xuICAgICAgICB3cmFwQXN5bmModGFzaykoKGVyciwgLi4ucmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBbcmVzdWx0XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIHRhc2tDYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBlcnIgPT4gY2FsbGJhY2soZXJyLCByZXN1bHRzKSk7XG59LCAzKTtcblxuLyoqXG4gKiBSdW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgaW4gcGFyYWxsZWwsIHdpdGhvdXQgd2FpdGluZyB1bnRpbFxuICogdGhlIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIElmIGFueSBvZiB0aGUgZnVuY3Rpb25zIHBhc3MgYW4gZXJyb3IgdG9cbiAqIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlXG4gKiBlcnJvci4gT25jZSB0aGUgYHRhc2tzYCBoYXZlIGNvbXBsZXRlZCwgdGhlIHJlc3VsdHMgYXJlIHBhc3NlZCB0byB0aGUgZmluYWxcbiAqIGBjYWxsYmFja2AgYXMgYW4gYXJyYXkuXG4gKlxuICogKipOb3RlOioqIGBwYXJhbGxlbGAgaXMgYWJvdXQga2lja2luZy1vZmYgSS9PIHRhc2tzIGluIHBhcmFsbGVsLCBub3QgYWJvdXRcbiAqIHBhcmFsbGVsIGV4ZWN1dGlvbiBvZiBjb2RlLiAgSWYgeW91ciB0YXNrcyBkbyBub3QgdXNlIGFueSB0aW1lcnMgb3IgcGVyZm9ybVxuICogYW55IEkvTywgdGhleSB3aWxsIGFjdHVhbGx5IGJlIGV4ZWN1dGVkIGluIHNlcmllcy4gIEFueSBzeW5jaHJvbm91cyBzZXR1cFxuICogc2VjdGlvbnMgZm9yIGVhY2ggdGFzayB3aWxsIGhhcHBlbiBvbmUgYWZ0ZXIgdGhlIG90aGVyLiAgSmF2YVNjcmlwdCByZW1haW5zXG4gKiBzaW5nbGUtdGhyZWFkZWQuXG4gKlxuICogKipIaW50OioqIFVzZSBbYHJlZmxlY3RgXXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH0gdG8gY29udGludWUgdGhlXG4gKiBleGVjdXRpb24gb2Ygb3RoZXIgdGFza3Mgd2hlbiBhIHRhc2sgZmFpbHMuXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIEVhY2ggcHJvcGVydHkgd2lsbFxuICogYmUgcnVuIGFzIGEgZnVuY3Rpb24gYW5kIHRoZSByZXN1bHRzIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmaW5hbCBgY2FsbGJhY2tgXG4gKiBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gVGhpcyBjYW4gYmUgYSBtb3JlIHJlYWRhYmxlIHdheSBvZiBoYW5kbGluZ1xuICogcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5wYXJhbGxlbH0uXG4gKlxuICogQG5hbWUgcGFyYWxsZWxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIG9mXG4gKiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byBydW4uXG4gKiBFYWNoIGFzeW5jIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGVcbiAqIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhIHJlc3VsdHMgYXJyYXlcbiAqIChvciBvYmplY3QpIGNvbnRhaW5pbmcgYWxsIHRoZSByZXN1bHQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgdGFzayBjYWxsYmFja3MuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG5vdCBwYXNzZWRcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vVXNpbmcgQ2FsbGJhY2tzXG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0byBbJ29uZScsJ3R3byddIGV2ZW4gdGhvdWdoXG4gKiAgICAgLy8gdGhlIHNlY29uZCBmdW5jdGlvbiBoYWQgYSBzaG9ydGVyIHRpbWVvdXQuXG4gKiB9KTtcbiAqXG4gKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5XG4gKiBhc3luYy5wYXJhbGxlbCh7XG4gKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAqIH0pO1xuICpcbiAqIC8vVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLnBhcmFsbGVsKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdKS50aGVuKHJlc3VsdHMgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG8gWydvbmUnLCd0d28nXSBldmVuIHRob3VnaFxuICogICAgIC8vIHRoZSBzZWNvbmQgZnVuY3Rpb24gaGFkIGEgc2hvcnRlciB0aW1lb3V0LlxuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheVxuICogYXN5bmMucGFyYWxsZWwoe1xuICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfSkudGhlbihyZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLnBhcmFsbGVsKFtcbiAqICAgICAgICAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgXSk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvIFsnb25lJywndHdvJ10gZXZlbiB0aG91Z2hcbiAqICAgICAgICAgLy8gdGhlIHNlY29uZCBmdW5jdGlvbiBoYWQgYSBzaG9ydGVyIHRpbWVvdXQuXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheVxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMucGFyYWxsZWwoe1xuICogICAgICAgICAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICogICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAqICAgICAgICAgICAgfVxuICogICAgICAgICB9KTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG86IHsgb25lOiAxLCB0d286IDIgfVxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqL1xuZnVuY3Rpb24gcGFyYWxsZWwodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9wYXJhbGxlbChlYWNoT2YkMSwgdGFza3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHBhcmFsbGVsYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnBhcmFsbGVsfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgcGFyYWxsZWxMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucGFyYWxsZWxde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wYXJhbGxlbH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIG9mXG4gKiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byBydW4uXG4gKiBFYWNoIGFzeW5jIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGVcbiAqIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhIHJlc3VsdHMgYXJyYXlcbiAqIChvciBvYmplY3QpIGNvbnRhaW5pbmcgYWxsIHRoZSByZXN1bHQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgdGFzayBjYWxsYmFja3MuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG5vdCBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gcGFyYWxsZWxMaW1pdCh0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9wYXJhbGxlbChlYWNoT2ZMaW1pdCQyKGxpbWl0KSwgdGFza3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBBIHF1ZXVlIG9mIHRhc2tzIGZvciB0aGUgd29ya2VyIGZ1bmN0aW9uIHRvIGNvbXBsZXRlLlxuICogQHR5cGVkZWYge0l0ZXJhYmxlfSBRdWV1ZU9iamVjdFxuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGVuZ3RoIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5sZW5ndGgoKWAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0YXJ0ZWQgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhbnlcbiAqIGl0ZW1zIGhhdmUgYmVlbiBwdXNoZWQgYW5kIHByb2Nlc3NlZCBieSB0aGUgcXVldWUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBydW5uaW5nIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJ1bm5pbmcoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB3b3JrZXJzTGlzdCAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhcnJheSBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLndvcmtlcnNMaXN0KClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtc1xuICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2Ugd2l0aCBgcXVldWUuaWRsZSgpYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb25jdXJyZW5jeSAtIGFuIGludGVnZXIgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgXG4gKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgY2hhbmdlZCBhZnRlciBhXG4gKiBgcXVldWVgIGlzIGNyZWF0ZWQgdG8gYWx0ZXIgdGhlIGNvbmN1cnJlbmN5IG9uLXRoZS1mbHkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGF5bG9hZCAtIGFuIGludGVnZXIgdGhhdCBzcGVjaWZpZXMgaG93IG1hbnkgaXRlbXMgYXJlXG4gKiBwYXNzZWQgdG8gdGhlIHdvcmtlciBmdW5jdGlvbiBhdCBhIHRpbWUuIG9ubHkgYXBwbGllcyBpZiB0aGlzIGlzIGFcbiAqIFtjYXJnb117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmNhcmdvfSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7QXN5bmNGdW5jdGlvbn0gcHVzaCAtIGFkZCBhIG5ldyB0YXNrIHRvIHRoZSBgcXVldWVgLiBDYWxscyBgY2FsbGJhY2tgXG4gKiBvbmNlIHRoZSBgd29ya2VyYCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZyB0aGUgdGFzay4gSW5zdGVhZCBvZiBhIHNpbmdsZSB0YXNrLFxuICogYSBgdGFza3NgIGFycmF5IGNhbiBiZSBzdWJtaXR0ZWQuIFRoZSByZXNwZWN0aXZlIGNhbGxiYWNrIGlzIHVzZWQgZm9yIGV2ZXJ5XG4gKiB0YXNrIGluIHRoZSBsaXN0LiBJbnZva2Ugd2l0aCBgcXVldWUucHVzaCh0YXNrLCBbY2FsbGJhY2tdKWAsXG4gKiBAcHJvcGVydHkge0FzeW5jRnVuY3Rpb259IHVuc2hpZnQgLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgZnJvbnQgb2YgdGhlIGBxdWV1ZWAuXG4gKiBJbnZva2Ugd2l0aCBgcXVldWUudW5zaGlmdCh0YXNrLCBbY2FsbGJhY2tdKWAuXG4gKiBAcHJvcGVydHkge0FzeW5jRnVuY3Rpb259IHB1c2hBc3luYyAtIHRoZSBzYW1lIGFzIGBxLnB1c2hgLCBleGNlcHQgdGhpcyByZXR1cm5zXG4gKiBhIHByb21pc2UgdGhhdCByZWplY3RzIGlmIGFuIGVycm9yIG9jY3Vycy5cbiAqIEBwcm9wZXJ0eSB7QXN5bmNGdW5jdGlvbn0gdW5zaGlmdEFzeW5jIC0gdGhlIHNhbWUgYXMgYHEudW5zaGlmdGAsIGV4Y2VwdCB0aGlzIHJldHVybnNcbiAqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVtb3ZlIC0gcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHF1ZXVlIHRoYXQgbWF0Y2ggYSB0ZXN0XG4gKiBmdW5jdGlvbi4gIFRoZSB0ZXN0IGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIGFuIG9iamVjdCB3aXRoIGEgYGRhdGFgIHByb3BlcnR5LFxuICogYW5kIGEgYHByaW9yaXR5YCBwcm9wZXJ0eSwgaWYgdGhpcyBpcyBhXG4gKiBbcHJpb3JpdHlRdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnByaW9yaXR5UXVldWV9IG9iamVjdC5cbiAqIEludm9rZWQgd2l0aCBgcXVldWUucmVtb3ZlKHRlc3RGbilgLCB3aGVyZSBgdGVzdEZuYCBpcyBvZiB0aGUgZm9ybVxuICogYGZ1bmN0aW9uICh7ZGF0YSwgcHJpb3JpdHl9KSB7fWAgYW5kIHJldHVybnMgYSBCb29sZWFuLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2F0dXJhdGVkIC0gYSBmdW5jdGlvbiB0aGF0IHNldHMgYSBjYWxsYmFjayB0aGF0IGlzXG4gKiBjYWxsZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHJ1bm5pbmcgd29ya2VycyBoaXRzIHRoZSBgY29uY3VycmVuY3lgIGxpbWl0LCBhbmRcbiAqIGZ1cnRoZXIgdGFza3Mgd2lsbCBiZSBxdWV1ZWQuICBJZiB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCwgYHEuc2F0dXJhdGVkKClgXG4gKiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIG5leHQgb2NjdXJyZW5jZS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2F0dXJhdGVkIC0gYSBmdW5jdGlvbiB0aGF0IHNldHMgYSBjYWxsYmFjayB0aGF0IGlzXG4gKiBjYWxsZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHJ1bm5pbmcgd29ya2VycyBpcyBsZXNzIHRoYW4gdGhlIGBjb25jdXJyZW5jeWAgJlxuICogYGJ1ZmZlcmAgbGltaXRzLCBhbmQgZnVydGhlciB0YXNrcyB3aWxsIG5vdCBiZSBxdWV1ZWQuIElmIHRoZSBjYWxsYmFjayBpc1xuICogb21pdHRlZCwgYHEudW5zYXR1cmF0ZWQoKWAgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBuZXh0IG9jY3VycmVuY2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnVmZmVyIC0gQSBtaW5pbXVtIHRocmVzaG9sZCBidWZmZXIgaW4gb3JkZXIgdG8gc2F5IHRoYXRcbiAqIHRoZSBgcXVldWVgIGlzIGB1bnNhdHVyYXRlZGAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlbXB0eSAtIGEgZnVuY3Rpb24gdGhhdCBzZXRzIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWRcbiAqIHdoZW4gdGhlIGxhc3QgaXRlbSBmcm9tIHRoZSBgcXVldWVgIGlzIGdpdmVuIHRvIGEgYHdvcmtlcmAuIElmIHRoZSBjYWxsYmFja1xuICogaXMgb21pdHRlZCwgYHEuZW1wdHkoKWAgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBuZXh0IG9jY3VycmVuY2UuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkcmFpbiAtIGEgZnVuY3Rpb24gdGhhdCBzZXRzIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWRcbiAqIHdoZW4gdGhlIGxhc3QgaXRlbSBmcm9tIHRoZSBgcXVldWVgIGhhcyByZXR1cm5lZCBmcm9tIHRoZSBgd29ya2VyYC4gSWYgdGhlXG4gKiBjYWxsYmFjayBpcyBvbWl0dGVkLCBgcS5kcmFpbigpYCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIG5leHQgb2NjdXJyZW5jZS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVycm9yIC0gYSBmdW5jdGlvbiB0aGF0IHNldHMgYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZFxuICogd2hlbiBhIHRhc2sgZXJyb3JzLiBIYXMgdGhlIHNpZ25hdHVyZSBgZnVuY3Rpb24oZXJyb3IsIHRhc2spYC4gSWYgdGhlXG4gKiBjYWxsYmFjayBpcyBvbWl0dGVkLCBgZXJyb3IoKWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZWplY3RzIG9uIHRoZSBuZXh0XG4gKiBlcnJvci5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGF1c2VkIC0gYSBib29sZWFuIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBxdWV1ZSBpc1xuICogaW4gYSBwYXVzZWQgc3RhdGUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwYXVzZSAtIGEgZnVuY3Rpb24gdGhhdCBwYXVzZXMgdGhlIHByb2Nlc3Npbmcgb2YgdGFza3NcbiAqIHVudGlsIGByZXN1bWUoKWAgaXMgY2FsbGVkLiBJbnZva2Ugd2l0aCBgcXVldWUucGF1c2UoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZXN1bWUgLSBhIGZ1bmN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgcHJvY2Vzc2luZyBvZlxuICogcXVldWVkIHRhc2tzIHdoZW4gdGhlIHF1ZXVlIGlzIHBhdXNlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJlc3VtZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGtpbGwgLSBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgYGRyYWluYCBjYWxsYmFjayBhbmRcbiAqIGVtcHRpZXMgcmVtYWluaW5nIHRhc2tzIGZyb20gdGhlIHF1ZXVlIGZvcmNpbmcgaXQgdG8gZ28gaWRsZS4gTm8gbW9yZSB0YXNrc1xuICogc2hvdWxkIGJlIHB1c2hlZCB0byB0aGUgcXVldWUgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLiBJbnZva2Ugd2l0aCBgcXVldWUua2lsbCgpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcSA9IGFzeW5jLnF1ZXVlKHdvcmtlciwgMilcbiAqIHEucHVzaChpdGVtMSlcbiAqIHEucHVzaChpdGVtMilcbiAqIHEucHVzaChpdGVtMylcbiAqIC8vIHF1ZXVlcyBhcmUgaXRlcmFibGUsIHNwcmVhZCBpbnRvIGFuIGFycmF5IHRvIGluc3BlY3RcbiAqIGNvbnN0IGl0ZW1zID0gWy4uLnFdIC8vIFtpdGVtMSwgaXRlbTIsIGl0ZW0zXVxuICogLy8gb3IgdXNlIGZvciBvZlxuICogZm9yIChsZXQgaXRlbSBvZiBxKSB7XG4gKiAgICAgY29uc29sZS5sb2coaXRlbSlcbiAqIH1cbiAqXG4gKiBxLmRyYWluKCgpID0+IHtcbiAqICAgICBjb25zb2xlLmxvZygnYWxsIGRvbmUnKVxuICogfSlcbiAqIC8vIG9yXG4gKiBhd2FpdCBxLmRyYWluKClcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgcXVldWVgIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgYGNvbmN1cnJlbmN5YC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBgcXVldWVgIGFyZSBwcm9jZXNzZWQgaW4gcGFyYWxsZWwgKHVwIHRvIHRoZSBgY29uY3VycmVuY3lgIGxpbWl0KS4gSWYgYWxsXG4gKiBgd29ya2VyYHMgYXJlIGluIHByb2dyZXNzLCB0aGUgdGFzayBpcyBxdWV1ZWQgdW50aWwgb25lIGJlY29tZXMgYXZhaWxhYmxlLlxuICogT25jZSBhIGB3b3JrZXJgIGNvbXBsZXRlcyBhIGB0YXNrYCwgdGhhdCBgdGFza2AncyBjYWxsYmFjayBpcyBjYWxsZWQuXG4gKlxuICogQG5hbWUgcXVldWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gd29ya2VyIC0gQW4gYXN5bmMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZWQgdGFzay5cbiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhbiBpbmRpdmlkdWFsIHRhc2ssIHBhc3MgYSBjYWxsYmFjayB0b1xuICogYHEucHVzaCgpYC4gSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PTFdIC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueVxuICogYHdvcmtlcmAgZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuICBJZiBvbWl0dGVkLCB0aGUgY29uY3VycmVuY3lcbiAqIGRlZmF1bHRzIHRvIGAxYC4gIElmIHRoZSBjb25jdXJyZW5jeSBpcyBgMGAsIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgcXVldWUgb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW4gYmVcbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIHF1ZXVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBjcmVhdGUgYSBxdWV1ZSBvYmplY3Qgd2l0aCBjb25jdXJyZW5jeSAyXG4gKiB2YXIgcSA9IGFzeW5jLnF1ZXVlKGZ1bmN0aW9uKHRhc2ssIGNhbGxiYWNrKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrLm5hbWUpO1xuICogICAgIGNhbGxiYWNrKCk7XG4gKiB9LCAyKTtcbiAqXG4gKiAvLyBhc3NpZ24gYSBjYWxsYmFja1xuICogcS5kcmFpbihmdW5jdGlvbigpIHtcbiAqICAgICBjb25zb2xlLmxvZygnYWxsIGl0ZW1zIGhhdmUgYmVlbiBwcm9jZXNzZWQnKTtcbiAqIH0pO1xuICogLy8gb3IgYXdhaXQgdGhlIGVuZFxuICogYXdhaXQgcS5kcmFpbigpXG4gKlxuICogLy8gYXNzaWduIGFuIGVycm9yIGNhbGxiYWNrXG4gKiBxLmVycm9yKGZ1bmN0aW9uKGVyciwgdGFzaykge1xuICogICAgIGNvbnNvbGUuZXJyb3IoJ3Rhc2sgZXhwZXJpZW5jZWQgYW4gZXJyb3InKTtcbiAqIH0pO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBxdWV1ZVxuICogcS5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICogfSk7XG4gKiAvLyBjYWxsYmFjayBpcyBvcHRpb25hbFxuICogcS5wdXNoKHtuYW1lOiAnYmFyJ30pO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBxdWV1ZSAoYmF0Y2gtd2lzZSlcbiAqIHEucHVzaChbe25hbWU6ICdiYXonfSx7bmFtZTogJ2JheSd9LHtuYW1lOiAnYmF4J31dLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBpdGVtJyk7XG4gKiB9KTtcbiAqXG4gKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gKiBxLnVuc2hpZnQoe25hbWU6ICdiYXInfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHF1ZXVlICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgdmFyIF93b3JrZXIgPSB3cmFwQXN5bmMod29ya2VyKTtcbiAgICByZXR1cm4gcXVldWUkMSgoaXRlbXMsIGNiKSA9PiB7XG4gICAgICAgIF93b3JrZXIoaXRlbXNbMF0sIGNiKTtcbiAgICB9LCBjb25jdXJyZW5jeSwgMSk7XG59XG5cbi8vIEJpbmFyeSBtaW4taGVhcCBpbXBsZW1lbnRhdGlvbiB1c2VkIGZvciBwcmlvcml0eSBxdWV1ZS5cbi8vIEltcGxlbWVudGF0aW9uIGlzIHN0YWJsZSwgaS5lLiBwdXNoIHRpbWUgaXMgY29uc2lkZXJlZCBmb3IgZXF1YWwgcHJpb3JpdGllc1xuY2xhc3MgSGVhcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGVhcCA9IFtdO1xuICAgICAgICB0aGlzLnB1c2hDb3VudCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXAubGVuZ3RoO1xuICAgIH1cblxuICAgIGVtcHR5ICgpIHtcbiAgICAgICAgdGhpcy5oZWFwID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHBlcmNVcChpbmRleCkge1xuICAgICAgICBsZXQgcDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPiAwICYmIHNtYWxsZXIodGhpcy5oZWFwW2luZGV4XSwgdGhpcy5oZWFwW3A9cGFyZW50KGluZGV4KV0pKSB7XG4gICAgICAgICAgICBsZXQgdCA9IHRoaXMuaGVhcFtpbmRleF07XG4gICAgICAgICAgICB0aGlzLmhlYXBbaW5kZXhdID0gdGhpcy5oZWFwW3BdO1xuICAgICAgICAgICAgdGhpcy5oZWFwW3BdID0gdDtcblxuICAgICAgICAgICAgaW5kZXggPSBwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGVyY0Rvd24oaW5kZXgpIHtcbiAgICAgICAgbGV0IGw7XG5cbiAgICAgICAgd2hpbGUgKChsPWxlZnRDaGkoaW5kZXgpKSA8IHRoaXMuaGVhcC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChsKzEgPCB0aGlzLmhlYXAubGVuZ3RoICYmIHNtYWxsZXIodGhpcy5oZWFwW2wrMV0sIHRoaXMuaGVhcFtsXSkpIHtcbiAgICAgICAgICAgICAgICBsID0gbCsxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc21hbGxlcih0aGlzLmhlYXBbaW5kZXhdLCB0aGlzLmhlYXBbbF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB0ID0gdGhpcy5oZWFwW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuaGVhcFtpbmRleF0gPSB0aGlzLmhlYXBbbF07XG4gICAgICAgICAgICB0aGlzLmhlYXBbbF0gPSB0O1xuXG4gICAgICAgICAgICBpbmRleCA9IGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoKG5vZGUpIHtcbiAgICAgICAgbm9kZS5wdXNoQ291bnQgPSArK3RoaXMucHVzaENvdW50O1xuICAgICAgICB0aGlzLmhlYXAucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5wZXJjVXAodGhpcy5oZWFwLmxlbmd0aC0xKTtcbiAgICB9XG5cbiAgICB1bnNoaWZ0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhcC5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIHNoaWZ0KCkge1xuICAgICAgICBsZXQgW3RvcF0gPSB0aGlzLmhlYXA7XG5cbiAgICAgICAgdGhpcy5oZWFwWzBdID0gdGhpcy5oZWFwW3RoaXMuaGVhcC5sZW5ndGgtMV07XG4gICAgICAgIHRoaXMuaGVhcC5wb3AoKTtcbiAgICAgICAgdGhpcy5wZXJjRG93bigwKTtcblxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH1cblxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpc107XG4gICAgfVxuXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmhlYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuaGVhcFtpXS5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlICh0ZXN0Rm4pIHtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaGVhcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0ZXN0Rm4odGhpcy5oZWFwW2ldKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhcFtqXSA9IHRoaXMuaGVhcFtpXTtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhlYXAuc3BsaWNlKGopO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBwYXJlbnQodGhpcy5oZWFwLmxlbmd0aC0xKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMucGVyY0Rvd24oaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxlZnRDaGkoaSkge1xuICAgIHJldHVybiAoaTw8MSkrMTtcbn1cblxuZnVuY3Rpb24gcGFyZW50KGkpIHtcbiAgICByZXR1cm4gKChpKzEpPj4xKS0xO1xufVxuXG5mdW5jdGlvbiBzbWFsbGVyKHgsIHkpIHtcbiAgICBpZiAoeC5wcmlvcml0eSAhPT0geS5wcmlvcml0eSkge1xuICAgICAgICByZXR1cm4geC5wcmlvcml0eSA8IHkucHJpb3JpdHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geC5wdXNoQ291bnQgPCB5LnB1c2hDb3VudDtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IG9ubHkgdGFza3MgYXJlIGFzc2lnbmVkIGEgcHJpb3JpdHkgYW5kXG4gKiBjb21wbGV0ZWQgaW4gYXNjZW5kaW5nIHByaW9yaXR5IG9yZGVyLlxuICpcbiAqIEBuYW1lIHByaW9yaXR5UXVldWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIGEgcXVldWVkIHRhc2suXG4gKiBJZiB5b3Ugd2FudCB0byBoYW5kbGUgZXJyb3JzIGZyb20gYW4gaW5kaXZpZHVhbCB0YXNrLCBwYXNzIGEgY2FsbGJhY2sgdG9cbiAqIGBxLnB1c2goKWAuXG4gKiBJbnZva2VkIHdpdGggKHRhc2ssIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb25jdXJyZW5jeSAtIEFuIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnkgYHdvcmtlcmBcbiAqIGZ1bmN0aW9ucyBzaG91bGQgYmUgcnVuIGluIHBhcmFsbGVsLiAgSWYgb21pdHRlZCwgdGhlIGNvbmN1cnJlbmN5IGRlZmF1bHRzIHRvXG4gKiBgMWAuICBJZiB0aGUgY29uY3VycmVuY3kgaXMgYDBgLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcmV0dXJucyB7bW9kdWxlOkNvbnRyb2xGbG93LlF1ZXVlT2JqZWN0fSBBIHByaW9yaXR5UXVldWUgb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIFRoZXJlIGFyZSB0aHJlZVxuICogZGlmZmVyZW5jZXMgYmV0d2VlbiBgcXVldWVgIGFuZCBgcHJpb3JpdHlRdWV1ZWAgb2JqZWN0czpcbiAqICogYHB1c2godGFzaywgcHJpb3JpdHksIFtjYWxsYmFja10pYCAtIGBwcmlvcml0eWAgc2hvdWxkIGJlIGEgbnVtYmVyLiBJZiBhblxuICogICBhcnJheSBvZiBgdGFza3NgIGlzIGdpdmVuLCBhbGwgdGFza3Mgd2lsbCBiZSBhc3NpZ25lZCB0aGUgc2FtZSBwcmlvcml0eS5cbiAqICogYHB1c2hBc3luYyh0YXNrLCBwcmlvcml0eSwgW2NhbGxiYWNrXSlgIC0gdGhlIHNhbWUgYXMgYHByaW9yaXR5UXVldWUucHVzaGAsXG4gKiAgIGV4Y2VwdCB0aGlzIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVqZWN0cyBpZiBhbiBlcnJvciBvY2N1cnMuXG4gKiAqIFRoZSBgdW5zaGlmdGAgYW5kIGB1bnNoaWZ0QXN5bmNgIG1ldGhvZHMgd2VyZSByZW1vdmVkLlxuICovXG5mdW5jdGlvbiBwcmlvcml0eVF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAvLyBTdGFydCB3aXRoIGEgbm9ybWFsIHF1ZXVlXG4gICAgdmFyIHEgPSBxdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcblxuICAgIHZhciB7XG4gICAgICAgIHB1c2gsXG4gICAgICAgIHB1c2hBc3luY1xuICAgIH0gPSBxO1xuXG4gICAgcS5fdGFza3MgPSBuZXcgSGVhcCgpO1xuICAgIHEuX2NyZWF0ZVRhc2tJdGVtID0gKHtkYXRhLCBwcmlvcml0eX0sIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRhSXRlbXModGFza3MsIHByaW9yaXR5KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICAgIHJldHVybiB7ZGF0YTogdGFza3MsIHByaW9yaXR5fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFza3MubWFwKGRhdGEgPT4geyByZXR1cm4ge2RhdGEsIHByaW9yaXR5fTsgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgcHVzaCB0byBhY2NlcHQgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgcHJpb3JpdHlcbiAgICBxLnB1c2ggPSBmdW5jdGlvbihkYXRhLCBwcmlvcml0eSA9IDAsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBwdXNoKGNyZWF0ZURhdGFJdGVtcyhkYXRhLCBwcmlvcml0eSksIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgcS5wdXNoQXN5bmMgPSBmdW5jdGlvbihkYXRhLCBwcmlvcml0eSA9IDAsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBwdXNoQXN5bmMoY3JlYXRlRGF0YUl0ZW1zKGRhdGEsIHByaW9yaXR5KSwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvbnNcbiAgICBkZWxldGUgcS51bnNoaWZ0O1xuICAgIGRlbGV0ZSBxLnVuc2hpZnRBc3luYztcblxuICAgIHJldHVybiBxO1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIGB0YXNrc2AgYXJyYXkgb2YgZnVuY3Rpb25zIGluIHBhcmFsbGVsLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlXG4gKiBwcmV2aW91cyBmdW5jdGlvbiBoYXMgY29tcGxldGVkLiBPbmNlIGFueSBvZiB0aGUgYHRhc2tzYCBjb21wbGV0ZSBvciBwYXNzIGFuXG4gKiBlcnJvciB0byBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLiBJdCdzXG4gKiBlcXVpdmFsZW50IHRvIGBQcm9taXNlLnJhY2UoKWAuXG4gKlxuICogQG5hbWUgcmFjZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheX0gdGFza3MgLSBBbiBhcnJheSBjb250YWluaW5nIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259XG4gKiB0byBydW4uIEVhY2ggZnVuY3Rpb24gY2FuIGNvbXBsZXRlIHdpdGggYW4gb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYW55IG9mIHRoZSBmdW5jdGlvbnMgaGF2ZVxuICogY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYW4gZXJyb3Igb3IgcmVzdWx0IGZyb20gdGhlIGZpcnN0IGZ1bmN0aW9uIHRoYXRcbiAqIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMucmFjZShbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSxcbiAqIC8vIG1haW4gY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gdGhlIHJlc3VsdCB3aWxsIGJlIGVxdWFsIHRvICd0d28nIGFzIGl0IGZpbmlzaGVzIGVhcmxpZXJcbiAqIH0pO1xuICovXG5mdW5jdGlvbiByYWNlKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhc2tzKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHJhY2UgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKSk7XG4gICAgaWYgKCF0YXNrcy5sZW5ndGgpIHJldHVybiBjYWxsYmFjaygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGFza3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHdyYXBBc3luYyh0YXNrc1tpXSkoY2FsbGJhY2spO1xuICAgIH1cbn1cblxudmFyIHJhY2UkMSA9IGF3YWl0aWZ5KHJhY2UsIDIpO1xuXG4vKipcbiAqIFNhbWUgYXMgW2ByZWR1Y2VgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVkdWNlfSwgb25seSBvcGVyYXRlcyBvbiBgYXJyYXlgIGluIHJldmVyc2Ugb3JkZXIuXG4gKlxuICogQG5hbWUgcmVkdWNlUmlnaHRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnJlZHVjZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlZHVjZX1cbiAqIEBhbGlhcyBmb2xkclxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Kn0gbWVtbyAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggaXRlbSBpbiB0aGVcbiAqIGFycmF5IHRvIHByb2R1Y2UgdGhlIG5leHQgc3RlcCBpbiB0aGUgcmVkdWN0aW9uLlxuICogVGhlIGBpdGVyYXRlZWAgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIG5leHQgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi5cbiAqIElmIHRoZSBpdGVyYXRlZSBjb21wbGV0ZXMgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGVcbiAqIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBJbnZva2VkIHdpdGggKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHJlZHVjZWQgdmFsdWUuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiByZWR1Y2VSaWdodCAoYXJyYXksIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciByZXZlcnNlZCA9IFsuLi5hcnJheV0ucmV2ZXJzZSgpO1xuICAgIHJldHVybiByZWR1Y2UkMShyZXZlcnNlZCwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBXcmFwcyB0aGUgYXN5bmMgZnVuY3Rpb24gaW4gYW5vdGhlciBmdW5jdGlvbiB0aGF0IGFsd2F5cyBjb21wbGV0ZXMgd2l0aCBhXG4gKiByZXN1bHQgb2JqZWN0LCBldmVuIHdoZW4gaXQgZXJyb3JzLlxuICpcbiAqIFRoZSByZXN1bHQgb2JqZWN0IGhhcyBlaXRoZXIgdGhlIHByb3BlcnR5IGBlcnJvcmAgb3IgYHZhbHVlYC5cbiAqXG4gKiBAbmFtZSByZWZsZWN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIFRoZSBhc3luYyBmdW5jdGlvbiB5b3Ugd2FudCB0byB3cmFwXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQSBmdW5jdGlvbiB0aGF0IGFsd2F5cyBwYXNzZXMgbnVsbCB0byBpdCdzIGNhbGxiYWNrIGFzXG4gKiB0aGUgZXJyb3IuIFRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIGNhbGxiYWNrIHdpbGwgYmUgYW4gYG9iamVjdGAgd2l0aFxuICogZWl0aGVyIGFuIGBlcnJvcmAgb3IgYSBgdmFsdWVgIHByb3BlcnR5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgYXN5bmMucmVmbGVjdChmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBkbyBzb21lIHN0dWZmIC4uLlxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgfSksXG4gKiAgICAgYXN5bmMucmVmbGVjdChmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgYnV0IGVycm9yIC4uLlxuICogICAgICAgICBjYWxsYmFjaygnYmFkIHN0dWZmIGhhcHBlbmVkJyk7XG4gKiAgICAgfSksXG4gKiAgICAgYXN5bmMucmVmbGVjdChmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgLi4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICB9KVxuICogXSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB2YWx1ZXNcbiAqICAgICAvLyByZXN1bHRzWzBdLnZhbHVlID0gJ29uZSdcbiAqICAgICAvLyByZXN1bHRzWzFdLmVycm9yID0gJ2JhZCBzdHVmZiBoYXBwZW5lZCdcbiAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bydcbiAqIH0pO1xuICovXG5mdW5jdGlvbiByZWZsZWN0KGZuKSB7XG4gICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7XG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gcmVmbGVjdE9uKGFyZ3MsIHJlZmxlY3RDYWxsYmFjaykge1xuICAgICAgICBhcmdzLnB1c2goKGVycm9yLCAuLi5jYkFyZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCByZXRWYWwgPSB7fTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldFZhbC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNiQXJncy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjYkFyZ3M7XG4gICAgICAgICAgICAgICAgaWYgKGNiQXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBbdmFsdWVdID0gY2JBcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRWYWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZmxlY3RDYWxsYmFjayhudWxsLCByZXRWYWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYW4gYXJyYXkgb3IgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucyB3aXRoIGByZWZsZWN0YC5cbiAqXG4gKiBAbmFtZSByZWZsZWN0QWxsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWZsZWN0XXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH1cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxJdGVyYWJsZX0gdGFza3MgLSBUaGUgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gd3JhcCBpbiBgYXN5bmMucmVmbGVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgYXN5bmMgZnVuY3Rpb25zLCBlYWNoIHdyYXBwZWQgaW5cbiAqIGBhc3luYy5yZWZsZWN0YFxuICogQGV4YW1wbGVcbiAqXG4gKiBsZXQgdGFza3MgPSBbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiBidXQgZXJyb3IgLi4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJykpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdO1xuICpcbiAqIGFzeW5jLnBhcmFsbGVsKGFzeW5jLnJlZmxlY3RBbGwodGFza3MpLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHZhbHVlc1xuICogICAgIC8vIHJlc3VsdHNbMF0udmFsdWUgPSAnb25lJ1xuICogICAgIC8vIHJlc3VsdHNbMV0uZXJyb3IgPSBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJylcbiAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bydcbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGxldCB0YXNrcyA9IHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKCd0d28nKTtcbiAqICAgICB9LFxuICogICAgIHRocmVlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfTtcbiAqXG4gKiBhc3luYy5wYXJhbGxlbChhc3luYy5yZWZsZWN0QWxsKHRhc2tzKSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB2YWx1ZXNcbiAqICAgICAvLyByZXN1bHRzLm9uZS52YWx1ZSA9ICdvbmUnXG4gKiAgICAgLy8gcmVzdWx0cy50d28uZXJyb3IgPSAndHdvJ1xuICogICAgIC8vIHJlc3VsdHMudGhyZWUudmFsdWUgPSAndGhyZWUnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcmVmbGVjdEFsbCh0YXNrcykge1xuICAgIHZhciByZXN1bHRzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICByZXN1bHRzID0gdGFza3MubWFwKHJlZmxlY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGFza3MpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlZmxlY3QuY2FsbCh0aGlzLCB0YXNrc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiByZWplY3QkMihlYWNoZm4sIGFyciwgX2l0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGl0ZXJhdGVlID0gd3JhcEFzeW5jKF9pdGVyYXRlZSk7XG4gICAgcmV0dXJuIF9maWx0ZXIoZWFjaGZuLCBhcnIsICh2YWx1ZSwgY2IpID0+IHtcbiAgICAgICAgaXRlcmF0ZWUodmFsdWUsIChlcnIsIHYpID0+IHtcbiAgICAgICAgICAgIGNiKGVyciwgIXYpO1xuICAgICAgICB9KTtcbiAgICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIFtgZmlsdGVyYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0uIFJlbW92ZXMgdmFsdWVzIHRoYXQgcGFzcyBhbiBgYXN5bmNgIHRydXRoIHRlc3QuXG4gKlxuICogQG5hbWUgcmVqZWN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyBgcmVzdWx0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBkaXIxIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTEudHh0LCBmaWxlMi50eHRcbiAqIC8vIGRpcjIgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMy50eHQsIGZpbGU0LnR4dFxuICogLy8gZGlyMyBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGU1LnR4dFxuICpcbiAqIGNvbnN0IGZpbGVMaXN0ID0gWydkaXIxL2ZpbGUxLnR4dCcsJ2RpcjIvZmlsZTMudHh0JywnZGlyMy9maWxlNi50eHQnXTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBmaWxlIGV4aXN0c1xuICogZnVuY3Rpb24gZmlsZUV4aXN0cyhmaWxlLCBjYWxsYmFjaykge1xuICogICAgZnMuYWNjZXNzKGZpbGUsIGZzLmNvbnN0YW50cy5GX09LLCAoZXJyKSA9PiB7XG4gKiAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycik7XG4gKiAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLnJlamVjdChmaWxlTGlzdCwgZmlsZUV4aXN0cywgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAvLyBbICdkaXIzL2ZpbGU2LnR4dCcgXVxuICogICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIHRoZSBub24tZXhpc3RpbmcgZmlsZXNcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5yZWplY3QoZmlsZUxpc3QsIGZpbGVFeGlzdHMpXG4gKiAudGhlbiggcmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gWyAnZGlyMy9maWxlNi50eHQnIF1cbiAqICAgICAvLyByZXN1bHRzIG5vdyBlcXVhbHMgYW4gYXJyYXkgb2YgdGhlIG5vbi1leGlzdGluZyBmaWxlc1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5yZWplY3QoZmlsZUxpc3QsIGZpbGVFeGlzdHMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgLy8gWyAnZGlyMy9maWxlNi50eHQnIF1cbiAqICAgICAgICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIHRoZSBub24tZXhpc3RpbmcgZmlsZXNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIHJlamVjdCAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlamVjdCQyKGVhY2hPZiQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgcmVqZWN0JDEgPSBhd2FpdGlmeShyZWplY3QsIDMpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgcmVqZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIHJlamVjdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyBgcmVzdWx0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiByZWplY3RMaW1pdCAoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiByZWplY3QkMihlYWNoT2ZMaW1pdCQyKGxpbWl0KSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIHJlamVjdExpbWl0JDEgPSBhd2FpdGlmeShyZWplY3RMaW1pdCwgNCk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2ByZWplY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgcmVqZWN0U2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyBgcmVzdWx0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiByZWplY3RTZXJpZXMgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiByZWplY3QkMihlYWNoT2ZTZXJpZXMkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIHJlamVjdFNlcmllcyQxID0gYXdhaXRpZnkocmVqZWN0U2VyaWVzLCAzKTtcblxuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGdldCBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZnJvbSBgdGFza2Agbm8gbW9yZSB0aGFuIGB0aW1lc2AgdGltZXNcbiAqIGJlZm9yZSByZXR1cm5pbmcgYW4gZXJyb3IuIElmIHRoZSB0YXNrIGlzIHN1Y2Nlc3NmdWwsIHRoZSBgY2FsbGJhY2tgIHdpbGwgYmVcbiAqIHBhc3NlZCB0aGUgcmVzdWx0IG9mIHRoZSBzdWNjZXNzZnVsIHRhc2suIElmIGFsbCBhdHRlbXB0cyBmYWlsLCB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LlxuICpcbiAqIEBuYW1lIHJldHJ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAc2VlIFthc3luYy5yZXRyeWFibGVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeWFibGV9XG4gKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRzID0ge3RpbWVzOiA1LCBpbnRlcnZhbDogMH18IDVdIC0gQ2FuIGJlIGVpdGhlciBhblxuICogb2JqZWN0IHdpdGggYHRpbWVzYCBhbmQgYGludGVydmFsYCBvciBhIG51bWJlci5cbiAqICogYHRpbWVzYCAtIFRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gbWFrZSBiZWZvcmUgZ2l2aW5nIHVwLiAgVGhlIGRlZmF1bHRcbiAqICAgaXMgYDVgLlxuICogKiBgaW50ZXJ2YWxgIC0gVGhlIHRpbWUgdG8gd2FpdCBiZXR3ZWVuIHJldHJpZXMsIGluIG1pbGxpc2Vjb25kcy4gIFRoZVxuICogICBkZWZhdWx0IGlzIGAwYC4gVGhlIGludGVydmFsIG1heSBhbHNvIGJlIHNwZWNpZmllZCBhcyBhIGZ1bmN0aW9uIG9mIHRoZVxuICogICByZXRyeSBjb3VudCAoc2VlIGV4YW1wbGUpLlxuICogKiBgZXJyb3JGaWx0ZXJgIC0gQW4gb3B0aW9uYWwgc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIG9uXG4gKiAgIGVycm9uZW91cyByZXN1bHQuIElmIGl0IHJldHVybnMgYHRydWVgIHRoZSByZXRyeSBhdHRlbXB0cyB3aWxsIGNvbnRpbnVlO1xuICogICBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgIHRoZSByZXRyeSBmbG93IGlzIGFib3J0ZWQgd2l0aCB0aGUgY3VycmVudFxuICogICBhdHRlbXB0J3MgZXJyb3IgYW5kIHJlc3VsdCBiZWluZyByZXR1cm5lZCB0byB0aGUgZmluYWwgY2FsbGJhY2suXG4gKiAgIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqICogSWYgYG9wdHNgIGlzIGEgbnVtYmVyLCB0aGUgbnVtYmVyIHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5LFxuICogICB3aXRoIHRoZSBkZWZhdWx0IGludGVydmFsIG9mIGAwYC5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGFzayAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIHJldHJ5LlxuICogSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlXG4gKiB0YXNrIGhhcyBzdWNjZWVkZWQsIG9yIGFmdGVyIHRoZSBmaW5hbCBmYWlsZWQgYXR0ZW1wdC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgXG4gKiBhbmQgYHJlc3VsdGAgYXJndW1lbnRzIG9mIHRoZSBsYXN0IGF0dGVtcHQgYXQgY29tcGxldGluZyB0aGUgYHRhc2tgLiBJbnZva2VkXG4gKiB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gVGhlIGByZXRyeWAgZnVuY3Rpb24gY2FuIGJlIHVzZWQgYXMgYSBzdGFuZC1hbG9uZSBjb250cm9sIGZsb3cgYnkgcGFzc2luZ1xuICogLy8gYSBjYWxsYmFjaywgYXMgc2hvd24gYmVsb3c6XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXNcbiAqIGFzeW5jLnJldHJ5KDMsIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gKiB9KTtcbiAqXG4gKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMyB0aW1lcywgd2FpdGluZyAyMDAgbXMgYmV0d2VlbiBlYWNoIHJldHJ5XG4gKiBhc3luYy5yZXRyeSh7dGltZXM6IDMsIGludGVydmFsOiAyMDB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDEwIHRpbWVzIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICogLy8gKGkuZS4gaW50ZXJ2YWxzIG9mIDEwMCwgMjAwLCA0MDAsIDgwMCwgMTYwMCwgLi4uIG1pbGxpc2Vjb25kcylcbiAqIGFzeW5jLnJldHJ5KHtcbiAqICAgdGltZXM6IDEwLFxuICogICBpbnRlcnZhbDogZnVuY3Rpb24ocmV0cnlDb3VudCkge1xuICogICAgIHJldHVybiA1MCAqIE1hdGgucG93KDIsIHJldHJ5Q291bnQpO1xuICogICB9XG4gKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIHRoZSBkZWZhdWx0IDUgdGltZXMgbm8gZGVsYXkgYmV0d2VlbiBlYWNoIHJldHJ5XG4gKiBhc3luYy5yZXRyeShhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIG9ubHkgd2hlbiBlcnJvciBjb25kaXRpb24gc2F0aXNmaWVzLCBhbGwgb3RoZXJcbiAqIC8vIGVycm9ycyB3aWxsIGFib3J0IHRoZSByZXRyeSBjb250cm9sIGZsb3cgYW5kIHJldHVybiB0byBmaW5hbCBjYWxsYmFja1xuICogYXN5bmMucmV0cnkoe1xuICogICBlcnJvckZpbHRlcjogZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgcmV0dXJuIGVyci5tZXNzYWdlID09PSAnVGVtcG9yYXJ5IGVycm9yJzsgLy8gb25seSByZXRyeSBvbiBhIHNwZWNpZmljIGVycm9yXG4gKiAgIH1cbiAqIH0sIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gKiB9KTtcbiAqXG4gKiAvLyB0byByZXRyeSBpbmRpdmlkdWFsIG1ldGhvZHMgdGhhdCBhcmUgbm90IGFzIHJlbGlhYmxlIHdpdGhpbiBvdGhlclxuICogLy8gY29udHJvbCBmbG93IGZ1bmN0aW9ucywgdXNlIHRoZSBgcmV0cnlhYmxlYCB3cmFwcGVyOlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgdXNlcnM6IGFwaS5nZXRVc2Vycy5iaW5kKGFwaSksXG4gKiAgICAgcGF5bWVudHM6IGFzeW5jLnJldHJ5YWJsZSgzLCBhcGkuZ2V0UGF5bWVudHMuYmluZChhcGkpKVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdHNcbiAqIH0pO1xuICpcbiAqL1xuY29uc3QgREVGQVVMVF9USU1FUyA9IDU7XG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMDtcblxuZnVuY3Rpb24gcmV0cnkob3B0cywgdGFzaywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgdGltZXM6IERFRkFVTFRfVElNRVMsXG4gICAgICAgIGludGVydmFsRnVuYzogY29uc3RhbnQoREVGQVVMVF9JTlRFUlZBTClcbiAgICB9O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGFzayB8fCBwcm9taXNlQ2FsbGJhY2soKTtcbiAgICAgICAgdGFzayA9IG9wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VUaW1lcyhvcHRpb25zLCBvcHRzKTtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBwcm9taXNlQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhc2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5XCIpO1xuICAgIH1cblxuICAgIHZhciBfdGFzayA9IHdyYXBBc3luYyh0YXNrKTtcblxuICAgIHZhciBhdHRlbXB0ID0gMTtcbiAgICBmdW5jdGlvbiByZXRyeUF0dGVtcHQoKSB7XG4gICAgICAgIF90YXNrKChlcnIsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICAgIGlmIChlcnIgJiYgYXR0ZW1wdCsrIDwgb3B0aW9ucy50aW1lcyAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucy5lcnJvckZpbHRlciAhPSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JGaWx0ZXIoZXJyKSkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJldHJ5QXR0ZW1wdCwgb3B0aW9ucy5pbnRlcnZhbEZ1bmMoYXR0ZW1wdCAtIDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0cnlBdHRlbXB0KCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrW1BST01JU0VfU1lNQk9MXVxufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWVzKGFjYywgdCkge1xuICAgIGlmICh0eXBlb2YgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWNjLnRpbWVzID0gK3QudGltZXMgfHwgREVGQVVMVF9USU1FUztcblxuICAgICAgICBhY2MuaW50ZXJ2YWxGdW5jID0gdHlwZW9mIHQuaW50ZXJ2YWwgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgdC5pbnRlcnZhbCA6XG4gICAgICAgICAgICBjb25zdGFudCgrdC5pbnRlcnZhbCB8fCBERUZBVUxUX0lOVEVSVkFMKTtcblxuICAgICAgICBhY2MuZXJyb3JGaWx0ZXIgPSB0LmVycm9yRmlsdGVyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHQgPT09ICdudW1iZXInIHx8IHR5cGVvZiB0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBhY2MudGltZXMgPSArdCB8fCBERUZBVUxUX1RJTUVTO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeVwiKTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBjbG9zZSByZWxhdGl2ZSBvZiBbYHJldHJ5YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5fS4gIFRoaXMgbWV0aG9kXG4gKiB3cmFwcyBhIHRhc2sgYW5kIG1ha2VzIGl0IHJldHJ5YWJsZSwgcmF0aGVyIHRoYW4gaW1tZWRpYXRlbHkgY2FsbGluZyBpdFxuICogd2l0aCByZXRyaWVzLlxuICpcbiAqIEBuYW1lIHJldHJ5YWJsZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucmV0cnlde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeX1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcn0gW29wdHMgPSB7dGltZXM6IDUsIGludGVydmFsOiAwfXwgNV0gLSBvcHRpb25hbFxuICogb3B0aW9ucywgZXhhY3RseSB0aGUgc2FtZSBhcyBmcm9tIGByZXRyeWAsIGV4Y2VwdCBmb3IgYSBgb3B0cy5hcml0eWAgdGhhdFxuICogaXMgdGhlIGFyaXR5IG9mIHRoZSBgdGFza2AgZnVuY3Rpb24sIGRlZmF1bHRpbmcgdG8gYHRhc2subGVuZ3RoYFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0YXNrIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0byB3cmFwLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgd3JhcHBlci5cbiAqIEludm9rZWQgd2l0aCAoLi4uYXJncywgY2FsbGJhY2spLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLCB3aGljaCB3aGVuIGludm9rZWQsIHdpbGxcbiAqIHJldHJ5IG9uIGFuIGVycm9yLCBiYXNlZCBvbiB0aGUgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gYG9wdHNgLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFjY2VwdCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIGB0YXNrYC5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgZGVwMTogYXN5bmMucmV0cnlhYmxlKDMsIGdldEZyb21GbGFreVNlcnZpY2UpLFxuICogICAgIHByb2Nlc3M6IFtcImRlcDFcIiwgYXN5bmMucmV0cnlhYmxlKDMsIGZ1bmN0aW9uIChyZXN1bHRzLCBjYikge1xuICogICAgICAgICBtYXliZVByb2Nlc3NEYXRhKHJlc3VsdHMuZGVwMSwgY2IpO1xuICogICAgIH0pXVxuICogfSwgY2FsbGJhY2spO1xuICovXG5mdW5jdGlvbiByZXRyeWFibGUgKG9wdHMsIHRhc2spIHtcbiAgICBpZiAoIXRhc2spIHtcbiAgICAgICAgdGFzayA9IG9wdHM7XG4gICAgICAgIG9wdHMgPSBudWxsO1xuICAgIH1cbiAgICBsZXQgYXJpdHkgPSAob3B0cyAmJiBvcHRzLmFyaXR5KSB8fCB0YXNrLmxlbmd0aDtcbiAgICBpZiAoaXNBc3luYyh0YXNrKSkge1xuICAgICAgICBhcml0eSArPSAxO1xuICAgIH1cbiAgICB2YXIgX3Rhc2sgPSB3cmFwQXN5bmModGFzayk7XG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoKGFyZ3MsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IGFyaXR5IC0gMSB8fCBjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBwcm9taXNlQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0YXNrRm4oY2IpIHtcbiAgICAgICAgICAgIF90YXNrKC4uLmFyZ3MsIGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzKSByZXRyeShvcHRzLCB0YXNrRm4sIGNhbGxiYWNrKTtcbiAgICAgICAgZWxzZSByZXRyeSh0YXNrRm4sIGNhbGxiYWNrKTtcblxuICAgICAgICByZXR1cm4gY2FsbGJhY2tbUFJPTUlTRV9TWU1CT0xdXG4gICAgfSk7XG59XG5cbi8qKlxuICogUnVuIHRoZSBmdW5jdGlvbnMgaW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBpbiBzZXJpZXMsIGVhY2ggb25lIHJ1bm5pbmcgb25jZVxuICogdGhlIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIElmIGFueSBmdW5jdGlvbnMgaW4gdGhlIHNlcmllcyBwYXNzIGFuXG4gKiBlcnJvciB0byBpdHMgY2FsbGJhY2ssIG5vIG1vcmUgZnVuY3Rpb25zIGFyZSBydW4sIGFuZCBgY2FsbGJhY2tgIGlzXG4gKiBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGVycm9yLiBPdGhlcndpc2UsIGBjYWxsYmFja2BcbiAqIHJlY2VpdmVzIGFuIGFycmF5IG9mIHJlc3VsdHMgd2hlbiBgdGFza3NgIGhhdmUgY29tcGxldGVkLlxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gdXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBFYWNoIHByb3BlcnR5IHdpbGxcbiAqIGJlIHJ1biBhcyBhIGZ1bmN0aW9uLCBhbmQgdGhlIHJlc3VsdHMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZpbmFsIGBjYWxsYmFja2BcbiAqIGFzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBUaGlzIGNhbiBiZSBhIG1vcmUgcmVhZGFibGUgd2F5IG9mIGhhbmRsaW5nXG4gKiAgcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5zZXJpZXN9LlxuICpcbiAqICoqTm90ZSoqIHRoYXQgd2hpbGUgbWFueSBpbXBsZW1lbnRhdGlvbnMgcHJlc2VydmUgdGhlIG9yZGVyIG9mIG9iamVjdFxuICogcHJvcGVydGllcywgdGhlIFtFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb25dKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy04LjYpXG4gKiBleHBsaWNpdGx5IHN0YXRlcyB0aGF0XG4gKlxuICogPiBUaGUgbWVjaGFuaWNzIGFuZCBvcmRlciBvZiBlbnVtZXJhdGluZyB0aGUgcHJvcGVydGllcyBpcyBub3Qgc3BlY2lmaWVkLlxuICpcbiAqIFNvIGlmIHlvdSByZWx5IG9uIHRoZSBvcmRlciBpbiB3aGljaCB5b3VyIHNlcmllcyBvZiBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkLFxuICogYW5kIHdhbnQgdGhpcyB0byB3b3JrIG9uIGFsbCBwbGF0Zm9ybXMsIGNvbnNpZGVyIHVzaW5nIGFuIGFycmF5LlxuICpcbiAqIEBuYW1lIHNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZ1xuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuIGluIHNlcmllcy5cbiAqIEVhY2ggZnVuY3Rpb24gY2FuIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBvcHRpb25hbCBgcmVzdWx0YCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5IChvciBvYmplY3QpXG4gKiBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGB0YXNrYCBjYWxsYmFja3MuIEludm9rZWRcbiAqIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vVXNpbmcgQ2FsbGJhY2tzXG4gKiBhc3luYy5zZXJpZXMoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAvLyBkbyBzb21lIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAvLyB0aGVuIGRvIGFub3RoZXIgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIF0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG8gWydvbmUnLCd0d28nXVxuICogfSk7XG4gKlxuICogLy8gYW4gZXhhbXBsZSB1c2luZyBvYmplY3RzIGluc3RlYWQgb2YgYXJyYXlzXG4gKiBhc3luYy5zZXJpZXMoe1xuICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIC8vIGRvIHNvbWUgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAvLyB0aGVuIGRvIGFub3RoZXIgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0bzogeyBvbmU6IDEsIHR3bzogMiB9XG4gKiB9KTtcbiAqXG4gKiAvL1VzaW5nIFByb21pc2VzXG4gKiBhc3luYy5zZXJpZXMoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIF0pLnRoZW4ocmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0byBbJ29uZScsJ3R3byddXG4gKiB9KS5jYXRjaChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5XG4gKiBhc3luYy5zZXJpZXMoe1xuICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIC8vIGRvIHNvbWUgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAvLyB0aGVuIGRvIGFub3RoZXIgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfSkudGhlbihyZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLnNlcmllcyhbXG4gKiAgICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgIC8vIGRvIHNvbWUgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAqICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gZG8gYW5vdGhlciBhc3luYyB0YXNrXG4gKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICogICAgICAgICAgICAgfVxuICogICAgICAgICBdKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG8gWydvbmUnLCd0d28nXVxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLnBhcmFsbGVsKHtcbiAqICAgICAgICAgICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICAvLyBkbyBzb21lIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gKiAgICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAqICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGRvIGFub3RoZXIgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTtcbiAqICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICogICAgICAgICAgICB9XG4gKiAgICAgICAgIH0pO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0bzogeyBvbmU6IDEsIHR3bzogMiB9XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBzZXJpZXModGFza3MsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9wYXJhbGxlbChlYWNoT2ZTZXJpZXMkMSwgdGFza3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgYGNvbGxgIHNhdGlzZmllcyBhbiBhc3luYyB0ZXN0LlxuICogSWYgYW55IGl0ZXJhdGVlIGNhbGwgcmV0dXJucyBgdHJ1ZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHlcbiAqIGNhbGxlZC5cbiAqXG4gKiBAbmFtZSBzb21lXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgYW55XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gYHJlc3VsdGAgdmFsdWUuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jXG4gKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBkaXIxIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTEudHh0LCBmaWxlMi50eHRcbiAqIC8vIGRpcjIgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMy50eHQsIGZpbGU0LnR4dFxuICogLy8gZGlyMyBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGU1LnR4dFxuICogLy8gZGlyNCBkb2VzIG5vdCBleGlzdFxuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhIGZpbGUgZXhpc3RzXG4gKiBmdW5jdGlvbiBmaWxlRXhpc3RzKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICBmcy5hY2Nlc3MoZmlsZSwgZnMuY29uc3RhbnRzLkZfT0ssIChlcnIpID0+IHtcbiAqICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKTtcbiAqICAgIH0pO1xuICogfVxuICpcbiAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMuc29tZShbJ2RpcjEvbWlzc2luZy50eHQnLCdkaXIyL21pc3NpbmcudHh0JywnZGlyMy9maWxlNS50eHQnXSwgZmlsZUV4aXN0cyxcbiAqICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAvLyB0cnVlXG4gKiAgICAgICAgLy8gcmVzdWx0IGlzIHRydWUgc2luY2Ugc29tZSBmaWxlIGluIHRoZSBsaXN0IGV4aXN0c1xuICogICAgfVxuICopO1xuICpcbiAqIGFzeW5jLnNvbWUoWydkaXIxL21pc3NpbmcudHh0JywnZGlyMi9taXNzaW5nLnR4dCcsJ2RpcjQvbWlzc2luZy50eHQnXSwgZmlsZUV4aXN0cyxcbiAqICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAvLyBmYWxzZVxuICogICAgICAgIC8vIHJlc3VsdCBpcyBmYWxzZSBzaW5jZSBub25lIG9mIHRoZSBmaWxlcyBleGlzdHNcbiAqICAgIH1cbiAqKTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMuc29tZShbJ2RpcjEvbWlzc2luZy50eHQnLCdkaXIyL21pc3NpbmcudHh0JywnZGlyMy9maWxlNS50eHQnXSwgZmlsZUV4aXN0cylcbiAqIC50aGVuKCByZXN1bHQgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gdHJ1ZVxuICogICAgIC8vIHJlc3VsdCBpcyB0cnVlIHNpbmNlIHNvbWUgZmlsZSBpbiB0aGUgbGlzdCBleGlzdHNcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiBhc3luYy5zb21lKFsnZGlyMS9taXNzaW5nLnR4dCcsJ2RpcjIvbWlzc2luZy50eHQnLCdkaXI0L21pc3NpbmcudHh0J10sIGZpbGVFeGlzdHMpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIGZhbHNlXG4gKiAgICAgLy8gcmVzdWx0IGlzIGZhbHNlIHNpbmNlIG5vbmUgb2YgdGhlIGZpbGVzIGV4aXN0c1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLnNvbWUoWydkaXIxL21pc3NpbmcudHh0JywnZGlyMi9taXNzaW5nLnR4dCcsJ2RpcjMvZmlsZTUudHh0J10sIGZpbGVFeGlzdHMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyB0cnVlXG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyB0cnVlIHNpbmNlIHNvbWUgZmlsZSBpbiB0aGUgbGlzdCBleGlzdHNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLnNvbWUoWydkaXIxL21pc3NpbmcudHh0JywnZGlyMi9taXNzaW5nLnR4dCcsJ2RpcjQvbWlzc2luZy50eHQnXSwgZmlsZUV4aXN0cyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIGZhbHNlXG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyBmYWxzZSBzaW5jZSBub25lIG9mIHRoZSBmaWxlcyBleGlzdHNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIHNvbWUoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgcmVzID0+IHJlcykoZWFjaE9mJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBzb21lJDEgPSBhd2FpdGlmeShzb21lLCAzKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHNvbWVgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgc29tZUxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zb21lXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX1cbiAqIEBhbGlhcyBhbnlMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbnMgaW4gcGFyYWxsZWwuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luY1xuICogdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqL1xuZnVuY3Rpb24gc29tZUxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRlc3RlcihCb29sZWFuLCByZXMgPT4gcmVzKShlYWNoT2ZMaW1pdCQyKGxpbWl0KSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIHNvbWVMaW1pdCQxID0gYXdhaXRpZnkoc29tZUxpbWl0LCA0KTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHNvbWVgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIHNvbWVTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnNvbWVde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfVxuICogQGFsaWFzIGFueVNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbnMgaW4gc2VyaWVzLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIHNvbWVTZXJpZXMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgcmVzID0+IHJlcykoZWFjaE9mU2VyaWVzJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBzb21lU2VyaWVzJDEgPSBhd2FpdGlmeShzb21lU2VyaWVzLCAzKTtcblxuLyoqXG4gKiBTb3J0cyBhIGxpc3QgYnkgdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGBjb2xsYCB2YWx1ZSB0aHJvdWdoIGFuIGFzeW5jXG4gKiBgaXRlcmF0ZWVgLlxuICpcbiAqIEBuYW1lIHNvcnRCeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgdmFsdWUgdG8gdXNlIGFzIHRoZSBzb3J0IGNyaXRlcmlhIGFzXG4gKiBpdHMgYHJlc3VsdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIHRoZSBpdGVtc1xuICogZnJvbSB0aGUgb3JpZ2luYWwgYGNvbGxgIHNvcnRlZCBieSB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBgaXRlcmF0ZWVgXG4gKiBjYWxscy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGJpZ2ZpbGUudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDI1MTEwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBtZWRpdW1maWxlLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAxMTAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBzbWFsbGZpbGUudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDEyMSBieXRlcyBpbiBzaXplXG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZmlsZSBzaXplIGluIGJ5dGVzXG4gKiBmdW5jdGlvbiBnZXRGaWxlU2l6ZUluQnl0ZXMoZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5zdGF0KGZpbGUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCBzdGF0LnNpemUpO1xuICogICAgIH0pO1xuICogfVxuICpcbiAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMuc29ydEJ5KFsnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0JywnYmlnZmlsZS50eHQnXSwgZ2V0RmlsZVNpemVJbkJ5dGVzLFxuICogICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5XG4gKiAgICAgICAgICAgICAvLyBmaWxlIHNpemUgKGFzY2VuZGluZyBieSBkZWZhdWx0KSwgZS5nLlxuICogICAgICAgICAgICAgLy8gWyAnc21hbGxmaWxlLnR4dCcsICdtZWRpdW1maWxlLnR4dCcsICdiaWdmaWxlLnR4dCddXG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKiApO1xuICpcbiAqIC8vIEJ5IG1vZGlmeWluZyB0aGUgY2FsbGJhY2sgcGFyYW1ldGVyIHRoZVxuICogLy8gc29ydGluZyBvcmRlciBjYW4gYmUgaW5mbHVlbmNlZDpcbiAqXG4gKiAvLyBhc2NlbmRpbmcgb3JkZXJcbiAqIGFzeW5jLnNvcnRCeShbJ21lZGl1bWZpbGUudHh0Jywnc21hbGxmaWxlLnR4dCcsJ2JpZ2ZpbGUudHh0J10sIGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZ2V0RmlsZVNpemVJbkJ5dGVzKGZpbGUsIGZ1bmN0aW9uKGdldEZpbGVTaXplRXJyLCBmaWxlU2l6ZSkge1xuICogICAgICAgICBpZiAoZ2V0RmlsZVNpemVFcnIpIHJldHVybiBjYWxsYmFjayhnZXRGaWxlU2l6ZUVycik7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIGZpbGVTaXplKTtcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5XG4gKiAgICAgICAgICAgICAvLyBmaWxlIHNpemUgKGFzY2VuZGluZyBieSBkZWZhdWx0KSwgZS5nLlxuICogICAgICAgICAgICAgLy8gWyAnc21hbGxmaWxlLnR4dCcsICdtZWRpdW1maWxlLnR4dCcsICdiaWdmaWxlLnR4dCddXG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKiApO1xuICpcbiAqIC8vIGRlc2NlbmRpbmcgb3JkZXJcbiAqIGFzeW5jLnNvcnRCeShbJ2JpZ2ZpbGUudHh0JywnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0J10sIGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZ2V0RmlsZVNpemVJbkJ5dGVzKGZpbGUsIGZ1bmN0aW9uKGdldEZpbGVTaXplRXJyLCBmaWxlU2l6ZSkge1xuICogICAgICAgICBpZiAoZ2V0RmlsZVNpemVFcnIpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhnZXRGaWxlU2l6ZUVycik7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgZmlsZVNpemUgKiAtMSk7XG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAgICAgLy8gcmVzdWx0cyBpcyBub3cgdGhlIG9yaWdpbmFsIGFycmF5IG9mIGZpbGVzIHNvcnRlZCBieVxuICogICAgICAgICAgICAgLy8gZmlsZSBzaXplIChhc2NlbmRpbmcgYnkgZGVmYXVsdCksIGUuZy5cbiAqICAgICAgICAgICAgIC8vIFsgJ2JpZ2ZpbGUudHh0JywgJ21lZGl1bWZpbGUudHh0JywgJ3NtYWxsZmlsZS50eHQnXVxuICogICAgICAgICB9XG4gKiAgICAgfVxuICogKTtcbiAqXG4gKiAvLyBFcnJvciBoYW5kbGluZ1xuICogYXN5bmMuc29ydEJ5KFsnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0JywnbWlzc2luZ2ZpbGUudHh0J10sIGdldEZpbGVTaXplSW5CeXRlcyxcbiAqICAgICBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqICk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLnNvcnRCeShbJ21lZGl1bWZpbGUudHh0Jywnc21hbGxmaWxlLnR4dCcsJ2JpZ2ZpbGUudHh0J10sIGdldEZpbGVTaXplSW5CeXRlcylcbiAqIC50aGVuKCByZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5XG4gKiAgICAgLy8gZmlsZSBzaXplIChhc2NlbmRpbmcgYnkgZGVmYXVsdCksIGUuZy5cbiAqICAgICAvLyBbICdzbWFsbGZpbGUudHh0JywgJ21lZGl1bWZpbGUudHh0JywgJ2JpZ2ZpbGUudHh0J11cbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBoYW5kbGluZ1xuICogYXN5bmMuc29ydEJ5KFsnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0JywnbWlzc2luZ2ZpbGUudHh0J10sIGdldEZpbGVTaXplSW5CeXRlcylcbiAqIC50aGVuKCByZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiAoYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMuc29ydEJ5KFsnYmlnZmlsZS50eHQnLCdtZWRpdW1maWxlLnR4dCcsJ3NtYWxsZmlsZS50eHQnXSwgZ2V0RmlsZVNpemVJbkJ5dGVzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgbm93IHRoZSBvcmlnaW5hbCBhcnJheSBvZiBmaWxlcyBzb3J0ZWQgYnlcbiAqICAgICAgICAgLy8gZmlsZSBzaXplIChhc2NlbmRpbmcgYnkgZGVmYXVsdCksIGUuZy5cbiAqICAgICAgICAgLy8gWyAnc21hbGxmaWxlLnR4dCcsICdtZWRpdW1maWxlLnR4dCcsICdiaWdmaWxlLnR4dCddXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9KSgpO1xuICpcbiAqIC8vIEVycm9yIGhhbmRsaW5nXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5zb3J0QnkoWydtaXNzaW5nZmlsZS50eHQnLCdtZWRpdW1maWxlLnR4dCcsJ3NtYWxsZmlsZS50eHQnXSwgZ2V0RmlsZVNpemVJbkJ5dGVzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBzb3J0QnkgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHJldHVybiBtYXAkMShjb2xsLCAoeCwgaXRlckNiKSA9PiB7XG4gICAgICAgIF9pdGVyYXRlZSh4LCAoZXJyLCBjcml0ZXJpYSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGl0ZXJDYihlcnIpO1xuICAgICAgICAgICAgaXRlckNiKGVyciwge3ZhbHVlOiB4LCBjcml0ZXJpYX0pO1xuICAgICAgICB9KTtcbiAgICB9LCAoZXJyLCByZXN1bHRzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzLnNvcnQoY29tcGFyYXRvcikubWFwKHYgPT4gdi52YWx1ZSkpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIH1cbn1cbnZhciBzb3J0QnkkMSA9IGF3YWl0aWZ5KHNvcnRCeSwgMyk7XG5cbi8qKlxuICogU2V0cyBhIHRpbWUgbGltaXQgb24gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZG9lcyBub3QgY2FsbFxuICogaXRzIGNhbGxiYWNrIHdpdGhpbiB0aGUgc3BlY2lmaWVkIG1pbGxpc2Vjb25kcywgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhXG4gKiB0aW1lb3V0IGVycm9yLiBUaGUgY29kZSBwcm9wZXJ0eSBmb3IgdGhlIGVycm9yIG9iamVjdCB3aWxsIGJlIGAnRVRJTUVET1VUJ2AuXG4gKlxuICogQG5hbWUgdGltZW91dFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gYXN5bmNGbiAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBsaW1pdCBpbiB0aW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpc2Vjb25kcyAtIFRoZSBzcGVjaWZpZWQgdGltZSBsaW1pdC5cbiAqIEBwYXJhbSB7Kn0gW2luZm9dIC0gQW55IHZhcmlhYmxlIHlvdSB3YW50IGF0dGFjaGVkIChgc3RyaW5nYCwgYG9iamVjdGAsIGV0YylcbiAqIHRvIHRpbWVvdXQgRXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSB3cmFwcGVkIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBhbnlcbiAqIG9mIHRoZSBjb250cm9sIGZsb3cgZnVuY3Rpb25zLlxuICogSW52b2tlIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHlvdSB3b3VsZCBgYXN5bmNGdW5jYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gbXlGdW5jdGlvbihmb28sIGNhbGxiYWNrKSB7XG4gKiAgICAgZG9Bc3luY1Rhc2soZm9vLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAqICAgICAgICAgLy8gaGFuZGxlIGVycm9yc1xuICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqXG4gKiAgICAgICAgIC8vIGRvIHNvbWUgc3R1ZmYgLi4uXG4gKlxuICogICAgICAgICAvLyByZXR1cm4gcHJvY2Vzc2VkIGRhdGFcbiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICogICAgIH0pO1xuICogfVxuICpcbiAqIHZhciB3cmFwcGVkID0gYXN5bmMudGltZW91dChteUZ1bmN0aW9uLCAxMDAwKTtcbiAqXG4gKiAvLyBjYWxsIGB3cmFwcGVkYCBhcyB5b3Ugd291bGQgYG15RnVuY3Rpb25gXG4gKiB3cmFwcGVkKHsgYmFyOiAnYmFyJyB9LCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAqICAgICAvLyBpZiBgbXlGdW5jdGlvbmAgdGFrZXMgPCAxMDAwIG1zIHRvIGV4ZWN1dGUsIGBlcnJgXG4gKiAgICAgLy8gYW5kIGBkYXRhYCB3aWxsIGhhdmUgdGhlaXIgZXhwZWN0ZWQgdmFsdWVzXG4gKlxuICogICAgIC8vIGVsc2UgYGVycmAgd2lsbCBiZSBhbiBFcnJvciB3aXRoIHRoZSBjb2RlICdFVElNRURPVVQnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gdGltZW91dChhc3luY0ZuLCBtaWxsaXNlY29uZHMsIGluZm8pIHtcbiAgICB2YXIgZm4gPSB3cmFwQXN5bmMoYXN5bmNGbik7XG5cbiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcygoYXJncywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgdmFyIHRpbWVkT3V0ID0gZmFsc2U7XG4gICAgICAgIHZhciB0aW1lcjtcblxuICAgICAgICBmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGFzeW5jRm4ubmFtZSB8fCAnYW5vbnltb3VzJztcbiAgICAgICAgICAgIHZhciBlcnJvciAgPSBuZXcgRXJyb3IoJ0NhbGxiYWNrIGZ1bmN0aW9uIFwiJyArIG5hbWUgKyAnXCIgdGltZWQgb3V0LicpO1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdFVElNRURPVVQnO1xuICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0gaW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MucHVzaCgoLi4uY2JBcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soLi4uY2JBcmdzKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXR1cCB0aW1lciBhbmQgY2FsbCBvcmlnaW5hbCBmdW5jdGlvblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBtaWxsaXNlY29uZHMpO1xuICAgICAgICBmbiguLi5hcmdzKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmFuZ2Uoc2l6ZSkge1xuICAgIHZhciByZXN1bHQgPSBBcnJheShzaXplKTtcbiAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgIHJlc3VsdFtzaXplXSA9IHNpemU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW3RpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICogdGltZS5cbiAqXG4gKiBAbmFtZSB0aW1lc0xpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy50aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBjYWxsIGBuYCB0aW1lcy5cbiAqIEludm9rZWQgd2l0aCB0aGUgaXRlcmF0aW9uIGluZGV4IGFuZCBhIGNhbGxiYWNrOiAobiwgbmV4dCkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIHRpbWVzTGltaXQoY291bnQsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICByZXR1cm4gbWFwTGltaXQkMShyYW5nZShjb3VudCksIGxpbWl0LCBfaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBDYWxscyB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbiBgbmAgdGltZXMsIGFuZCBhY2N1bXVsYXRlcyByZXN1bHRzIGluIHRoZSBzYW1lXG4gKiBtYW5uZXIgeW91IHdvdWxkIHVzZSB3aXRoIFttYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICpcbiAqIEBuYW1lIHRpbWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gUHJldGVuZCB0aGlzIGlzIHNvbWUgY29tcGxpY2F0ZWQgYXN5bmMgZmFjdG9yeVxuICogdmFyIGNyZWF0ZVVzZXIgPSBmdW5jdGlvbihpZCwgY2FsbGJhY2spIHtcbiAqICAgICBjYWxsYmFjayhudWxsLCB7XG4gKiAgICAgICAgIGlkOiAndXNlcicgKyBpZFxuICogICAgIH0pO1xuICogfTtcbiAqXG4gKiAvLyBnZW5lcmF0ZSA1IHVzZXJzXG4gKiBhc3luYy50aW1lcyg1LCBmdW5jdGlvbihuLCBuZXh0KSB7XG4gKiAgICAgY3JlYXRlVXNlcihuLCBmdW5jdGlvbihlcnIsIHVzZXIpIHtcbiAqICAgICAgICAgbmV4dChlcnIsIHVzZXIpO1xuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCB1c2Vycykge1xuICogICAgIC8vIHdlIHNob3VsZCBub3cgaGF2ZSA1IHVzZXJzXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gdGltZXMgKG4sIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aW1lc0xpbWl0KG4sIEluZmluaXR5LCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW3RpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSB0aW1lc1Nlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMudGltZXNde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy50aW1lc31cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBjYWxsIGBuYCB0aW1lcy5cbiAqIEludm9rZWQgd2l0aCB0aGUgaXRlcmF0aW9uIGluZGV4IGFuZCBhIGNhbGxiYWNrOiAobiwgbmV4dCkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHNlZSB7QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZFxuICovXG5mdW5jdGlvbiB0aW1lc1NlcmllcyAobiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRpbWVzTGltaXQobiwgMSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIEEgcmVsYXRpdmUgb2YgYHJlZHVjZWAuICBUYWtlcyBhbiBPYmplY3Qgb3IgQXJyYXksIGFuZCBpdGVyYXRlcyBvdmVyIGVhY2hcbiAqIGVsZW1lbnQgaW4gcGFyYWxsZWwsIGVhY2ggc3RlcCBwb3RlbnRpYWxseSBtdXRhdGluZyBhbiBgYWNjdW11bGF0b3JgIHZhbHVlLlxuICogVGhlIHR5cGUgb2YgdGhlIGFjY3VtdWxhdG9yIGRlZmF1bHRzIHRvIHRoZSB0eXBlIG9mIGNvbGxlY3Rpb24gcGFzc2VkIGluLlxuICpcbiAqIEBuYW1lIHRyYW5zZm9ybVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHRyYW5zZm9ybS4gIElmIG9taXR0ZWQsXG4gKiBpdCB3aWxsIGRlZmF1bHQgdG8gYW4gZW1wdHkgT2JqZWN0IG9yIEFycmF5LCBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgYGNvbGxgXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggaXRlbSBpbiB0aGVcbiAqIGNvbGxlY3Rpb24gdGhhdCBwb3RlbnRpYWxseSBtb2RpZmllcyB0aGUgYWNjdW11bGF0b3IuXG4gKiBJbnZva2VkIHdpdGggKGFjY3VtdWxhdG9yLCBpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHRyYW5zZm9ybWVkIGFjY3VtdWxhdG9yLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBmaWxlMS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMi50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMjAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMy50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMzAwMCBieXRlcyBpbiBzaXplXG4gKlxuICogLy8gaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBodW1hbi1yZWFkYWJsZSBzaXplIGZvcm1hdCBmcm9tIGJ5dGVzXG4gKiBmdW5jdGlvbiBmb3JtYXRCeXRlcyhieXRlcywgZGVjaW1hbHMgPSAyKSB7XG4gKiAgIC8vIGltcGxlbWVudGF0aW9uIG5vdCBpbmNsdWRlZCBmb3IgYnJldml0eVxuICogICByZXR1cm4gaHVtYW5SZWFkYmxlRmlsZXNpemU7XG4gKiB9XG4gKlxuICogY29uc3QgZmlsZUxpc3QgPSBbJ2ZpbGUxLnR4dCcsJ2ZpbGUyLnR4dCcsJ2ZpbGUzLnR4dCddO1xuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZpbGUgc2l6ZSwgdHJhbnNmb3JtZWQgdG8gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gKiAvLyBlLmcuIDEwMjQgYnl0ZXMgPSAxS0IsIDEyMzQgYnl0ZXMgPSAxLjIxIEtCLCAxMDQ4NTc2IGJ5dGVzID0gMU1CLCBldGMuXG4gKiBmdW5jdGlvbiB0cmFuc2Zvcm1GaWxlU2l6ZShhY2MsIHZhbHVlLCBrZXksIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdCh2YWx1ZSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGFjY1trZXldID0gZm9ybWF0Qnl0ZXMoc3RhdC5zaXplKTtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy50cmFuc2Zvcm0oZmlsZUxpc3QsIHRyYW5zZm9ybUZpbGVTaXplLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGlmKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIFsgJzEwMDAgQnl0ZXMnLCAnMS45NSBLQicsICcyLjkzIEtCJyBdXG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLnRyYW5zZm9ybShmaWxlTGlzdCwgdHJhbnNmb3JtRmlsZVNpemUpXG4gKiAudGhlbihyZXN1bHQgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gWyAnMTAwMCBCeXRlcycsICcxLjk1IEtCJywgJzIuOTMgS0InIF1cbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiAoYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy50cmFuc2Zvcm0oZmlsZUxpc3QsIHRyYW5zZm9ybUZpbGVTaXplKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8gWyAnMTAwMCBCeXRlcycsICcxLjk1IEtCJywgJzIuOTMgS0InIF1cbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH0pKCk7XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBmaWxlMS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMi50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMjAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMy50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMzAwMCBieXRlcyBpbiBzaXplXG4gKlxuICogLy8gaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBodW1hbi1yZWFkYWJsZSBzaXplIGZvcm1hdCBmcm9tIGJ5dGVzXG4gKiBmdW5jdGlvbiBmb3JtYXRCeXRlcyhieXRlcywgZGVjaW1hbHMgPSAyKSB7XG4gKiAgIC8vIGltcGxlbWVudGF0aW9uIG5vdCBpbmNsdWRlZCBmb3IgYnJldml0eVxuICogICByZXR1cm4gaHVtYW5SZWFkYmxlRmlsZXNpemU7XG4gKiB9XG4gKlxuICogY29uc3QgZmlsZU1hcCA9IHsgZjE6ICdmaWxlMS50eHQnLCBmMjogJ2ZpbGUyLnR4dCcsIGYzOiAnZmlsZTMudHh0JyB9O1xuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZpbGUgc2l6ZSwgdHJhbnNmb3JtZWQgdG8gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gKiAvLyBlLmcuIDEwMjQgYnl0ZXMgPSAxS0IsIDEyMzQgYnl0ZXMgPSAxLjIxIEtCLCAxMDQ4NTc2IGJ5dGVzID0gMU1CLCBldGMuXG4gKiBmdW5jdGlvbiB0cmFuc2Zvcm1GaWxlU2l6ZShhY2MsIHZhbHVlLCBrZXksIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdCh2YWx1ZSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGFjY1trZXldID0gZm9ybWF0Qnl0ZXMoc3RhdC5zaXplKTtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy50cmFuc2Zvcm0oZmlsZU1hcCwgdHJhbnNmb3JtRmlsZVNpemUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgaWYoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8geyBmMTogJzEwMDAgQnl0ZXMnLCBmMjogJzEuOTUgS0InLCBmMzogJzIuOTMgS0InIH1cbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMudHJhbnNmb3JtKGZpbGVNYXAsIHRyYW5zZm9ybUZpbGVTaXplKVxuICogLnRoZW4ocmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIHsgZjE6ICcxMDAwIEJ5dGVzJywgZjI6ICcxLjk1IEtCJywgZjM6ICcyLjkzIEtCJyB9XG4gKiB9KS5jYXRjaChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy50cmFuc2Zvcm0oZmlsZU1hcCwgdHJhbnNmb3JtRmlsZVNpemUpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyB7IGYxOiAnMTAwMCBCeXRlcycsIGYyOiAnMS45NSBLQicsIGYzOiAnMi45MyBLQicgfVxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtIChjb2xsLCBhY2N1bXVsYXRvciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMyAmJiB0eXBlb2YgYWNjdW11bGF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBpdGVyYXRlZTtcbiAgICAgICAgaXRlcmF0ZWUgPSBhY2N1bXVsYXRvcjtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBBcnJheS5pc0FycmF5KGNvbGwpID8gW10gOiB7fTtcbiAgICB9XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IHByb21pc2VDYWxsYmFjaygpKTtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcblxuICAgIGVhY2hPZiQxKGNvbGwsICh2LCBrLCBjYikgPT4ge1xuICAgICAgICBfaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHYsIGssIGNiKTtcbiAgICB9LCBlcnIgPT4gY2FsbGJhY2soZXJyLCBhY2N1bXVsYXRvcikpO1xuICAgIHJldHVybiBjYWxsYmFja1tQUk9NSVNFX1NZTUJPTF1cbn1cblxuLyoqXG4gKiBJdCBydW5zIGVhY2ggdGFzayBpbiBzZXJpZXMgYnV0IHN0b3BzIHdoZW5ldmVyIGFueSBvZiB0aGUgZnVuY3Rpb25zIHdlcmVcbiAqIHN1Y2Nlc3NmdWwuIElmIG9uZSBvZiB0aGUgdGFza3Mgd2VyZSBzdWNjZXNzZnVsLCB0aGUgYGNhbGxiYWNrYCB3aWxsIGJlXG4gKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgdGFza3MgZmFpbCwgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHBhc3NlZCB0aGUgZXJyb3IgYW5kIHJlc3VsdCAoaWYgYW55KSBvZiB0aGUgZmluYWwgYXR0ZW1wdC5cbiAqXG4gKiBAbmFtZSB0cnlFYWNoXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBjb250YWluaW5nIGZ1bmN0aW9ucyB0b1xuICogcnVuLCBlYWNoIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGl0IG11c3QgY2FsbCBvblxuICogY29tcGxldGlvbiB3aXRoIGFuIGVycm9yIGBlcnJgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgYW4gb3B0aW9uYWwgYHJlc3VsdGBcbiAqIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIG9uZVxuICogb2YgdGhlIHRhc2tzIGhhcyBzdWNjZWVkZWQsIG9yIGFsbCBoYXZlIGZhaWxlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFuZFxuICogYHJlc3VsdGAgYXJndW1lbnRzIG9mIHRoZSBsYXN0IGF0dGVtcHQgYXQgY29tcGxldGluZyB0aGUgYHRhc2tgLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogYXN5bmMudHJ5RWFjaChbXG4gKiAgICAgZnVuY3Rpb24gZ2V0RGF0YUZyb21GaXJzdFdlYnNpdGUoY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgd2Vic2l0ZVxuICogICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24gZ2V0RGF0YUZyb21TZWNvbmRXZWJzaXRlKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIEZpcnN0IHdlYnNpdGUgZmFpbGVkLFxuICogICAgICAgICAvLyBUcnkgZ2V0dGluZyB0aGUgZGF0YSBmcm9tIHRoZSBiYWNrdXAgd2Vic2l0ZVxuICogICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICogICAgIH1cbiAqIF0sXG4gKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgTm93IGRvIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLlxuICogfSk7XG4gKlxuICovXG5mdW5jdGlvbiB0cnlFYWNoKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gZWFjaFNlcmllcyQxKHRhc2tzLCAodGFzaywgdGFza0NiKSA9PiB7XG4gICAgICAgIHdyYXBBc3luYyh0YXNrKSgoZXJyLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuIHRhc2tDYihlcnIpO1xuXG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgW3Jlc3VsdF0gPSBhcmdzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB0YXNrQ2IoZXJyID8gbnVsbCA6IHt9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgKCkgPT4gY2FsbGJhY2soZXJyb3IsIHJlc3VsdCkpO1xufVxuXG52YXIgdHJ5RWFjaCQxID0gYXdhaXRpZnkodHJ5RWFjaCk7XG5cbi8qKlxuICogVW5kb2VzIGEgW21lbW9pemVde0BsaW5rIG1vZHVsZTpVdGlscy5tZW1vaXplfWQgZnVuY3Rpb24sIHJldmVydGluZyBpdCB0byB0aGUgb3JpZ2luYWwsXG4gKiB1bm1lbW9pemVkIGZvcm0uIEhhbmR5IGZvciB0ZXN0aW5nLlxuICpcbiAqIEBuYW1lIHVubWVtb2l6ZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubWVtb2l6ZV17QGxpbmsgbW9kdWxlOlV0aWxzLm1lbW9pemV9XG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIHRoZSBtZW1vaXplZCBmdW5jdGlvblxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgb3JpZ2luYWwgdW5tZW1vaXplZCBmdW5jdGlvblxuICovXG5mdW5jdGlvbiB1bm1lbW9pemUoZm4pIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKSguLi5hcmdzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFJlcGVhdGVkbHkgY2FsbCBgaXRlcmF0ZWVgLCB3aGlsZSBgdGVzdGAgcmV0dXJucyBgdHJ1ZWAuIENhbGxzIGBjYWxsYmFja2Agd2hlblxuICogc3RvcHBlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLlxuICpcbiAqIEBuYW1lIHdoaWxzdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0ZXN0IC0gYXN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBiZWZvcmUgZWFjaFxuICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWVcbiAqIGB0ZXN0YCBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTtcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY291bnQgPSAwO1xuICogYXN5bmMud2hpbHN0KFxuICogICAgIGZ1bmN0aW9uIHRlc3QoY2IpIHsgY2IobnVsbCwgY291bnQgPCA1KTsgfSxcbiAqICAgICBmdW5jdGlvbiBpdGVyKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvdW50Kys7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBjb3VudCk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24gKGVyciwgbikge1xuICogICAgICAgICAvLyA1IHNlY29uZHMgaGF2ZSBwYXNzZWQsIG4gPSA1XG4gKiAgICAgfVxuICogKTtcbiAqL1xuZnVuY3Rpb24gd2hpbHN0KHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2spO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gbmV4dChlcnIsIC4uLnJlc3QpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJlc3VsdHMgPSByZXN0O1xuICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBfdGVzdChjaGVjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2soZXJyLCB0cnV0aCkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgaWYgKCF0cnV0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIC4uLnJlc3VsdHMpO1xuICAgICAgICBfZm4obmV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90ZXN0KGNoZWNrKTtcbn1cbnZhciB3aGlsc3QkMSA9IGF3YWl0aWZ5KHdoaWxzdCwgMyk7XG5cbi8qKlxuICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAgdW50aWwgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW5cbiAqIHN0b3BwZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55XG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suXG4gKlxuICogVGhlIGludmVyc2Ugb2YgW3doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0uXG4gKlxuICogQG5hbWUgdW50aWxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLndoaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGVzdCAtIGFzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lXG4gKiBgdGVzdGAgZmFpbHMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgcGFzc2VkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTtcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgbm90IHBhc3NlZFxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByZXN1bHRzID0gW11cbiAqIGxldCBmaW5pc2hlZCA9IGZhbHNlXG4gKiBhc3luYy51bnRpbChmdW5jdGlvbiB0ZXN0KGNiKSB7XG4gKiAgICAgY2IobnVsbCwgZmluaXNoZWQpXG4gKiB9LCBmdW5jdGlvbiBpdGVyKG5leHQpIHtcbiAqICAgICBmZXRjaFBhZ2UodXJsLCAoZXJyLCBib2R5KSA9PiB7XG4gKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycilcbiAqICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KGJvZHkub2JqZWN0cylcbiAqICAgICAgICAgZmluaXNoZWQgPSAhIWJvZHkubmV4dFxuICogICAgICAgICBuZXh0KGVycilcbiAqICAgICB9KVxuICogfSwgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gKiAgICAgLy8gYWxsIHBhZ2VzIGhhdmUgYmVlbiBmZXRjaGVkXG4gKiB9KVxuICovXG5mdW5jdGlvbiB1bnRpbCh0ZXN0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcbiAgICByZXR1cm4gd2hpbHN0JDEoKGNiKSA9PiBfdGVzdCgoZXJyLCB0cnV0aCkgPT4gY2IgKGVyciwgIXRydXRoKSksIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyB0aGUgYHRhc2tzYCBhcnJheSBvZiBmdW5jdGlvbnMgaW4gc2VyaWVzLCBlYWNoIHBhc3NpbmcgdGhlaXIgcmVzdWx0cyB0b1xuICogdGhlIG5leHQgaW4gdGhlIGFycmF5LiBIb3dldmVyLCBpZiBhbnkgb2YgdGhlIGB0YXNrc2AgcGFzcyBhbiBlcnJvciB0byB0aGVpclxuICogb3duIGNhbGxiYWNrLCB0aGUgbmV4dCBmdW5jdGlvbiBpcyBub3QgZXhlY3V0ZWQsIGFuZCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzXG4gKiBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gKlxuICogQG5hbWUgd2F0ZXJmYWxsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IG9mIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259XG4gKiB0byBydW4uXG4gKiBFYWNoIGZ1bmN0aW9uIHNob3VsZCBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2YgYHJlc3VsdGAgdmFsdWVzLlxuICogVGhlIGByZXN1bHRgIHZhbHVlcyB3aWxsIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMsIGluIG9yZGVyLCB0byB0aGUgbmV4dCB0YXNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGVcbiAqIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZC4gVGhpcyB3aWxsIGJlIHBhc3NlZCB0aGUgcmVzdWx0cyBvZiB0aGUgbGFzdCB0YXNrJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnLCAndHdvJyk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihhcmcxLCBhcmcyLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJ1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAndGhyZWUnKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGFyZzEsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGFyZzEgbm93IGVxdWFscyAndGhyZWUnXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkb25lJyk7XG4gKiAgICAgfVxuICogXSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgJ2RvbmUnXG4gKiB9KTtcbiAqXG4gKiAvLyBPciwgd2l0aCBuYW1lZCBmdW5jdGlvbnM6XG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIG15Rmlyc3RGdW5jdGlvbixcbiAqICAgICBteVNlY29uZEZ1bmN0aW9uLFxuICogICAgIG15TGFzdEZ1bmN0aW9uLFxuICogXSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgJ2RvbmUnXG4gKiB9KTtcbiAqIGZ1bmN0aW9uIG15Rmlyc3RGdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgIGNhbGxiYWNrKG51bGwsICdvbmUnLCAndHdvJyk7XG4gKiB9XG4gKiBmdW5jdGlvbiBteVNlY29uZEZ1bmN0aW9uKGFyZzEsIGFyZzIsIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gYXJnMSBub3cgZXF1YWxzICdvbmUnIGFuZCBhcmcyIG5vdyBlcXVhbHMgJ3R3bydcbiAqICAgICBjYWxsYmFjayhudWxsLCAndGhyZWUnKTtcbiAqIH1cbiAqIGZ1bmN0aW9uIG15TGFzdEZ1bmN0aW9uKGFyZzEsIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZSdcbiAqICAgICBjYWxsYmFjayhudWxsLCAnZG9uZScpO1xuICogfVxuICovXG5mdW5jdGlvbiB3YXRlcmZhbGwgKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhc2tzKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB2YXIgdGFza0luZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIG5leHRUYXNrKGFyZ3MpIHtcbiAgICAgICAgdmFyIHRhc2sgPSB3cmFwQXN5bmModGFza3NbdGFza0luZGV4KytdKTtcbiAgICAgICAgdGFzayguLi5hcmdzLCBvbmx5T25jZShuZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dChlcnIsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHJldHVyblxuICAgICAgICBpZiAoZXJyIHx8IHRhc2tJbmRleCA9PT0gdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0VGFzayhhcmdzKTtcbiAgICB9XG5cbiAgICBuZXh0VGFzayhbXSk7XG59XG5cbnZhciB3YXRlcmZhbGwkMSA9IGF3YWl0aWZ5KHdhdGVyZmFsbCk7XG5cbi8qKlxuICogQW4gXCJhc3luYyBmdW5jdGlvblwiIGluIHRoZSBjb250ZXh0IG9mIEFzeW5jIGlzIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB3aXRoXG4gKiBhIHZhcmlhYmxlIG51bWJlciBvZiBwYXJhbWV0ZXJzLCB3aXRoIHRoZSBmaW5hbCBwYXJhbWV0ZXIgYmVpbmcgYSBjYWxsYmFjay5cbiAqIChgZnVuY3Rpb24gKGFyZzEsIGFyZzIsIC4uLiwgY2FsbGJhY2spIHt9YClcbiAqIFRoZSBmaW5hbCBjYWxsYmFjayBpcyBvZiB0aGUgZm9ybSBgY2FsbGJhY2soZXJyLCByZXN1bHRzLi4uKWAsIHdoaWNoIG11c3QgYmVcbiAqIGNhbGxlZCBvbmNlIHRoZSBmdW5jdGlvbiBpcyBjb21wbGV0ZWQuICBUaGUgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGFcbiAqIEVycm9yIGFzIGl0cyBmaXJzdCBhcmd1bWVudCB0byBzaWduYWwgdGhhdCBhbiBlcnJvciBvY2N1cnJlZC5cbiAqIE90aGVyd2lzZSwgaWYgbm8gZXJyb3Igb2NjdXJyZWQsIGl0IHNob3VsZCBiZSBjYWxsZWQgd2l0aCBgbnVsbGAgYXMgdGhlIGZpcnN0XG4gKiBhcmd1bWVudCwgYW5kIGFueSBhZGRpdGlvbmFsIGByZXN1bHRgIGFyZ3VtZW50cyB0aGF0IG1heSBhcHBseSwgdG8gc2lnbmFsXG4gKiBzdWNjZXNzZnVsIGNvbXBsZXRpb24uXG4gKiBUaGUgY2FsbGJhY2sgbXVzdCBiZSBjYWxsZWQgZXhhY3RseSBvbmNlLCBpZGVhbGx5IG9uIGEgbGF0ZXIgdGljayBvZiB0aGVcbiAqIEphdmFTY3JpcHQgZXZlbnQgbG9vcC5cbiAqXG4gKiBUaGlzIHR5cGUgb2YgZnVuY3Rpb24gaXMgYWxzbyByZWZlcnJlZCB0byBhcyBhIFwiTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvblwiLFxuICogb3IgYSBcImNvbnRpbnVhdGlvbiBwYXNzaW5nLXN0eWxlIGZ1bmN0aW9uXCIgKENQUykuIE1vc3Qgb2YgdGhlIG1ldGhvZHMgb2YgdGhpc1xuICogbGlicmFyeSBhcmUgdGhlbXNlbHZlcyBDUFMvTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbnMsIG9yIGZ1bmN0aW9ucyB0aGF0XG4gKiByZXR1cm4gQ1BTL05vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb25zLlxuICpcbiAqIFdoZXJldmVyIHdlIGFjY2VwdCBhIE5vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb24sIHdlIGFsc28gZGlyZWN0bHkgYWNjZXB0IGFuXG4gKiBbRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1N0YXRlbWVudHMvYXN5bmNfZnVuY3Rpb259LlxuICogSW4gdGhpcyBjYXNlLCB0aGUgYGFzeW5jYCBmdW5jdGlvbiB3aWxsIG5vdCBiZSBwYXNzZWQgYSBmaW5hbCBjYWxsYmFja1xuICogYXJndW1lbnQsIGFuZCBhbnkgdGhyb3duIGVycm9yIHdpbGwgYmUgdXNlZCBhcyB0aGUgYGVycmAgYXJndW1lbnQgb2YgdGhlXG4gKiBpbXBsaWNpdCBjYWxsYmFjaywgYW5kIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBgcmVzdWx0YCB2YWx1ZS5cbiAqIChpLmUuIGEgYHJlamVjdGVkYCBvZiB0aGUgcmV0dXJuZWQgUHJvbWlzZSBiZWNvbWVzIHRoZSBgZXJyYCBjYWxsYmFja1xuICogYXJndW1lbnQsIGFuZCBhIGByZXNvbHZlZGAgdmFsdWUgYmVjb21lcyB0aGUgYHJlc3VsdGAuKVxuICpcbiAqIE5vdGUsIGR1ZSB0byBKYXZhU2NyaXB0IGxpbWl0YXRpb25zLCB3ZSBjYW4gb25seSBkZXRlY3QgbmF0aXZlIGBhc3luY2BcbiAqIGZ1bmN0aW9ucyBhbmQgbm90IHRyYW5zcGlsaWVkIGltcGxlbWVudGF0aW9ucy5cbiAqIFlvdXIgZW52aXJvbm1lbnQgbXVzdCBoYXZlIGBhc3luY2AvYGF3YWl0YCBzdXBwb3J0IGZvciB0aGlzIHRvIHdvcmsuXG4gKiAoZS5nLiBOb2RlID4gdjcuNiwgb3IgYSByZWNlbnQgdmVyc2lvbiBvZiBhIG1vZGVybiBicm93c2VyKS5cbiAqIElmIHlvdSBhcmUgdXNpbmcgYGFzeW5jYCBmdW5jdGlvbnMgdGhyb3VnaCBhIHRyYW5zcGlsZXIgKGUuZy4gQmFiZWwpLCB5b3VcbiAqIG11c3Qgc3RpbGwgd3JhcCB0aGUgZnVuY3Rpb24gd2l0aCBbYXN5bmNpZnlde0BsaW5rIG1vZHVsZTpVdGlscy5hc3luY2lmeX0sXG4gKiBiZWNhdXNlIHRoZSBgYXN5bmMgZnVuY3Rpb25gIHdpbGwgYmUgY29tcGlsZWQgdG8gYW4gb3JkaW5hcnkgZnVuY3Rpb24gdGhhdFxuICogcmV0dXJucyBhIHByb21pc2UuXG4gKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSBBc3luY0Z1bmN0aW9uXG4gKiBAc3RhdGljXG4gKi9cblxuXG52YXIgaW5kZXggPSB7XG4gICAgYXBwbHksXG4gICAgYXBwbHlFYWNoLFxuICAgIGFwcGx5RWFjaFNlcmllcyxcbiAgICBhc3luY2lmeSxcbiAgICBhdXRvLFxuICAgIGF1dG9JbmplY3QsXG4gICAgY2FyZ286IGNhcmdvJDEsXG4gICAgY2FyZ29RdWV1ZTogY2FyZ28sXG4gICAgY29tcG9zZSxcbiAgICBjb25jYXQ6IGNvbmNhdCQxLFxuICAgIGNvbmNhdExpbWl0OiBjb25jYXRMaW1pdCQxLFxuICAgIGNvbmNhdFNlcmllczogY29uY2F0U2VyaWVzJDEsXG4gICAgY29uc3RhbnQ6IGNvbnN0YW50JDEsXG4gICAgZGV0ZWN0OiBkZXRlY3QkMSxcbiAgICBkZXRlY3RMaW1pdDogZGV0ZWN0TGltaXQkMSxcbiAgICBkZXRlY3RTZXJpZXM6IGRldGVjdFNlcmllcyQxLFxuICAgIGRpcixcbiAgICBkb1VudGlsLFxuICAgIGRvV2hpbHN0OiBkb1doaWxzdCQxLFxuICAgIGVhY2gsXG4gICAgZWFjaExpbWl0OiBlYWNoTGltaXQkMSxcbiAgICBlYWNoT2Y6IGVhY2hPZiQxLFxuICAgIGVhY2hPZkxpbWl0OiBlYWNoT2ZMaW1pdCQxLFxuICAgIGVhY2hPZlNlcmllczogZWFjaE9mU2VyaWVzJDEsXG4gICAgZWFjaFNlcmllczogZWFjaFNlcmllcyQxLFxuICAgIGVuc3VyZUFzeW5jLFxuICAgIGV2ZXJ5OiBldmVyeSQxLFxuICAgIGV2ZXJ5TGltaXQ6IGV2ZXJ5TGltaXQkMSxcbiAgICBldmVyeVNlcmllczogZXZlcnlTZXJpZXMkMSxcbiAgICBmaWx0ZXI6IGZpbHRlciQxLFxuICAgIGZpbHRlckxpbWl0OiBmaWx0ZXJMaW1pdCQxLFxuICAgIGZpbHRlclNlcmllczogZmlsdGVyU2VyaWVzJDEsXG4gICAgZm9yZXZlcjogZm9yZXZlciQxLFxuICAgIGdyb3VwQnksXG4gICAgZ3JvdXBCeUxpbWl0OiBncm91cEJ5TGltaXQkMSxcbiAgICBncm91cEJ5U2VyaWVzLFxuICAgIGxvZyxcbiAgICBtYXA6IG1hcCQxLFxuICAgIG1hcExpbWl0OiBtYXBMaW1pdCQxLFxuICAgIG1hcFNlcmllczogbWFwU2VyaWVzJDEsXG4gICAgbWFwVmFsdWVzLFxuICAgIG1hcFZhbHVlc0xpbWl0OiBtYXBWYWx1ZXNMaW1pdCQxLFxuICAgIG1hcFZhbHVlc1NlcmllcyxcbiAgICBtZW1vaXplLFxuICAgIG5leHRUaWNrLFxuICAgIHBhcmFsbGVsLFxuICAgIHBhcmFsbGVsTGltaXQsXG4gICAgcHJpb3JpdHlRdWV1ZSxcbiAgICBxdWV1ZSxcbiAgICByYWNlOiByYWNlJDEsXG4gICAgcmVkdWNlOiByZWR1Y2UkMSxcbiAgICByZWR1Y2VSaWdodCxcbiAgICByZWZsZWN0LFxuICAgIHJlZmxlY3RBbGwsXG4gICAgcmVqZWN0OiByZWplY3QkMSxcbiAgICByZWplY3RMaW1pdDogcmVqZWN0TGltaXQkMSxcbiAgICByZWplY3RTZXJpZXM6IHJlamVjdFNlcmllcyQxLFxuICAgIHJldHJ5LFxuICAgIHJldHJ5YWJsZSxcbiAgICBzZXEsXG4gICAgc2VyaWVzLFxuICAgIHNldEltbWVkaWF0ZTogc2V0SW1tZWRpYXRlJDEsXG4gICAgc29tZTogc29tZSQxLFxuICAgIHNvbWVMaW1pdDogc29tZUxpbWl0JDEsXG4gICAgc29tZVNlcmllczogc29tZVNlcmllcyQxLFxuICAgIHNvcnRCeTogc29ydEJ5JDEsXG4gICAgdGltZW91dCxcbiAgICB0aW1lcyxcbiAgICB0aW1lc0xpbWl0LFxuICAgIHRpbWVzU2VyaWVzLFxuICAgIHRyYW5zZm9ybSxcbiAgICB0cnlFYWNoOiB0cnlFYWNoJDEsXG4gICAgdW5tZW1vaXplLFxuICAgIHVudGlsLFxuICAgIHdhdGVyZmFsbDogd2F0ZXJmYWxsJDEsXG4gICAgd2hpbHN0OiB3aGlsc3QkMSxcblxuICAgIC8vIGFsaWFzZXNcbiAgICBhbGw6IGV2ZXJ5JDEsXG4gICAgYWxsTGltaXQ6IGV2ZXJ5TGltaXQkMSxcbiAgICBhbGxTZXJpZXM6IGV2ZXJ5U2VyaWVzJDEsXG4gICAgYW55OiBzb21lJDEsXG4gICAgYW55TGltaXQ6IHNvbWVMaW1pdCQxLFxuICAgIGFueVNlcmllczogc29tZVNlcmllcyQxLFxuICAgIGZpbmQ6IGRldGVjdCQxLFxuICAgIGZpbmRMaW1pdDogZGV0ZWN0TGltaXQkMSxcbiAgICBmaW5kU2VyaWVzOiBkZXRlY3RTZXJpZXMkMSxcbiAgICBmbGF0TWFwOiBjb25jYXQkMSxcbiAgICBmbGF0TWFwTGltaXQ6IGNvbmNhdExpbWl0JDEsXG4gICAgZmxhdE1hcFNlcmllczogY29uY2F0U2VyaWVzJDEsXG4gICAgZm9yRWFjaDogZWFjaCxcbiAgICBmb3JFYWNoU2VyaWVzOiBlYWNoU2VyaWVzJDEsXG4gICAgZm9yRWFjaExpbWl0OiBlYWNoTGltaXQkMSxcbiAgICBmb3JFYWNoT2Y6IGVhY2hPZiQxLFxuICAgIGZvckVhY2hPZlNlcmllczogZWFjaE9mU2VyaWVzJDEsXG4gICAgZm9yRWFjaE9mTGltaXQ6IGVhY2hPZkxpbWl0JDEsXG4gICAgaW5qZWN0OiByZWR1Y2UkMSxcbiAgICBmb2xkbDogcmVkdWNlJDEsXG4gICAgZm9sZHI6IHJlZHVjZVJpZ2h0LFxuICAgIHNlbGVjdDogZmlsdGVyJDEsXG4gICAgc2VsZWN0TGltaXQ6IGZpbHRlckxpbWl0JDEsXG4gICAgc2VsZWN0U2VyaWVzOiBmaWx0ZXJTZXJpZXMkMSxcbiAgICB3cmFwU3luYzogYXN5bmNpZnksXG4gICAgZHVyaW5nOiB3aGlsc3QkMSxcbiAgICBkb0R1cmluZzogZG9XaGlsc3QkMVxufTtcblxuZXhwb3J0IHsgZXZlcnkkMSBhcyBhbGwsIGV2ZXJ5TGltaXQkMSBhcyBhbGxMaW1pdCwgZXZlcnlTZXJpZXMkMSBhcyBhbGxTZXJpZXMsIHNvbWUkMSBhcyBhbnksIHNvbWVMaW1pdCQxIGFzIGFueUxpbWl0LCBzb21lU2VyaWVzJDEgYXMgYW55U2VyaWVzLCBhcHBseSwgYXBwbHlFYWNoLCBhcHBseUVhY2hTZXJpZXMsIGFzeW5jaWZ5LCBhdXRvLCBhdXRvSW5qZWN0LCBjYXJnbyQxIGFzIGNhcmdvLCBjYXJnbyBhcyBjYXJnb1F1ZXVlLCBjb21wb3NlLCBjb25jYXQkMSBhcyBjb25jYXQsIGNvbmNhdExpbWl0JDEgYXMgY29uY2F0TGltaXQsIGNvbmNhdFNlcmllcyQxIGFzIGNvbmNhdFNlcmllcywgY29uc3RhbnQkMSBhcyBjb25zdGFudCwgaW5kZXggYXMgZGVmYXVsdCwgZGV0ZWN0JDEgYXMgZGV0ZWN0LCBkZXRlY3RMaW1pdCQxIGFzIGRldGVjdExpbWl0LCBkZXRlY3RTZXJpZXMkMSBhcyBkZXRlY3RTZXJpZXMsIGRpciwgZG9XaGlsc3QkMSBhcyBkb0R1cmluZywgZG9VbnRpbCwgZG9XaGlsc3QkMSBhcyBkb1doaWxzdCwgd2hpbHN0JDEgYXMgZHVyaW5nLCBlYWNoLCBlYWNoTGltaXQkMSBhcyBlYWNoTGltaXQsIGVhY2hPZiQxIGFzIGVhY2hPZiwgZWFjaE9mTGltaXQkMSBhcyBlYWNoT2ZMaW1pdCwgZWFjaE9mU2VyaWVzJDEgYXMgZWFjaE9mU2VyaWVzLCBlYWNoU2VyaWVzJDEgYXMgZWFjaFNlcmllcywgZW5zdXJlQXN5bmMsIGV2ZXJ5JDEgYXMgZXZlcnksIGV2ZXJ5TGltaXQkMSBhcyBldmVyeUxpbWl0LCBldmVyeVNlcmllcyQxIGFzIGV2ZXJ5U2VyaWVzLCBmaWx0ZXIkMSBhcyBmaWx0ZXIsIGZpbHRlckxpbWl0JDEgYXMgZmlsdGVyTGltaXQsIGZpbHRlclNlcmllcyQxIGFzIGZpbHRlclNlcmllcywgZGV0ZWN0JDEgYXMgZmluZCwgZGV0ZWN0TGltaXQkMSBhcyBmaW5kTGltaXQsIGRldGVjdFNlcmllcyQxIGFzIGZpbmRTZXJpZXMsIGNvbmNhdCQxIGFzIGZsYXRNYXAsIGNvbmNhdExpbWl0JDEgYXMgZmxhdE1hcExpbWl0LCBjb25jYXRTZXJpZXMkMSBhcyBmbGF0TWFwU2VyaWVzLCByZWR1Y2UkMSBhcyBmb2xkbCwgcmVkdWNlUmlnaHQgYXMgZm9sZHIsIGVhY2ggYXMgZm9yRWFjaCwgZWFjaExpbWl0JDEgYXMgZm9yRWFjaExpbWl0LCBlYWNoT2YkMSBhcyBmb3JFYWNoT2YsIGVhY2hPZkxpbWl0JDEgYXMgZm9yRWFjaE9mTGltaXQsIGVhY2hPZlNlcmllcyQxIGFzIGZvckVhY2hPZlNlcmllcywgZWFjaFNlcmllcyQxIGFzIGZvckVhY2hTZXJpZXMsIGZvcmV2ZXIkMSBhcyBmb3JldmVyLCBncm91cEJ5LCBncm91cEJ5TGltaXQkMSBhcyBncm91cEJ5TGltaXQsIGdyb3VwQnlTZXJpZXMsIHJlZHVjZSQxIGFzIGluamVjdCwgbG9nLCBtYXAkMSBhcyBtYXAsIG1hcExpbWl0JDEgYXMgbWFwTGltaXQsIG1hcFNlcmllcyQxIGFzIG1hcFNlcmllcywgbWFwVmFsdWVzLCBtYXBWYWx1ZXNMaW1pdCQxIGFzIG1hcFZhbHVlc0xpbWl0LCBtYXBWYWx1ZXNTZXJpZXMsIG1lbW9pemUsIG5leHRUaWNrLCBwYXJhbGxlbCwgcGFyYWxsZWxMaW1pdCwgcHJpb3JpdHlRdWV1ZSwgcXVldWUsIHJhY2UkMSBhcyByYWNlLCByZWR1Y2UkMSBhcyByZWR1Y2UsIHJlZHVjZVJpZ2h0LCByZWZsZWN0LCByZWZsZWN0QWxsLCByZWplY3QkMSBhcyByZWplY3QsIHJlamVjdExpbWl0JDEgYXMgcmVqZWN0TGltaXQsIHJlamVjdFNlcmllcyQxIGFzIHJlamVjdFNlcmllcywgcmV0cnksIHJldHJ5YWJsZSwgZmlsdGVyJDEgYXMgc2VsZWN0LCBmaWx0ZXJMaW1pdCQxIGFzIHNlbGVjdExpbWl0LCBmaWx0ZXJTZXJpZXMkMSBhcyBzZWxlY3RTZXJpZXMsIHNlcSwgc2VyaWVzLCBzZXRJbW1lZGlhdGUkMSBhcyBzZXRJbW1lZGlhdGUsIHNvbWUkMSBhcyBzb21lLCBzb21lTGltaXQkMSBhcyBzb21lTGltaXQsIHNvbWVTZXJpZXMkMSBhcyBzb21lU2VyaWVzLCBzb3J0QnkkMSBhcyBzb3J0QnksIHRpbWVvdXQsIHRpbWVzLCB0aW1lc0xpbWl0LCB0aW1lc1NlcmllcywgdHJhbnNmb3JtLCB0cnlFYWNoJDEgYXMgdHJ5RWFjaCwgdW5tZW1vaXplLCB1bnRpbCwgd2F0ZXJmYWxsJDEgYXMgd2F0ZXJmYWxsLCB3aGlsc3QkMSBhcyB3aGlsc3QsIGFzeW5jaWZ5IGFzIHdyYXBTeW5jIH07XG4iXSwibmFtZXMiOlsiYXBwbHkiLCJmbiIsImFyZ3MiLCJjYWxsQXJncyIsImluaXRpYWxQYXJhbXMiLCJjYWxsYmFjayIsInBvcCIsImNhbGwiLCJoYXNRdWV1ZU1pY3JvdGFzayIsInF1ZXVlTWljcm90YXNrIiwiaGFzU2V0SW1tZWRpYXRlIiwic2V0SW1tZWRpYXRlIiwiaGFzTmV4dFRpY2siLCJwcm9jZXNzIiwibmV4dFRpY2siLCJmYWxsYmFjayIsInNldFRpbWVvdXQiLCJ3cmFwIiwiZGVmZXIiLCJfZGVmZXIkMSIsInNldEltbWVkaWF0ZSQxIiwiYXN5bmNpZnkiLCJmdW5jIiwiaXNBc3luYyIsInByb21pc2UiLCJoYW5kbGVQcm9taXNlIiwicmVzdWx0IiwiZSIsInRoZW4iLCJ2YWx1ZSIsImludm9rZUNhbGxiYWNrIiwiZXJyIiwiRXJyb3IiLCJtZXNzYWdlIiwiZXJyb3IiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImlzQXN5bmNHZW5lcmF0b3IiLCJpc0FzeW5jSXRlcmFibGUiLCJvYmoiLCJhc3luY0l0ZXJhdG9yIiwid3JhcEFzeW5jIiwiYXN5bmNGbiIsImF3YWl0aWZ5IiwiYXJpdHkiLCJsZW5ndGgiLCJhd2FpdGFibGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNiQXJncyIsImFwcGx5RWFjaCQxIiwiZWFjaGZuIiwiYXBwbHlFYWNoIiwiZm5zIiwiZ28iLCJ0aGF0IiwiY2IiLCJjb25jYXQiLCJfYXN5bmNNYXAiLCJhcnIiLCJpdGVyYXRlZSIsInJlc3VsdHMiLCJjb3VudGVyIiwiX2l0ZXJhdGVlIiwiXyIsIml0ZXJDYiIsImluZGV4IiwidiIsImlzQXJyYXlMaWtlIiwiYnJlYWtMb29wIiwiYnJlYWtMb29wJDEiLCJvbmNlIiwid3JhcHBlciIsImNhbGxGbiIsIk9iamVjdCIsImFzc2lnbiIsImdldEl0ZXJhdG9yIiwiY29sbCIsIml0ZXJhdG9yIiwiY3JlYXRlQXJyYXlJdGVyYXRvciIsImkiLCJsZW4iLCJuZXh0Iiwia2V5IiwiY3JlYXRlRVMyMDE1SXRlcmF0b3IiLCJpdGVtIiwiZG9uZSIsImNyZWF0ZU9iamVjdEl0ZXJhdG9yIiwib2tleXMiLCJrZXlzIiwiY3JlYXRlSXRlcmF0b3IiLCJvbmx5T25jZSIsImFzeW5jRWFjaE9mTGltaXQiLCJnZW5lcmF0b3IiLCJsaW1pdCIsImNhbmNlbGVkIiwiYXdhaXRpbmciLCJydW5uaW5nIiwiaWR4IiwicmVwbGVuaXNoIiwiaXRlckRvbmUiLCJpdGVyYXRlZUNhbGxiYWNrIiwiY2F0Y2giLCJoYW5kbGVFcnJvciIsImVhY2hPZkxpbWl0JDIiLCJSYW5nZUVycm9yIiwibmV4dEVsZW0iLCJsb29waW5nIiwiZWxlbSIsImVhY2hPZkxpbWl0IiwiZWFjaE9mTGltaXQkMSIsImVhY2hPZkFycmF5TGlrZSIsImNvbXBsZXRlZCIsIml0ZXJhdG9yQ2FsbGJhY2siLCJlYWNoT2ZHZW5lcmljIiwiSW5maW5pdHkiLCJlYWNoT2YiLCJlYWNoT2ZJbXBsZW1lbnRhdGlvbiIsImVhY2hPZiQxIiwibWFwIiwibWFwJDEiLCJlYWNoT2ZTZXJpZXMiLCJlYWNoT2ZTZXJpZXMkMSIsIm1hcFNlcmllcyIsIm1hcFNlcmllcyQxIiwiYXBwbHlFYWNoU2VyaWVzIiwiUFJPTUlTRV9TWU1CT0wiLCJwcm9taXNlQ2FsbGJhY2siLCJyZXMiLCJyZWoiLCJhdXRvIiwidGFza3MiLCJjb25jdXJyZW5jeSIsIm51bVRhc2tzIiwicnVubmluZ1Rhc2tzIiwiaGFzRXJyb3IiLCJsaXN0ZW5lcnMiLCJjcmVhdGUiLCJyZWFkeVRhc2tzIiwicmVhZHlUb0NoZWNrIiwidW5jaGVja2VkRGVwZW5kZW5jaWVzIiwiZm9yRWFjaCIsInRhc2siLCJBcnJheSIsImlzQXJyYXkiLCJlbnF1ZXVlVGFzayIsInB1c2giLCJkZXBlbmRlbmNpZXMiLCJzbGljZSIsInJlbWFpbmluZ0RlcGVuZGVuY2llcyIsImRlcGVuZGVuY3lOYW1lIiwiam9pbiIsImFkZExpc3RlbmVyIiwiY2hlY2tGb3JEZWFkbG9ja3MiLCJwcm9jZXNzUXVldWUiLCJydW5UYXNrIiwicnVuIiwic2hpZnQiLCJ0YXNrTmFtZSIsInRhc2tMaXN0ZW5lcnMiLCJ0YXNrQ29tcGxldGUiLCJ0YXNrQ2FsbGJhY2siLCJzYWZlUmVzdWx0cyIsInJrZXkiLCJ0YXNrRm4iLCJjdXJyZW50VGFzayIsImdldERlcGVuZGVudHMiLCJkZXBlbmRlbnQiLCJpbmRleE9mIiwiRk5fQVJHUyIsIkFSUk9XX0ZOX0FSR1MiLCJGTl9BUkdfU1BMSVQiLCJGTl9BUkciLCJzdHJpcENvbW1lbnRzIiwic3RyaW5nIiwic3RyaXBwZWQiLCJlbmRCbG9ja0NvbW1lbnQiLCJlbmRJbmRleCIsInBhcnNlUGFyYW1zIiwic3JjIiwidG9TdHJpbmciLCJtYXRjaCIsInJlcGxhY2UiLCJzcGxpdCIsImFyZyIsInRyaW0iLCJhdXRvSW5qZWN0IiwibmV3VGFza3MiLCJwYXJhbXMiLCJmbklzQXN5bmMiLCJoYXNOb0RlcHMiLCJuZXdUYXNrIiwidGFza0NiIiwibmV3QXJncyIsIm5hbWUiLCJETEwiLCJjb25zdHJ1Y3RvciIsImhlYWQiLCJ0YWlsIiwicmVtb3ZlTGluayIsIm5vZGUiLCJwcmV2IiwiZW1wdHkiLCJpbnNlcnRBZnRlciIsIm5ld05vZGUiLCJpbnNlcnRCZWZvcmUiLCJ1bnNoaWZ0Iiwic2V0SW5pdGlhbCIsInRvQXJyYXkiLCJjdXIiLCJkYXRhIiwicmVtb3ZlIiwidGVzdEZuIiwiY3VyciIsImRsbCIsInF1ZXVlJDEiLCJ3b3JrZXIiLCJwYXlsb2FkIiwiX3dvcmtlciIsIm51bVJ1bm5pbmciLCJ3b3JrZXJzTGlzdCIsImV2ZW50cyIsImRyYWluIiwic2F0dXJhdGVkIiwidW5zYXR1cmF0ZWQiLCJvbiIsImV2ZW50IiwiaGFuZGxlciIsImhhbmRsZUFuZFJlbW92ZSIsIm9mZiIsImV2IiwiZmlsdGVyIiwidHJpZ2dlciIsInByb2Nlc3NpbmdTY2hlZHVsZWQiLCJfaW5zZXJ0IiwiaW5zZXJ0QXRGcm9udCIsInJlamVjdE9uRXJyb3IiLCJxIiwic3RhcnRlZCIsIl9jcmVhdGVUYXNrSXRlbSIsIl90YXNrcyIsIl9jcmVhdGVDQiIsImwiLCJzcGxpY2UiLCJidWZmZXIiLCJpZGxlIiwiX21heWJlRHJhaW4iLCJldmVudE1ldGhvZCIsImlzUHJvY2Vzc2luZyIsInBhdXNlZCIsImRhdHVtIiwicHVzaEFzeW5jIiwia2lsbCIsInVuc2hpZnRBc3luYyIsIk1hdGgiLCJtaW4iLCJwYXVzZSIsInJlc3VtZSIsImRlZmluZVByb3BlcnRpZXMiLCJ3cml0YWJsZSIsImNhcmdvJDEiLCJjYXJnbyIsInJlZHVjZSIsIm1lbW8iLCJ4IiwicmVkdWNlJDEiLCJzZXEiLCJmdW5jdGlvbnMiLCJfZnVuY3Rpb25zIiwibmV3YXJncyIsIm5leHRhcmdzIiwiY29tcG9zZSIsInJldmVyc2UiLCJtYXBMaW1pdCIsIm1hcExpbWl0JDEiLCJjb25jYXRMaW1pdCIsInZhbCIsIm1hcFJlc3VsdHMiLCJjb25jYXRMaW1pdCQxIiwiY29uY2F0JDEiLCJjb25jYXRTZXJpZXMiLCJjb25jYXRTZXJpZXMkMSIsImNvbnN0YW50JDEiLCJpZ25vcmVkQXJncyIsIl9jcmVhdGVUZXN0ZXIiLCJjaGVjayIsImdldFJlc3VsdCIsInRlc3RQYXNzZWQiLCJ0ZXN0UmVzdWx0IiwiZGV0ZWN0IiwiYm9vbCIsImRldGVjdCQxIiwiZGV0ZWN0TGltaXQiLCJkZXRlY3RMaW1pdCQxIiwiZGV0ZWN0U2VyaWVzIiwiZGV0ZWN0U2VyaWVzJDEiLCJjb25zb2xlRnVuYyIsInJlc3VsdEFyZ3MiLCJjb25zb2xlIiwiZGlyIiwiZG9XaGlsc3QiLCJ0ZXN0IiwiX2ZuIiwiX3Rlc3QiLCJ0cnV0aCIsImRvV2hpbHN0JDEiLCJkb1VudGlsIiwiX3dpdGhvdXRJbmRleCIsImVhY2hMaW1pdCQyIiwiZWFjaCIsImVhY2hMaW1pdCIsImVhY2hMaW1pdCQxIiwiZWFjaFNlcmllcyIsImVhY2hTZXJpZXMkMSIsImVuc3VyZUFzeW5jIiwic3luYyIsImlubmVyQXJncyIsImV2ZXJ5IiwiZXZlcnkkMSIsImV2ZXJ5TGltaXQiLCJldmVyeUxpbWl0JDEiLCJldmVyeVNlcmllcyIsImV2ZXJ5U2VyaWVzJDEiLCJmaWx0ZXJBcnJheSIsInRydXRoVmFsdWVzIiwiZmlsdGVyR2VuZXJpYyIsInNvcnQiLCJhIiwiYiIsIl9maWx0ZXIiLCJmaWx0ZXIkMSIsImZpbHRlckxpbWl0IiwiZmlsdGVyTGltaXQkMSIsImZpbHRlclNlcmllcyIsImZpbHRlclNlcmllcyQxIiwiZm9yZXZlciIsImVycmJhY2siLCJmb3JldmVyJDEiLCJncm91cEJ5TGltaXQiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3RvdHlwZSIsImdyb3VwQnlMaW1pdCQxIiwiZ3JvdXBCeSIsImdyb3VwQnlTZXJpZXMiLCJsb2ciLCJtYXBWYWx1ZXNMaW1pdCIsIm5ld09iaiIsIm1hcFZhbHVlc0xpbWl0JDEiLCJtYXBWYWx1ZXMiLCJtYXBWYWx1ZXNTZXJpZXMiLCJtZW1vaXplIiwiaGFzaGVyIiwicXVldWVzIiwibWVtb2l6ZWQiLCJ1bm1lbW9pemVkIiwiX2RlZmVyIiwiX3BhcmFsbGVsIiwicGFyYWxsZWwiLCJwYXJhbGxlbExpbWl0IiwicXVldWUiLCJpdGVtcyIsIkhlYXAiLCJoZWFwIiwicHVzaENvdW50IiwiTnVtYmVyIiwiTUlOX1NBRkVfSU5URUdFUiIsInBlcmNVcCIsInAiLCJzbWFsbGVyIiwicGFyZW50IiwidCIsInBlcmNEb3duIiwibGVmdENoaSIsInRvcCIsImoiLCJ5IiwicHJpb3JpdHkiLCJwcmlvcml0eVF1ZXVlIiwiY3JlYXRlRGF0YUl0ZW1zIiwicmFjZSIsIlR5cGVFcnJvciIsInJhY2UkMSIsInJlZHVjZVJpZ2h0IiwiYXJyYXkiLCJyZXZlcnNlZCIsInJlZmxlY3QiLCJyZWZsZWN0T24iLCJyZWZsZWN0Q2FsbGJhY2siLCJyZXRWYWwiLCJyZWZsZWN0QWxsIiwicmVqZWN0JDIiLCJyZWplY3QkMSIsInJlamVjdExpbWl0IiwicmVqZWN0TGltaXQkMSIsInJlamVjdFNlcmllcyIsInJlamVjdFNlcmllcyQxIiwiY29uc3RhbnQiLCJERUZBVUxUX1RJTUVTIiwiREVGQVVMVF9JTlRFUlZBTCIsInJldHJ5Iiwib3B0cyIsIm9wdGlvbnMiLCJ0aW1lcyIsImludGVydmFsRnVuYyIsImFyZ3VtZW50cyIsInBhcnNlVGltZXMiLCJfdGFzayIsImF0dGVtcHQiLCJyZXRyeUF0dGVtcHQiLCJlcnJvckZpbHRlciIsImFjYyIsImludGVydmFsIiwicmV0cnlhYmxlIiwic2VyaWVzIiwic29tZSIsIkJvb2xlYW4iLCJzb21lJDEiLCJzb21lTGltaXQiLCJzb21lTGltaXQkMSIsInNvbWVTZXJpZXMiLCJzb21lU2VyaWVzJDEiLCJzb3J0QnkiLCJjcml0ZXJpYSIsImNvbXBhcmF0b3IiLCJsZWZ0IiwicmlnaHQiLCJzb3J0QnkkMSIsInRpbWVvdXQiLCJtaWxsaXNlY29uZHMiLCJpbmZvIiwidGltZWRPdXQiLCJ0aW1lciIsInRpbWVvdXRDYWxsYmFjayIsImNvZGUiLCJjbGVhclRpbWVvdXQiLCJyYW5nZSIsInNpemUiLCJ0aW1lc0xpbWl0IiwiY291bnQiLCJuIiwidGltZXNTZXJpZXMiLCJ0cmFuc2Zvcm0iLCJhY2N1bXVsYXRvciIsImsiLCJ0cnlFYWNoIiwidHJ5RWFjaCQxIiwidW5tZW1vaXplIiwid2hpbHN0IiwicmVzdCIsIndoaWxzdCQxIiwidW50aWwiLCJ3YXRlcmZhbGwiLCJ0YXNrSW5kZXgiLCJuZXh0VGFzayIsIndhdGVyZmFsbCQxIiwiY2FyZ29RdWV1ZSIsImFsbCIsImFsbExpbWl0IiwiYWxsU2VyaWVzIiwiYW55IiwiYW55TGltaXQiLCJhbnlTZXJpZXMiLCJmaW5kIiwiZmluZExpbWl0IiwiZmluZFNlcmllcyIsImZsYXRNYXAiLCJmbGF0TWFwTGltaXQiLCJmbGF0TWFwU2VyaWVzIiwiZm9yRWFjaFNlcmllcyIsImZvckVhY2hMaW1pdCIsImZvckVhY2hPZiIsImZvckVhY2hPZlNlcmllcyIsImZvckVhY2hPZkxpbWl0IiwiaW5qZWN0IiwiZm9sZGwiLCJmb2xkciIsInNlbGVjdCIsInNlbGVjdExpbWl0Iiwic2VsZWN0U2VyaWVzIiwid3JhcFN5bmMiLCJkdXJpbmciLCJkb0R1cmluZyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/async/dist/async.mjs\n");

/***/ })

};
;