/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tmp";
exports.ids = ["vendor-chunks/tmp"];
exports.modules = {

/***/ "(ssr)/./node_modules/tmp/lib/tmp.js":
/*!*************************************!*\
  !*** ./node_modules/tmp/lib/tmp.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */ /*\n * Module dependencies.\n */ const fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst _c = {\n    fs: fs.constants,\n    os: os.constants\n};\nconst rimraf = __webpack_require__(/*! rimraf */ \"(ssr)/./node_modules/rimraf/rimraf.js\");\n/*\n * The working inner variables.\n */ const // the random characters to choose from\nRANDOM_CHARS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", TEMPLATE_PATTERN = /XXXXXX/, DEFAULT_TRIES = 3, CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR), // constants are off on the windows platform and will not match the actual errno codes\nIS_WIN32 = os.platform() === \"win32\", EBADF = _c.EBADF || _c.os.errno.EBADF, ENOENT = _c.ENOENT || _c.os.errno.ENOENT, DIR_MODE = 448 /* 448 */ , FILE_MODE = 384 /* 384 */ , EXIT = \"exit\", // this will hold the objects need to be removed on exit\n_removeObjects = [], // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\nFN_RMDIR_SYNC = fs.rmdirSync.bind(fs), FN_RIMRAF_SYNC = rimraf.sync;\nlet _gracefulCleanup = false;\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */ function tmpName(options, callback) {\n    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];\n    try {\n        _assertAndSanitizeOptions(opts);\n    } catch (err) {\n        return cb(err);\n    }\n    let tries = opts.tries;\n    (function _getUniqueName() {\n        try {\n            const name = _generateTmpName(opts);\n            // check whether the path exists then retry if needed\n            fs.stat(name, function(err) {\n                /* istanbul ignore else */ if (!err) {\n                    /* istanbul ignore else */ if (tries-- > 0) return _getUniqueName();\n                    return cb(new Error(\"Could not get a unique tmp filename, max tries reached \" + name));\n                }\n                cb(null, name);\n            });\n        } catch (err) {\n            cb(err);\n        }\n    })();\n}\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */ function tmpNameSync(options) {\n    const args = _parseArguments(options), opts = args[0];\n    _assertAndSanitizeOptions(opts);\n    let tries = opts.tries;\n    do {\n        const name = _generateTmpName(opts);\n        try {\n            fs.statSync(name);\n        } catch (e) {\n            return name;\n        }\n    }while (tries-- > 0);\n    throw new Error(\"Could not get a unique tmp filename, max tries reached\");\n}\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */ function file(options, callback) {\n    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];\n    // gets a temporary filename\n    tmpName(opts, function _tmpNameCreated(err, name) {\n        /* istanbul ignore else */ if (err) return cb(err);\n        // create and open the file\n        fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n            /* istanbu ignore else */ if (err) return cb(err);\n            if (opts.discardDescriptor) {\n                return fs.close(fd, function _discardCallback(possibleErr) {\n                    // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n                    return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n                });\n            } else {\n                // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n                // about the descriptor\n                const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n                cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n            }\n        });\n    });\n}\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */ function fileSync(options) {\n    const args = _parseArguments(options), opts = args[0];\n    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n    const name = tmpNameSync(opts);\n    var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n    /* istanbul ignore else */ if (opts.discardDescriptor) {\n        fs.closeSync(fd);\n        fd = undefined;\n    }\n    return {\n        name: name,\n        fd: fd,\n        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n    };\n}\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */ function dir(options, callback) {\n    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];\n    // gets a temporary filename\n    tmpName(opts, function _tmpNameCreated(err, name) {\n        /* istanbul ignore else */ if (err) return cb(err);\n        // create the directory\n        fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n            /* istanbul ignore else */ if (err) return cb(err);\n            cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n        });\n    });\n}\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */ function dirSync(options) {\n    const args = _parseArguments(options), opts = args[0];\n    const name = tmpNameSync(opts);\n    fs.mkdirSync(name, opts.mode || DIR_MODE);\n    return {\n        name: name,\n        removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n    };\n}\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */ function _removeFileAsync(fdPath, next) {\n    const _handler = function(err) {\n        if (err && !_isENOENT(err)) {\n            // reraise any unanticipated error\n            return next(err);\n        }\n        next();\n    };\n    if (0 <= fdPath[0]) fs.close(fdPath[0], function() {\n        fs.unlink(fdPath[1], _handler);\n    });\n    else fs.unlink(fdPath[1], _handler);\n}\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */ function _removeFileSync(fdPath) {\n    let rethrownException = null;\n    try {\n        if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n    } catch (e) {\n        // reraise any unanticipated error\n        if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n    } finally{\n        try {\n            fs.unlinkSync(fdPath[1]);\n        } catch (e) {\n            // reraise any unanticipated error\n            if (!_isENOENT(e)) rethrownException = e;\n        }\n    }\n    if (rethrownException !== null) {\n        throw rethrownException;\n    }\n}\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */ function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n    const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [\n        fd,\n        name\n    ], sync);\n    const removeCallback = _prepareRemoveCallback(_removeFileAsync, [\n        fd,\n        name\n    ], sync, removeCallbackSync);\n    if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n    return sync ? removeCallbackSync : removeCallback;\n}\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */ function _prepareTmpDirRemoveCallback(name, opts, sync) {\n    const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n    const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n    const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n    const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n    if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n    return sync ? removeCallbackSync : removeCallback;\n}\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */ function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n    let called = false;\n    // if sync is true, the next parameter will be ignored\n    return function _cleanupCallback(next) {\n        /* istanbul ignore else */ if (!called) {\n            // remove cleanupCallback from cache\n            const toRemove = cleanupCallbackSync || _cleanupCallback;\n            const index = _removeObjects.indexOf(toRemove);\n            /* istanbul ignore else */ if (index >= 0) _removeObjects.splice(index, 1);\n            called = true;\n            if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n                return removeFunction(fileOrDirName);\n            } else {\n                return removeFunction(fileOrDirName, next || function() {});\n            }\n        }\n    };\n}\n/**\n * The garbage collector.\n *\n * @private\n */ function _garbageCollector() {\n    /* istanbul ignore else */ if (!_gracefulCleanup) return;\n    // the function being called removes itself from _removeObjects,\n    // loop until _removeObjects is empty\n    while(_removeObjects.length){\n        try {\n            _removeObjects[0]();\n        } catch (e) {\n        // already removed?\n        }\n    }\n}\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */ function _randomChars(howMany) {\n    let value = [], rnd = null;\n    // make sure that we do not fail because we ran out of entropy\n    try {\n        rnd = crypto.randomBytes(howMany);\n    } catch (e) {\n        rnd = crypto.pseudoRandomBytes(howMany);\n    }\n    for(var i = 0; i < howMany; i++){\n        value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n    }\n    return value.join(\"\");\n}\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */ function _isBlank(s) {\n    return s === null || _isUndefined(s) || !s.trim();\n}\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */ function _isUndefined(obj) {\n    return typeof obj === \"undefined\";\n}\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */ function _parseArguments(options, callback) {\n    /* istanbul ignore else */ if (typeof options === \"function\") {\n        return [\n            {},\n            options\n        ];\n    }\n    /* istanbul ignore else */ if (_isUndefined(options)) {\n        return [\n            {},\n            callback\n        ];\n    }\n    // copy options so we do not leak the changes we make internally\n    const actualOptions = {};\n    for (const key of Object.getOwnPropertyNames(options)){\n        actualOptions[key] = options[key];\n    }\n    return [\n        actualOptions,\n        callback\n    ];\n}\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */ function _generateTmpName(opts) {\n    const tmpDir = opts.tmpdir;\n    /* istanbul ignore else */ if (!_isUndefined(opts.name)) return path.join(tmpDir, opts.dir, opts.name);\n    /* istanbul ignore else */ if (!_isUndefined(opts.template)) return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n    // prefix and postfix\n    const name = [\n        opts.prefix ? opts.prefix : \"tmp\",\n        \"-\",\n        process.pid,\n        \"-\",\n        _randomChars(12),\n        opts.postfix ? \"-\" + opts.postfix : \"\"\n    ].join(\"\");\n    return path.join(tmpDir, opts.dir, name);\n}\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @param {Options} options\n * @private\n */ function _assertAndSanitizeOptions(options) {\n    options.tmpdir = _getTmpDir(options);\n    const tmpDir = options.tmpdir;\n    /* istanbul ignore else */ if (!_isUndefined(options.name)) _assertIsRelative(options.name, \"name\", tmpDir);\n    /* istanbul ignore else */ if (!_isUndefined(options.dir)) _assertIsRelative(options.dir, \"dir\", tmpDir);\n    /* istanbul ignore else */ if (!_isUndefined(options.template)) {\n        _assertIsRelative(options.template, \"template\", tmpDir);\n        if (!options.template.match(TEMPLATE_PATTERN)) throw new Error(`Invalid template, found \"${options.template}\".`);\n    }\n    /* istanbul ignore else */ if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0) throw new Error(`Invalid tries, found \"${options.tries}\".`);\n    // if a name was specified we will try once\n    options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n    options.keep = !!options.keep;\n    options.detachDescriptor = !!options.detachDescriptor;\n    options.discardDescriptor = !!options.discardDescriptor;\n    options.unsafeCleanup = !!options.unsafeCleanup;\n    // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n    options.dir = _isUndefined(options.dir) ? \"\" : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));\n    options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));\n    // sanitize further if template is relative to options.dir\n    options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);\n    // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n    options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name);\n    options.prefix = _isUndefined(options.prefix) ? \"\" : options.prefix;\n    options.postfix = _isUndefined(options.postfix) ? \"\" : options.postfix;\n}\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @param name\n * @param tmpDir\n * @returns {string}\n * @private\n */ function _resolvePath(name, tmpDir) {\n    const sanitizedName = _sanitizeName(name);\n    if (sanitizedName.startsWith(tmpDir)) {\n        return path.resolve(sanitizedName);\n    } else {\n        return path.resolve(path.join(tmpDir, sanitizedName));\n    }\n}\n/**\n * Sanitize the specified path name by removing all quote characters.\n *\n * @param name\n * @returns {string}\n * @private\n */ function _sanitizeName(name) {\n    if (_isBlank(name)) {\n        return name;\n    }\n    return name.replace(/[\"']/g, \"\");\n}\n/**\n * Asserts whether specified name is relative to the specified tmpDir.\n *\n * @param {string} name\n * @param {string} option\n * @param {string} tmpDir\n * @throws {Error}\n * @private\n */ function _assertIsRelative(name, option, tmpDir) {\n    if (option === \"name\") {\n        // assert that name is not absolute and does not contain a path\n        if (path.isAbsolute(name)) throw new Error(`${option} option must not contain an absolute path, found \"${name}\".`);\n        // must not fail on valid .<name> or ..<name> or similar such constructs\n        let basename = path.basename(name);\n        if (basename === \"..\" || basename === \".\" || basename !== name) throw new Error(`${option} option must not contain a path, found \"${name}\".`);\n    } else {\n        // assert that dir or template are relative to tmpDir\n        if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {\n            throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${name}\".`);\n        }\n        let resolvedPath = _resolvePath(name, tmpDir);\n        if (!resolvedPath.startsWith(tmpDir)) throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${resolvedPath}\".`);\n    }\n}\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */ function _isEBADF(error) {\n    return _isExpectedError(error, -EBADF, \"EBADF\");\n}\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */ function _isENOENT(error) {\n    return _isExpectedError(error, -ENOENT, \"ENOENT\");\n}\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */ function _isExpectedError(error, errno, code) {\n    return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */ function setGracefulCleanup() {\n    _gracefulCleanup = true;\n}\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @param {?Options} options\n * @returns {string} the currently configured tmp dir\n */ function _getTmpDir(options) {\n    return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));\n}\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */ /**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */ /**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */ /**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */ /**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */ /**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */ /**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */ /**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */ /**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */ /**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */ /**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */ // exporting all the needed methods\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, \"tmpdir\", ({\n    enumerable: true,\n    configurable: false,\n    get: function() {\n        return _getTmpDir();\n    }\n}));\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cC9saWIvdG1wLmpzPzg4ZDciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUbXBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNyBLQVJBU1pJIElzdHZhbiA8Z2l0aHViQHNwYW0ucmFzemkuaHU+XG4gKlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLypcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IF9jID0geyBmczogZnMuY29uc3RhbnRzLCBvczogb3MuY29uc3RhbnRzIH07XG5jb25zdCByaW1yYWYgPSByZXF1aXJlKCdyaW1yYWYnKTtcblxuLypcbiAqIFRoZSB3b3JraW5nIGlubmVyIHZhcmlhYmxlcy5cbiAqL1xuY29uc3RcbiAgLy8gdGhlIHJhbmRvbSBjaGFyYWN0ZXJzIHRvIGNob29zZSBmcm9tXG4gIFJBTkRPTV9DSEFSUyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXG5cbiAgVEVNUExBVEVfUEFUVEVSTiA9IC9YWFhYWFgvLFxuXG4gIERFRkFVTFRfVFJJRVMgPSAzLFxuXG4gIENSRUFURV9GTEFHUyA9IChfYy5PX0NSRUFUIHx8IF9jLmZzLk9fQ1JFQVQpIHwgKF9jLk9fRVhDTCB8fCBfYy5mcy5PX0VYQ0wpIHwgKF9jLk9fUkRXUiB8fCBfYy5mcy5PX1JEV1IpLFxuXG4gIC8vIGNvbnN0YW50cyBhcmUgb2ZmIG9uIHRoZSB3aW5kb3dzIHBsYXRmb3JtIGFuZCB3aWxsIG5vdCBtYXRjaCB0aGUgYWN0dWFsIGVycm5vIGNvZGVzXG4gIElTX1dJTjMyID0gb3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJyxcbiAgRUJBREYgPSBfYy5FQkFERiB8fCBfYy5vcy5lcnJuby5FQkFERixcbiAgRU5PRU5UID0gX2MuRU5PRU5UIHx8IF9jLm9zLmVycm5vLkVOT0VOVCxcblxuICBESVJfTU9ERSA9IDBvNzAwIC8qIDQ0OCAqLyxcbiAgRklMRV9NT0RFID0gMG82MDAgLyogMzg0ICovLFxuXG4gIEVYSVQgPSAnZXhpdCcsXG5cbiAgLy8gdGhpcyB3aWxsIGhvbGQgdGhlIG9iamVjdHMgbmVlZCB0byBiZSByZW1vdmVkIG9uIGV4aXRcbiAgX3JlbW92ZU9iamVjdHMgPSBbXSxcblxuICAvLyBBUEkgY2hhbmdlIGluIGZzLnJtZGlyU3luYyBsZWFkcyB0byBlcnJvciB3aGVuIHBhc3NpbmcgaW4gYSBzZWNvbmQgcGFyYW1ldGVyLCBlLmcuIHRoZSBjYWxsYmFja1xuICBGTl9STURJUl9TWU5DID0gZnMucm1kaXJTeW5jLmJpbmQoZnMpLFxuICBGTl9SSU1SQUZfU1lOQyA9IHJpbXJhZi5zeW5jO1xuXG5sZXRcbiAgX2dyYWNlZnVsQ2xlYW51cCA9IGZhbHNlO1xuXG4vKipcbiAqIEdldHMgYSB0ZW1wb3JhcnkgZmlsZSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7KE9wdGlvbnN8dG1wTmFtZUNhbGxiYWNrKX0gb3B0aW9ucyBvcHRpb25zIG9yIGNhbGxiYWNrXG4gKiBAcGFyYW0gez90bXBOYW1lQ2FsbGJhY2t9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICovXG5mdW5jdGlvbiB0bXBOYW1lKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0XG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdO1xuXG4gIHRyeSB7XG4gICAgX2Fzc2VydEFuZFNhbml0aXplT3B0aW9ucyhvcHRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGNiKGVycik7XG4gIH1cblxuICBsZXQgdHJpZXMgPSBvcHRzLnRyaWVzO1xuICAoZnVuY3Rpb24gX2dldFVuaXF1ZU5hbWUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpO1xuXG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBwYXRoIGV4aXN0cyB0aGVuIHJldHJ5IGlmIG5lZWRlZFxuICAgICAgZnMuc3RhdChuYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAodHJpZXMtLSA+IDApIHJldHVybiBfZ2V0VW5pcXVlTmFtZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQ291bGQgbm90IGdldCBhIHVuaXF1ZSB0bXAgZmlsZW5hbWUsIG1heCB0cmllcyByZWFjaGVkICcgKyBuYW1lKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYihudWxsLCBuYW1lKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0oKSk7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXMgdmVyc2lvbiBvZiB0bXBOYW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZ2VuZXJhdGVkIHJhbmRvbSBuYW1lXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG9wdGlvbnMgYXJlIGludmFsaWQgb3IgY291bGQgbm90IGdlbmVyYXRlIGEgZmlsZW5hbWVcbiAqL1xuZnVuY3Rpb24gdG1wTmFtZVN5bmMob3B0aW9ucykge1xuICBjb25zdFxuICAgIGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucyksXG4gICAgb3B0cyA9IGFyZ3NbMF07XG5cbiAgX2Fzc2VydEFuZFNhbml0aXplT3B0aW9ucyhvcHRzKTtcblxuICBsZXQgdHJpZXMgPSBvcHRzLnRyaWVzO1xuICBkbyB7XG4gICAgY29uc3QgbmFtZSA9IF9nZW5lcmF0ZVRtcE5hbWUob3B0cyk7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnN0YXRTeW5jKG5hbWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfSB3aGlsZSAodHJpZXMtLSA+IDApO1xuXG4gIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBhIHVuaXF1ZSB0bXAgZmlsZW5hbWUsIG1heCB0cmllcyByZWFjaGVkJyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgb3BlbnMgYSB0ZW1wb3JhcnkgZmlsZS5cbiAqXG4gKiBAcGFyYW0geyhPcHRpb25zfG51bGx8dW5kZWZpbmVkfGZpbGVDYWxsYmFjayl9IG9wdGlvbnMgdGhlIGNvbmZpZyBvcHRpb25zIG9yIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBvciBudWxsIG9yIHVuZGVmaW5lZFxuICogQHBhcmFtIHs/ZmlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBmaWxlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0XG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdO1xuXG4gIC8vIGdldHMgYSB0ZW1wb3JhcnkgZmlsZW5hbWVcbiAgdG1wTmFtZShvcHRzLCBmdW5jdGlvbiBfdG1wTmFtZUNyZWF0ZWQoZXJyLCBuYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIC8vIGNyZWF0ZSBhbmQgb3BlbiB0aGUgZmlsZVxuICAgIGZzLm9wZW4obmFtZSwgQ1JFQVRFX0ZMQUdTLCBvcHRzLm1vZGUgfHwgRklMRV9NT0RFLCBmdW5jdGlvbiBfZmlsZUNyZWF0ZWQoZXJyLCBmZCkge1xuICAgICAgLyogaXN0YW5idSBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChvcHRzLmRpc2NhcmREZXNjcmlwdG9yKSB7XG4gICAgICAgIHJldHVybiBmcy5jbG9zZShmZCwgZnVuY3Rpb24gX2Rpc2NhcmRDYWxsYmFjayhwb3NzaWJsZUVycikge1xuICAgICAgICAgIC8vIHRoZSBjaGFuY2Ugb2YgZ2V0dGluZyBhbiBlcnJvciBvbiBjbG9zZSBoZXJlIGlzIHJhdGhlciBsb3cgYW5kIG1pZ2h0IG9jY3VyIGluIHRoZSBtb3N0IGVkZ2llc3QgY2FzZXMgb25seVxuICAgICAgICAgIHJldHVybiBjYihwb3NzaWJsZUVyciwgbmFtZSwgdW5kZWZpbmVkLCBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCAtMSwgb3B0cywgZmFsc2UpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZXRhY2hEZXNjcmlwdG9yIHBhc3NlcyB0aGUgZGVzY3JpcHRvciB3aGVyZWFzIGRpc2NhcmREZXNjcmlwdG9yIGNsb3NlcyBpdCwgZWl0aGVyIHdheSwgd2Ugbm8gbG9uZ2VyIGNhcmVcbiAgICAgICAgLy8gYWJvdXQgdGhlIGRlc2NyaXB0b3JcbiAgICAgICAgY29uc3QgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA9IG9wdHMuZGlzY2FyZERlc2NyaXB0b3IgfHwgb3B0cy5kZXRhY2hEZXNjcmlwdG9yO1xuICAgICAgICBjYihudWxsLCBuYW1lLCBmZCwgX3ByZXBhcmVUbXBGaWxlUmVtb3ZlQ2FsbGJhY2sobmFtZSwgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA/IC0xIDogZmQsIG9wdHMsIGZhbHNlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtGaWxlU3luY09iamVjdH0gb2JqZWN0IGNvbnNpc3RzIG9mIG5hbWUsIGZkIGFuZCByZW1vdmVDYWxsYmFja1xuICogQHRocm93cyB7RXJyb3J9IGlmIGNhbm5vdCBjcmVhdGUgYSBmaWxlXG4gKi9cbmZ1bmN0aW9uIGZpbGVTeW5jKG9wdGlvbnMpIHtcbiAgY29uc3RcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMpLFxuICAgIG9wdHMgPSBhcmdzWzBdO1xuXG4gIGNvbnN0IGRpc2NhcmRPckRldGFjaERlc2NyaXB0b3IgPSBvcHRzLmRpc2NhcmREZXNjcmlwdG9yIHx8IG9wdHMuZGV0YWNoRGVzY3JpcHRvcjtcbiAgY29uc3QgbmFtZSA9IHRtcE5hbWVTeW5jKG9wdHMpO1xuICB2YXIgZmQgPSBmcy5vcGVuU3luYyhuYW1lLCBDUkVBVEVfRkxBR1MsIG9wdHMubW9kZSB8fCBGSUxFX01PREUpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAob3B0cy5kaXNjYXJkRGVzY3JpcHRvcikge1xuICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgZmQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZmQ6IGZkLFxuICAgIHJlbW92ZUNhbGxiYWNrOiBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCBkaXNjYXJkT3JEZXRhY2hEZXNjcmlwdG9yID8gLTEgOiBmZCwgb3B0cywgdHJ1ZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGVtcG9yYXJ5IGRpcmVjdG9yeS5cbiAqXG4gKiBAcGFyYW0geyhPcHRpb25zfGRpckNhbGxiYWNrKX0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7P2RpckNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBkaXIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3RcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGNhbGxiYWNrKSxcbiAgICBvcHRzID0gYXJnc1swXSxcbiAgICBjYiA9IGFyZ3NbMV07XG5cbiAgLy8gZ2V0cyBhIHRlbXBvcmFyeSBmaWxlbmFtZVxuICB0bXBOYW1lKG9wdHMsIGZ1bmN0aW9uIF90bXBOYW1lQ3JlYXRlZChlcnIsIG5hbWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBkaXJlY3RvcnlcbiAgICBmcy5ta2RpcihuYW1lLCBvcHRzLm1vZGUgfHwgRElSX01PREUsIGZ1bmN0aW9uIF9kaXJDcmVhdGVkKGVycikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBjYihudWxsLCBuYW1lLCBfcHJlcGFyZVRtcERpclJlbW92ZUNhbGxiYWNrKG5hbWUsIG9wdHMsIGZhbHNlKSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgZGlyLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0RpclN5bmNPYmplY3R9IG9iamVjdCBjb25zaXN0cyBvZiBuYW1lIGFuZCByZW1vdmVDYWxsYmFja1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGNhbm5vdCBjcmVhdGUgYSBkaXJlY3RvcnlcbiAqL1xuZnVuY3Rpb24gZGlyU3luYyhvcHRpb25zKSB7XG4gIGNvbnN0XG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zKSxcbiAgICBvcHRzID0gYXJnc1swXTtcblxuICBjb25zdCBuYW1lID0gdG1wTmFtZVN5bmMob3B0cyk7XG4gIGZzLm1rZGlyU3luYyhuYW1lLCBvcHRzLm1vZGUgfHwgRElSX01PREUpO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICByZW1vdmVDYWxsYmFjazogX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayhuYW1lLCBvcHRzLCB0cnVlKVxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZmlsZXMgYXN5bmNocm9ub3VzbHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZkUGF0aFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JlbW92ZUZpbGVBc3luYyhmZFBhdGgsIG5leHQpIHtcbiAgY29uc3QgX2hhbmRsZXIgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiAhX2lzRU5PRU5UKGVycikpIHtcbiAgICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgfVxuICAgIG5leHQoKTtcbiAgfTtcblxuICBpZiAoMCA8PSBmZFBhdGhbMF0pXG4gICAgZnMuY2xvc2UoZmRQYXRoWzBdLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmcy51bmxpbmsoZmRQYXRoWzFdLCBfaGFuZGxlcik7XG4gICAgfSk7XG4gIGVsc2UgZnMudW5saW5rKGZkUGF0aFsxXSwgX2hhbmRsZXIpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZmlsZXMgc3luY2hyb25vdXNseS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmRQYXRoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVtb3ZlRmlsZVN5bmMoZmRQYXRoKSB7XG4gIGxldCByZXRocm93bkV4Y2VwdGlvbiA9IG51bGw7XG4gIHRyeSB7XG4gICAgaWYgKDAgPD0gZmRQYXRoWzBdKSBmcy5jbG9zZVN5bmMoZmRQYXRoWzBdKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICBpZiAoIV9pc0VCQURGKGUpICYmICFfaXNFTk9FTlQoZSkpIHRocm93IGU7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnVubGlua1N5bmMoZmRQYXRoWzFdKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICAgIGlmICghX2lzRU5PRU5UKGUpKSByZXRocm93bkV4Y2VwdGlvbiA9IGU7XG4gICAgfVxuICB9XG4gIGlmIChyZXRocm93bkV4Y2VwdGlvbiAhPT0gbnVsbCkge1xuICAgIHRocm93IHJldGhyb3duRXhjZXB0aW9uO1xuICB9XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdGhlIGNhbGxiYWNrIGZvciByZW1vdmFsIG9mIHRoZSB0ZW1wb3JhcnkgZmlsZS5cbiAqXG4gKiBSZXR1cm5zIGVpdGhlciBhIHN5bmMgY2FsbGJhY2sgb3IgYSBhc3luYyBjYWxsYmFjayBkZXBlbmRpbmcgb24gd2hldGhlclxuICogZmlsZVN5bmMgb3IgZmlsZSB3YXMgY2FsbGVkLCB3aGljaCBpcyBleHByZXNzZWQgYnkgdGhlIHN5bmMgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBwYXRoIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcmV0dXJucyB7ZmlsZUNhbGxiYWNrIHwgZmlsZUNhbGxiYWNrU3luY31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIGZkLCBvcHRzLCBzeW5jKSB7XG4gIGNvbnN0IHJlbW92ZUNhbGxiYWNrU3luYyA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2soX3JlbW92ZUZpbGVTeW5jLCBbZmQsIG5hbWVdLCBzeW5jKTtcbiAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSBfcHJlcGFyZVJlbW92ZUNhbGxiYWNrKF9yZW1vdmVGaWxlQXN5bmMsIFtmZCwgbmFtZV0sIHN5bmMsIHJlbW92ZUNhbGxiYWNrU3luYyk7XG5cbiAgaWYgKCFvcHRzLmtlZXApIF9yZW1vdmVPYmplY3RzLnVuc2hpZnQocmVtb3ZlQ2FsbGJhY2tTeW5jKTtcblxuICByZXR1cm4gc3luYyA/IHJlbW92ZUNhbGxiYWNrU3luYyA6IHJlbW92ZUNhbGxiYWNrO1xufVxuXG4vKipcbiAqIFByZXBhcmVzIHRoZSBjYWxsYmFjayBmb3IgcmVtb3ZhbCBvZiB0aGUgdGVtcG9yYXJ5IGRpcmVjdG9yeS5cbiAqXG4gKiBSZXR1cm5zIGVpdGhlciBhIHN5bmMgY2FsbGJhY2sgb3IgYSBhc3luYyBjYWxsYmFjayBkZXBlbmRpbmcgb24gd2hldGhlclxuICogdG1wRmlsZVN5bmMgb3IgdG1wRmlsZSB3YXMgY2FsbGVkLCB3aGljaCBpcyBleHByZXNzZWQgYnkgdGhlIHN5bmMgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayhuYW1lLCBvcHRzLCBzeW5jKSB7XG4gIGNvbnN0IHJlbW92ZUZ1bmN0aW9uID0gb3B0cy51bnNhZmVDbGVhbnVwID8gcmltcmFmIDogZnMucm1kaXIuYmluZChmcyk7XG4gIGNvbnN0IHJlbW92ZUZ1bmN0aW9uU3luYyA9IG9wdHMudW5zYWZlQ2xlYW51cCA/IEZOX1JJTVJBRl9TWU5DIDogRk5fUk1ESVJfU1lOQztcbiAgY29uc3QgcmVtb3ZlQ2FsbGJhY2tTeW5jID0gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhyZW1vdmVGdW5jdGlvblN5bmMsIG5hbWUsIHN5bmMpO1xuICBjb25zdCByZW1vdmVDYWxsYmFjayA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2socmVtb3ZlRnVuY3Rpb24sIG5hbWUsIHN5bmMsIHJlbW92ZUNhbGxiYWNrU3luYyk7XG4gIGlmICghb3B0cy5rZWVwKSBfcmVtb3ZlT2JqZWN0cy51bnNoaWZ0KHJlbW92ZUNhbGxiYWNrU3luYyk7XG5cbiAgcmV0dXJuIHN5bmMgPyByZW1vdmVDYWxsYmFja1N5bmMgOiByZW1vdmVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZ3VhcmRlZCBmdW5jdGlvbiB3cmFwcGluZyB0aGUgcmVtb3ZlRnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBUaGUgY2xlYW51cCBjYWxsYmFjayBpcyBzYXZlIHRvIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqIFN1YnNlcXVlbnQgaW52b2NhdGlvbnMgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlbW92ZUZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZU9yRGlyTmFtZVxuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja1N5bmM/fSBjbGVhbnVwQ2FsbGJhY2tTeW5jXG4gKiBAcmV0dXJucyB7Y2xlYW51cENhbGxiYWNrIHwgY2xlYW51cENhbGxiYWNrU3luY31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2socmVtb3ZlRnVuY3Rpb24sIGZpbGVPckRpck5hbWUsIHN5bmMsIGNsZWFudXBDYWxsYmFja1N5bmMpIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGlmIHN5bmMgaXMgdHJ1ZSwgdGhlIG5leHQgcGFyYW1ldGVyIHdpbGwgYmUgaWdub3JlZFxuICByZXR1cm4gZnVuY3Rpb24gX2NsZWFudXBDYWxsYmFjayhuZXh0KSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAvLyByZW1vdmUgY2xlYW51cENhbGxiYWNrIGZyb20gY2FjaGVcbiAgICAgIGNvbnN0IHRvUmVtb3ZlID0gY2xlYW51cENhbGxiYWNrU3luYyB8fCBfY2xlYW51cENhbGxiYWNrO1xuICAgICAgY29uc3QgaW5kZXggPSBfcmVtb3ZlT2JqZWN0cy5pbmRleE9mKHRvUmVtb3ZlKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoaW5kZXggPj0gMCkgX3JlbW92ZU9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGlmIChzeW5jIHx8IHJlbW92ZUZ1bmN0aW9uID09PSBGTl9STURJUl9TWU5DIHx8IHJlbW92ZUZ1bmN0aW9uID09PSBGTl9SSU1SQUZfU1lOQykge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRnVuY3Rpb24oZmlsZU9yRGlyTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRnVuY3Rpb24oZmlsZU9yRGlyTmFtZSwgbmV4dCB8fCBmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGdhcmJhZ2UgY29sbGVjdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nYXJiYWdlQ29sbGVjdG9yKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9ncmFjZWZ1bENsZWFudXApIHJldHVybjtcblxuICAvLyB0aGUgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIHJlbW92ZXMgaXRzZWxmIGZyb20gX3JlbW92ZU9iamVjdHMsXG4gIC8vIGxvb3AgdW50aWwgX3JlbW92ZU9iamVjdHMgaXMgZW1wdHlcbiAgd2hpbGUgKF9yZW1vdmVPYmplY3RzLmxlbmd0aCkge1xuICAgIHRyeSB7XG4gICAgICBfcmVtb3ZlT2JqZWN0c1swXSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGFscmVhZHkgcmVtb3ZlZD9cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSYW5kb20gbmFtZSBnZW5lcmF0b3IgYmFzZWQgb24gY3J5cHRvLlxuICogQWRhcHRlZCBmcm9tIGh0dHA6Ly9ibG9nLnRvbXBhd2xhay5vcmcvaG93LXRvLWdlbmVyYXRlLXJhbmRvbS12YWx1ZXMtbm9kZWpzLWphdmFzY3JpcHRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaG93TWFueVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGdlbmVyYXRlZCByYW5kb20gbmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JhbmRvbUNoYXJzKGhvd01hbnkpIHtcbiAgbGV0XG4gICAgdmFsdWUgPSBbXSxcbiAgICBybmQgPSBudWxsO1xuXG4gIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGRvIG5vdCBmYWlsIGJlY2F1c2Ugd2UgcmFuIG91dCBvZiBlbnRyb3B5XG4gIHRyeSB7XG4gICAgcm5kID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGhvd01hbnkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcm5kID0gY3J5cHRvLnBzZXVkb1JhbmRvbUJ5dGVzKGhvd01hbnkpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3dNYW55OyBpKyspIHtcbiAgICB2YWx1ZS5wdXNoKFJBTkRPTV9DSEFSU1tybmRbaV0gJSBSQU5ET01fQ0hBUlMubGVuZ3RoXSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWUuam9pbignJyk7XG59XG5cbi8qKlxuICogSGVscGVyIHdoaWNoIGRldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBzIGlzIGJsYW5rLCB0aGF0IGlzIHVuZGVmaW5lZCwgb3IgZW1wdHkgb3IgbnVsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIHdoZXRoZXIgdGhlIHN0cmluZyBzIGlzIGJsYW5rLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gX2lzQmxhbmsocykge1xuICByZXR1cm4gcyA9PT0gbnVsbCB8fCBfaXNVbmRlZmluZWQocykgfHwgIXMudHJpbSgpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBgb2JqYCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyB1bmRlZmluZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc1VuZGVmaW5lZChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgZnVuY3Rpb24gYXJndW1lbnRzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGVscHMgdG8gaGF2ZSBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xudWxsfHVuZGVmaW5lZHxGdW5jdGlvbil9IG9wdGlvbnNcbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0FycmF5fSBwYXJzZWQgYXJndW1lbnRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcGFyc2VBcmd1bWVudHMob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIFt7fSwgb3B0aW9uc107XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoX2lzVW5kZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFt7fSwgY2FsbGJhY2tdO1xuICB9XG5cbiAgLy8gY29weSBvcHRpb25zIHNvIHdlIGRvIG5vdCBsZWFrIHRoZSBjaGFuZ2VzIHdlIG1ha2UgaW50ZXJuYWxseVxuICBjb25zdCBhY3R1YWxPcHRpb25zID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9wdGlvbnMpKSB7XG4gICAgYWN0dWFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIFthY3R1YWxPcHRpb25zLCBjYWxsYmFja107XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbmV3IHRlbXBvcmFyeSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgbmV3IHJhbmRvbSBuYW1lIGFjY29yZGluZyB0byBvcHRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpIHtcblxuICBjb25zdCB0bXBEaXIgPSBvcHRzLnRtcGRpcjtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRzLm5hbWUpKVxuICAgIHJldHVybiBwYXRoLmpvaW4odG1wRGlyLCBvcHRzLmRpciwgb3B0cy5uYW1lKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRzLnRlbXBsYXRlKSlcbiAgICByZXR1cm4gcGF0aC5qb2luKHRtcERpciwgb3B0cy5kaXIsIG9wdHMudGVtcGxhdGUpLnJlcGxhY2UoVEVNUExBVEVfUEFUVEVSTiwgX3JhbmRvbUNoYXJzKDYpKTtcblxuICAvLyBwcmVmaXggYW5kIHBvc3RmaXhcbiAgY29uc3QgbmFtZSA9IFtcbiAgICBvcHRzLnByZWZpeCA/IG9wdHMucHJlZml4IDogJ3RtcCcsXG4gICAgJy0nLFxuICAgIHByb2Nlc3MucGlkLFxuICAgICctJyxcbiAgICBfcmFuZG9tQ2hhcnMoMTIpLFxuICAgIG9wdHMucG9zdGZpeCA/ICctJyArIG9wdHMucG9zdGZpeCA6ICcnXG4gIF0uam9pbignJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbih0bXBEaXIsIG9wdHMuZGlyLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBvcHRpb25zIGFyZSB2YWxpZCwgYWxzbyBzYW5pdGl6ZXMgb3B0aW9ucyBhbmQgcHJvdmlkZXMgc2FuZSBkZWZhdWx0cyBmb3IgbWlzc2luZ1xuICogb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9hc3NlcnRBbmRTYW5pdGl6ZU9wdGlvbnMob3B0aW9ucykge1xuXG4gIG9wdGlvbnMudG1wZGlyID0gX2dldFRtcERpcihvcHRpb25zKTtcblxuICBjb25zdCB0bXBEaXIgPSBvcHRpb25zLnRtcGRpcjtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLm5hbWUpKVxuICAgIF9hc3NlcnRJc1JlbGF0aXZlKG9wdGlvbnMubmFtZSwgJ25hbWUnLCB0bXBEaXIpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLmRpcikpXG4gICAgX2Fzc2VydElzUmVsYXRpdmUob3B0aW9ucy5kaXIsICdkaXInLCB0bXBEaXIpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLnRlbXBsYXRlKSkge1xuICAgIF9hc3NlcnRJc1JlbGF0aXZlKG9wdGlvbnMudGVtcGxhdGUsICd0ZW1wbGF0ZScsIHRtcERpcik7XG4gICAgaWYgKCFvcHRpb25zLnRlbXBsYXRlLm1hdGNoKFRFTVBMQVRFX1BBVFRFUk4pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRlbXBsYXRlLCBmb3VuZCBcIiR7b3B0aW9ucy50ZW1wbGF0ZX1cIi5gKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLnRyaWVzKSAmJiBpc05hTihvcHRpb25zLnRyaWVzKSB8fCBvcHRpb25zLnRyaWVzIDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHJpZXMsIGZvdW5kIFwiJHtvcHRpb25zLnRyaWVzfVwiLmApO1xuXG4gIC8vIGlmIGEgbmFtZSB3YXMgc3BlY2lmaWVkIHdlIHdpbGwgdHJ5IG9uY2VcbiAgb3B0aW9ucy50cmllcyA9IF9pc1VuZGVmaW5lZChvcHRpb25zLm5hbWUpID8gb3B0aW9ucy50cmllcyB8fCBERUZBVUxUX1RSSUVTIDogMTtcbiAgb3B0aW9ucy5rZWVwID0gISFvcHRpb25zLmtlZXA7XG4gIG9wdGlvbnMuZGV0YWNoRGVzY3JpcHRvciA9ICEhb3B0aW9ucy5kZXRhY2hEZXNjcmlwdG9yO1xuICBvcHRpb25zLmRpc2NhcmREZXNjcmlwdG9yID0gISFvcHRpb25zLmRpc2NhcmREZXNjcmlwdG9yO1xuICBvcHRpb25zLnVuc2FmZUNsZWFudXAgPSAhIW9wdGlvbnMudW5zYWZlQ2xlYW51cDtcblxuICAvLyBzYW5pdGl6ZSBkaXIsIGFsc28ga2VlcCAobXVsdGlwbGUpIGJsYW5rcyBpZiB0aGUgdXNlciwgcHVycG9ydGVkbHkgc2FuZSwgcmVxdWVzdHMgdXMgdG9cbiAgb3B0aW9ucy5kaXIgPSBfaXNVbmRlZmluZWQob3B0aW9ucy5kaXIpID8gJycgOiBwYXRoLnJlbGF0aXZlKHRtcERpciwgX3Jlc29sdmVQYXRoKG9wdGlvbnMuZGlyLCB0bXBEaXIpKTtcbiAgb3B0aW9ucy50ZW1wbGF0ZSA9IF9pc1VuZGVmaW5lZChvcHRpb25zLnRlbXBsYXRlKSA/IHVuZGVmaW5lZCA6IHBhdGgucmVsYXRpdmUodG1wRGlyLCBfcmVzb2x2ZVBhdGgob3B0aW9ucy50ZW1wbGF0ZSwgdG1wRGlyKSk7XG4gIC8vIHNhbml0aXplIGZ1cnRoZXIgaWYgdGVtcGxhdGUgaXMgcmVsYXRpdmUgdG8gb3B0aW9ucy5kaXJcbiAgb3B0aW9ucy50ZW1wbGF0ZSA9IF9pc0JsYW5rKG9wdGlvbnMudGVtcGxhdGUpID8gdW5kZWZpbmVkIDogcGF0aC5yZWxhdGl2ZShvcHRpb25zLmRpciwgb3B0aW9ucy50ZW1wbGF0ZSk7XG5cbiAgLy8gZm9yIGNvbXBsZXRlbmVzcycgc2FrZSBvbmx5LCBhbHNvIGtlZXAgKG11bHRpcGxlKSBibGFua3MgaWYgdGhlIHVzZXIsIHB1cnBvcnRlZGx5IHNhbmUsIHJlcXVlc3RzIHVzIHRvXG4gIG9wdGlvbnMubmFtZSA9IF9pc1VuZGVmaW5lZChvcHRpb25zLm5hbWUpID8gdW5kZWZpbmVkIDogX3Nhbml0aXplTmFtZShvcHRpb25zLm5hbWUpO1xuICBvcHRpb25zLnByZWZpeCA9IF9pc1VuZGVmaW5lZChvcHRpb25zLnByZWZpeCkgPyAnJyA6IG9wdGlvbnMucHJlZml4O1xuICBvcHRpb25zLnBvc3RmaXggPSBfaXNVbmRlZmluZWQob3B0aW9ucy5wb3N0Zml4KSA/ICcnIDogb3B0aW9ucy5wb3N0Zml4O1xufVxuXG4vKipcbiAqIFJlc29sdmUgdGhlIHNwZWNpZmllZCBwYXRoIG5hbWUgaW4gcmVzcGVjdCB0byB0bXBEaXIuXG4gKlxuICogVGhlIHNwZWNpZmllZCBuYW1lIG1pZ2h0IGluY2x1ZGUgcmVsYXRpdmUgcGF0aCBjb21wb25lbnRzLCBlLmcuIC4uL1xuICogc28gd2UgbmVlZCB0byByZXNvbHZlIGluIG9yZGVyIHRvIGJlIHN1cmUgdGhhdCBpcyBpcyBsb2NhdGVkIGluc2lkZSB0bXBEaXJcbiAqXG4gKiBAcGFyYW0gbmFtZVxuICogQHBhcmFtIHRtcERpclxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZXNvbHZlUGF0aChuYW1lLCB0bXBEaXIpIHtcbiAgY29uc3Qgc2FuaXRpemVkTmFtZSA9IF9zYW5pdGl6ZU5hbWUobmFtZSk7XG4gIGlmIChzYW5pdGl6ZWROYW1lLnN0YXJ0c1dpdGgodG1wRGlyKSkge1xuICAgIHJldHVybiBwYXRoLnJlc29sdmUoc2FuaXRpemVkTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShwYXRoLmpvaW4odG1wRGlyLCBzYW5pdGl6ZWROYW1lKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgc3BlY2lmaWVkIHBhdGggbmFtZSBieSByZW1vdmluZyBhbGwgcXVvdGUgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gbmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9zYW5pdGl6ZU5hbWUobmFtZSkge1xuICBpZiAoX2lzQmxhbmsobmFtZSkpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICByZXR1cm4gbmFtZS5yZXBsYWNlKC9bXCInXS9nLCAnJyk7XG59XG5cbi8qKlxuICogQXNzZXJ0cyB3aGV0aGVyIHNwZWNpZmllZCBuYW1lIGlzIHJlbGF0aXZlIHRvIHRoZSBzcGVjaWZpZWQgdG1wRGlyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gdG1wRGlyXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9hc3NlcnRJc1JlbGF0aXZlKG5hbWUsIG9wdGlvbiwgdG1wRGlyKSB7XG4gIGlmIChvcHRpb24gPT09ICduYW1lJykge1xuICAgIC8vIGFzc2VydCB0aGF0IG5hbWUgaXMgbm90IGFic29sdXRlIGFuZCBkb2VzIG5vdCBjb250YWluIGEgcGF0aFxuICAgIGlmIChwYXRoLmlzQWJzb2x1dGUobmFtZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ufSBvcHRpb24gbXVzdCBub3QgY29udGFpbiBhbiBhYnNvbHV0ZSBwYXRoLCBmb3VuZCBcIiR7bmFtZX1cIi5gKTtcbiAgICAvLyBtdXN0IG5vdCBmYWlsIG9uIHZhbGlkIC48bmFtZT4gb3IgLi48bmFtZT4gb3Igc2ltaWxhciBzdWNoIGNvbnN0cnVjdHNcbiAgICBsZXQgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKG5hbWUpO1xuICAgIGlmIChiYXNlbmFtZSA9PT0gJy4uJyB8fCBiYXNlbmFtZSA9PT0gJy4nIHx8IGJhc2VuYW1lICE9PSBuYW1lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbn0gb3B0aW9uIG11c3Qgbm90IGNvbnRhaW4gYSBwYXRoLCBmb3VuZCBcIiR7bmFtZX1cIi5gKTtcbiAgfVxuICBlbHNlIHsgLy8gaWYgKG9wdGlvbiA9PT0gJ2RpcicgfHwgb3B0aW9uID09PSAndGVtcGxhdGUnKSB7XG4gICAgLy8gYXNzZXJ0IHRoYXQgZGlyIG9yIHRlbXBsYXRlIGFyZSByZWxhdGl2ZSB0byB0bXBEaXJcbiAgICBpZiAocGF0aC5pc0Fic29sdXRlKG5hbWUpICYmICFuYW1lLnN0YXJ0c1dpdGgodG1wRGlyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbn0gb3B0aW9uIG11c3QgYmUgcmVsYXRpdmUgdG8gXCIke3RtcERpcn1cIiwgZm91bmQgXCIke25hbWV9XCIuYCk7XG4gICAgfVxuICAgIGxldCByZXNvbHZlZFBhdGggPSBfcmVzb2x2ZVBhdGgobmFtZSwgdG1wRGlyKTtcbiAgICBpZiAoIXJlc29sdmVkUGF0aC5zdGFydHNXaXRoKHRtcERpcikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ufSBvcHRpb24gbXVzdCBiZSByZWxhdGl2ZSB0byBcIiR7dG1wRGlyfVwiLCBmb3VuZCBcIiR7cmVzb2x2ZWRQYXRofVwiLmApO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZvciB0ZXN0aW5nIGFnYWluc3QgRUJBREYgdG8gY29tcGVuc2F0ZSBjaGFuZ2VzIG1hZGUgdG8gTm9kZSA3LnggdW5kZXIgV2luZG93cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNFQkFERihlcnJvcikge1xuICByZXR1cm4gX2lzRXhwZWN0ZWRFcnJvcihlcnJvciwgLUVCQURGLCAnRUJBREYnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHRlc3RpbmcgYWdhaW5zdCBFTk9FTlQgdG8gY29tcGVuc2F0ZSBjaGFuZ2VzIG1hZGUgdG8gTm9kZSA3LnggdW5kZXIgV2luZG93cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNFTk9FTlQoZXJyb3IpIHtcbiAgcmV0dXJuIF9pc0V4cGVjdGVkRXJyb3IoZXJyb3IsIC1FTk9FTlQsICdFTk9FTlQnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGV4cGVjdGVkIGVycm9yIGNvZGUgbWF0Y2hlcyB0aGUgYWN0dWFsIGNvZGUgYW5kIGVycm5vLFxuICogd2hpY2ggd2lsbCBkaWZmZXIgYmV0d2VlbiB0aGUgc3VwcG9ydGVkIG5vZGUgdmVyc2lvbnMuXG4gKlxuICogLSBOb2RlID49IDcuMDpcbiAqICAgZXJyb3IuY29kZSB7c3RyaW5nfVxuICogICBlcnJvci5lcnJubyB7bnVtYmVyfSBhbnkgbnVtZXJpY2FsIHZhbHVlIHdpbGwgYmUgbmVnYXRlZFxuICpcbiAqIENBVkVBVFxuICpcbiAqIE9uIHdpbmRvd3MsIHRoZSBlcnJubyBmb3IgRUJBREYgaXMgLTQwODMgYnV0IG9zLmNvbnN0YW50cy5lcnJuby5FQkFERiBpcyBkaWZmZXJlbnQgYW5kIHdlIG11c3QgYXNzdW1lIHRoYXQgRU5PRU5UXG4gKiBpcyBubyBkaWZmZXJlbnQgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge1N5c3RlbUVycm9yfSBlcnJvclxuICogQHBhcmFtIHtudW1iZXJ9IGVycm5vXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lzRXhwZWN0ZWRFcnJvcihlcnJvciwgZXJybm8sIGNvZGUpIHtcbiAgcmV0dXJuIElTX1dJTjMyID8gZXJyb3IuY29kZSA9PT0gY29kZSA6IGVycm9yLmNvZGUgPT09IGNvZGUgJiYgZXJyb3IuZXJybm8gPT09IGVycm5vO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGdyYWNlZnVsIGNsZWFudXAuXG4gKlxuICogSWYgZ3JhY2VmdWwgY2xlYW51cCBpcyBzZXQsIHRtcCB3aWxsIHJlbW92ZSBhbGwgY29udHJvbGxlZCB0ZW1wb3Jhcnkgb2JqZWN0cyBvbiBwcm9jZXNzIGV4aXQsIG90aGVyd2lzZSB0aGVcbiAqIHRlbXBvcmFyeSBvYmplY3RzIHdpbGwgcmVtYWluIGluIHBsYWNlLCB3YWl0aW5nIHRvIGJlIGNsZWFuZWQgdXAgb24gc3lzdGVtIHJlc3RhcnQgb3Igb3RoZXJ3aXNlIHNjaGVkdWxlZCB0ZW1wb3JhcnlcbiAqIG9iamVjdCByZW1vdmFscy5cbiAqL1xuZnVuY3Rpb24gc2V0R3JhY2VmdWxDbGVhbnVwKCkge1xuICBfZ3JhY2VmdWxDbGVhbnVwID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgY29uZmlndXJlZCB0bXAgZGlyIGZyb20gb3MudG1wZGlyKCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7P09wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjdXJyZW50bHkgY29uZmlndXJlZCB0bXAgZGlyXG4gKi9cbmZ1bmN0aW9uIF9nZXRUbXBEaXIob3B0aW9ucykge1xuICByZXR1cm4gcGF0aC5yZXNvbHZlKF9zYW5pdGl6ZU5hbWUob3B0aW9ucyAmJiBvcHRpb25zLnRtcGRpciB8fCBvcy50bXBkaXIoKSkpO1xufVxuXG4vLyBJbnN0YWxsIHByb2Nlc3MgZXhpdCBsaXN0ZW5lclxucHJvY2Vzcy5hZGRMaXN0ZW5lcihFWElULCBfZ2FyYmFnZUNvbGxlY3Rvcik7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGtlZXAgdGhlIHRlbXBvcmFyeSBvYmplY3QgKGZpbGUgb3IgZGlyKSB3aWxsIG5vdCBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICogQHByb3BlcnR5IHs/bnVtYmVyfSB0cmllcyB0aGUgbnVtYmVyIG9mIHRyaWVzIGJlZm9yZSBnaXZlIHVwIHRoZSBuYW1lIGdlbmVyYXRpb25cbiAqIEBwcm9wZXJ0eSAoP2ludCkgbW9kZSB0aGUgYWNjZXNzIG1vZGUsIGRlZmF1bHRzIGFyZSAwbzcwMCBmb3IgZGlyZWN0b3JpZXMgYW5kIDBvNjAwIGZvciBmaWxlc1xuICogQHByb3BlcnR5IHs/c3RyaW5nfSB0ZW1wbGF0ZSB0aGUgXCJta3N0ZW1wXCIgbGlrZSBmaWxlbmFtZSB0ZW1wbGF0ZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBuYW1lIGZpeGVkIG5hbWUgcmVsYXRpdmUgdG8gdG1wZGlyIG9yIHRoZSBzcGVjaWZpZWQgZGlyIG9wdGlvblxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBkaXIgdG1wIGRpcmVjdG9yeSByZWxhdGl2ZSB0byB0aGUgcm9vdCB0bXAgZGlyZWN0b3J5IGluIHVzZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBwcmVmaXggcHJlZml4IGZvciB0aGUgZ2VuZXJhdGVkIG5hbWVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcG9zdGZpeCBwb3N0Zml4IGZvciB0aGUgZ2VuZXJhdGVkIG5hbWVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdG1wZGlyIHRoZSByb290IHRtcCBkaXJlY3Rvcnkgd2hpY2ggb3ZlcnJpZGVzIHRoZSBvcyB0bXBkaXJcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHVuc2FmZUNsZWFudXAgcmVjdXJzaXZlbHkgcmVtb3ZlcyB0aGUgY3JlYXRlZCB0ZW1wb3JhcnkgZGlyZWN0b3J5LCBldmVuIHdoZW4gaXQncyBub3QgZW1wdHlcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGRldGFjaERlc2NyaXB0b3IgZGV0YWNoZXMgdGhlIGZpbGUgZGVzY3JpcHRvciwgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBjbG9zaW5nIHRoZSBmaWxlLCB0bXAgd2lsbCBubyBsb25nZXIgdHJ5IGNsb3NpbmcgdGhlIGZpbGUgZHVyaW5nIGdhcmJhZ2UgY29sbGVjdGlvblxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gZGlzY2FyZERlc2NyaXB0b3IgZGlzY2FyZHMgdGhlIGZpbGUgZGVzY3JpcHRvciAoY2xvc2VzIGZpbGUsIGZkIGlzIC0xKSwgdG1wIHdpbGwgbm8gbG9uZ2VyIHRyeSBjbG9zaW5nIHRoZSBmaWxlIGR1cmluZyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbGVTeW5jT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZkIHRoZSBmaWxlIGRlc2NyaXB0b3Igb3IgLTEgaWYgdGhlIGZkIGhhcyBiZWVuIGRpc2NhcmRlZFxuICogQHByb3BlcnR5IHtmaWxlQ2FsbGJhY2t9IHJlbW92ZUNhbGxiYWNrIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byByZW1vdmUgdGhlIGZpbGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERpclN5bmNPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnlcbiAqIEBwcm9wZXJ0eSB7ZmlsZUNhbGxiYWNrfSByZW1vdmVDYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoZSBkaXJlY3RvcnlcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayB0bXBOYW1lQ2FsbGJhY2tcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbGVDYWxsYmFja1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciB0aGUgZXJyb3Igb2JqZWN0IGlmIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB0ZW1wb3JhcnkgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgdGhlIGZpbGUgZGVzY3JpcHRvciBvciAtMSBpZiB0aGUgZmQgaGFkIGJlZW4gZGlzY2FyZGVkXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBmaWxlQ2FsbGJhY2tTeW5jXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCB0aGUgZmlsZSBkZXNjcmlwdG9yIG9yIC0xIGlmIHRoZSBmZCBoYWQgYmVlbiBkaXNjYXJkZWRcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrU3luY30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBkaXJDYWxsYmFja1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciB0aGUgZXJyb3Igb2JqZWN0IGlmIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB0ZW1wb3JhcnkgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBkaXJDYWxsYmFja1N5bmNcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2tTeW5jfSBmbiB0aGUgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgdGVtcG9yYXJ5IGNyZWF0ZWQgZmlsZSBvciBkaXJlY3RvcnkuXG4gKlxuICogQGNhbGxiYWNrIGNsZWFudXBDYWxsYmFja1xuICogQHBhcmFtIHtzaW1wbGVDYWxsYmFja30gW25leHRdIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbmV2ZXIgdGhlIHRtcCBvYmplY3QgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgdGVtcG9yYXJ5IGNyZWF0ZWQgZmlsZSBvciBkaXJlY3RvcnkuXG4gKlxuICogQGNhbGxiYWNrIGNsZWFudXBDYWxsYmFja1N5bmNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBmdW5jdGlvbiBjb21wb3NpdGlvbi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9yYXN6aS9ub2RlLXRtcC9pc3N1ZXMvNTd8cmFzemkvbm9kZS10bXAjNTd9XG4gKlxuICogQGNhbGxiYWNrIHNpbXBsZUNhbGxiYWNrXG4gKi9cblxuLy8gZXhwb3J0aW5nIGFsbCB0aGUgbmVlZGVkIG1ldGhvZHNcblxuLy8gZXZhbHVhdGUgX2dldFRtcERpcigpIGxhemlseSwgbWFpbmx5IGZvciBzaW1wbGlmeWluZyB0ZXN0aW5nIGJ1dCBpdCBhbHNvIHdpbGxcbi8vIGFsbG93IHVzZXJzIHRvIHJlY29uZmlndXJlIHRoZSB0ZW1wb3JhcnkgZGlyZWN0b3J5XG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICd0bXBkaXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZ2V0VG1wRGlyKCk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5kaXIgPSBkaXI7XG5tb2R1bGUuZXhwb3J0cy5kaXJTeW5jID0gZGlyU3luYztcblxubW9kdWxlLmV4cG9ydHMuZmlsZSA9IGZpbGU7XG5tb2R1bGUuZXhwb3J0cy5maWxlU3luYyA9IGZpbGVTeW5jO1xuXG5tb2R1bGUuZXhwb3J0cy50bXBOYW1lID0gdG1wTmFtZTtcbm1vZHVsZS5leHBvcnRzLnRtcE5hbWVTeW5jID0gdG1wTmFtZVN5bmM7XG5cbm1vZHVsZS5leHBvcnRzLnNldEdyYWNlZnVsQ2xlYW51cCA9IHNldEdyYWNlZnVsQ2xlYW51cDtcbiJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJvcyIsInBhdGgiLCJjcnlwdG8iLCJfYyIsImNvbnN0YW50cyIsInJpbXJhZiIsIlJBTkRPTV9DSEFSUyIsIlRFTVBMQVRFX1BBVFRFUk4iLCJERUZBVUxUX1RSSUVTIiwiQ1JFQVRFX0ZMQUdTIiwiT19DUkVBVCIsIk9fRVhDTCIsIk9fUkRXUiIsIklTX1dJTjMyIiwicGxhdGZvcm0iLCJFQkFERiIsImVycm5vIiwiRU5PRU5UIiwiRElSX01PREUiLCJGSUxFX01PREUiLCJFWElUIiwiX3JlbW92ZU9iamVjdHMiLCJGTl9STURJUl9TWU5DIiwicm1kaXJTeW5jIiwiYmluZCIsIkZOX1JJTVJBRl9TWU5DIiwic3luYyIsIl9ncmFjZWZ1bENsZWFudXAiLCJ0bXBOYW1lIiwib3B0aW9ucyIsImNhbGxiYWNrIiwiYXJncyIsIl9wYXJzZUFyZ3VtZW50cyIsIm9wdHMiLCJjYiIsIl9hc3NlcnRBbmRTYW5pdGl6ZU9wdGlvbnMiLCJlcnIiLCJ0cmllcyIsIl9nZXRVbmlxdWVOYW1lIiwibmFtZSIsIl9nZW5lcmF0ZVRtcE5hbWUiLCJzdGF0IiwiRXJyb3IiLCJ0bXBOYW1lU3luYyIsInN0YXRTeW5jIiwiZSIsImZpbGUiLCJfdG1wTmFtZUNyZWF0ZWQiLCJvcGVuIiwibW9kZSIsIl9maWxlQ3JlYXRlZCIsImZkIiwiZGlzY2FyZERlc2NyaXB0b3IiLCJjbG9zZSIsIl9kaXNjYXJkQ2FsbGJhY2siLCJwb3NzaWJsZUVyciIsInVuZGVmaW5lZCIsIl9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrIiwiZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciIsImRldGFjaERlc2NyaXB0b3IiLCJmaWxlU3luYyIsIm9wZW5TeW5jIiwiY2xvc2VTeW5jIiwicmVtb3ZlQ2FsbGJhY2siLCJkaXIiLCJta2RpciIsIl9kaXJDcmVhdGVkIiwiX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayIsImRpclN5bmMiLCJta2RpclN5bmMiLCJfcmVtb3ZlRmlsZUFzeW5jIiwiZmRQYXRoIiwibmV4dCIsIl9oYW5kbGVyIiwiX2lzRU5PRU5UIiwidW5saW5rIiwiX3JlbW92ZUZpbGVTeW5jIiwicmV0aHJvd25FeGNlcHRpb24iLCJfaXNFQkFERiIsInVubGlua1N5bmMiLCJyZW1vdmVDYWxsYmFja1N5bmMiLCJfcHJlcGFyZVJlbW92ZUNhbGxiYWNrIiwia2VlcCIsInVuc2hpZnQiLCJyZW1vdmVGdW5jdGlvbiIsInVuc2FmZUNsZWFudXAiLCJybWRpciIsInJlbW92ZUZ1bmN0aW9uU3luYyIsImZpbGVPckRpck5hbWUiLCJjbGVhbnVwQ2FsbGJhY2tTeW5jIiwiY2FsbGVkIiwiX2NsZWFudXBDYWxsYmFjayIsInRvUmVtb3ZlIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiX2dhcmJhZ2VDb2xsZWN0b3IiLCJsZW5ndGgiLCJfcmFuZG9tQ2hhcnMiLCJob3dNYW55IiwidmFsdWUiLCJybmQiLCJyYW5kb21CeXRlcyIsInBzZXVkb1JhbmRvbUJ5dGVzIiwiaSIsInB1c2giLCJqb2luIiwiX2lzQmxhbmsiLCJzIiwiX2lzVW5kZWZpbmVkIiwidHJpbSIsIm9iaiIsImFjdHVhbE9wdGlvbnMiLCJrZXkiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidG1wRGlyIiwidG1wZGlyIiwidGVtcGxhdGUiLCJyZXBsYWNlIiwicHJlZml4IiwicHJvY2VzcyIsInBpZCIsInBvc3RmaXgiLCJfZ2V0VG1wRGlyIiwiX2Fzc2VydElzUmVsYXRpdmUiLCJtYXRjaCIsImlzTmFOIiwicmVsYXRpdmUiLCJfcmVzb2x2ZVBhdGgiLCJfc2FuaXRpemVOYW1lIiwic2FuaXRpemVkTmFtZSIsInN0YXJ0c1dpdGgiLCJyZXNvbHZlIiwib3B0aW9uIiwiaXNBYnNvbHV0ZSIsImJhc2VuYW1lIiwicmVzb2x2ZWRQYXRoIiwiZXJyb3IiLCJfaXNFeHBlY3RlZEVycm9yIiwiY29kZSIsInNldEdyYWNlZnVsQ2xlYW51cCIsImFkZExpc3RlbmVyIiwiZGVmaW5lUHJvcGVydHkiLCJtb2R1bGUiLCJleHBvcnRzIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImdldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tmp/lib/tmp.js\n");

/***/ })

};
;