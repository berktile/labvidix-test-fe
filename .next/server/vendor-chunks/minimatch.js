/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minimatch";
exports.ids = ["vendor-chunks/minimatch"];
exports.modules = {

/***/ "(ssr)/./node_modules/minimatch/minimatch.js":
/*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = minimatch;\nminimatch.Minimatch = Minimatch;\nvar path = function() {\n    try {\n        return __webpack_require__(/*! path */ \"path\");\n    } catch (e) {}\n}() || {\n    sep: \"/\"\n};\nminimatch.sep = path.sep;\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\nvar expand = __webpack_require__(/*! brace-expansion */ \"(ssr)/./node_modules/brace-expansion/index.js\");\nvar plTypes = {\n    \"!\": {\n        open: \"(?:(?!(?:\",\n        close: \"))[^/]*?)\"\n    },\n    \"?\": {\n        open: \"(?:\",\n        close: \")?\"\n    },\n    \"+\": {\n        open: \"(?:\",\n        close: \")+\"\n    },\n    \"*\": {\n        open: \"(?:\",\n        close: \")*\"\n    },\n    \"@\": {\n        open: \"(?:\",\n        close: \")\"\n    }\n};\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = \"[^/]\";\n// * => any number of characters\nvar star = qmark + \"*?\";\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet(\"().*{}+?[]^$\\\\!\");\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet(s) {\n    return s.split(\"\").reduce(function(set, c) {\n        set[c] = true;\n        return set;\n    }, {});\n}\n// normalizes slashes.\nvar slashSplit = /\\/+/;\nminimatch.filter = filter;\nfunction filter(pattern, options) {\n    options = options || {};\n    return function(p, i, list) {\n        return minimatch(p, pattern, options);\n    };\n}\nfunction ext(a, b) {\n    b = b || {};\n    var t = {};\n    Object.keys(a).forEach(function(k) {\n        t[k] = a[k];\n    });\n    Object.keys(b).forEach(function(k) {\n        t[k] = b[k];\n    });\n    return t;\n}\nminimatch.defaults = function(def) {\n    if (!def || typeof def !== \"object\" || !Object.keys(def).length) {\n        return minimatch;\n    }\n    var orig = minimatch;\n    var m = function minimatch(p, pattern, options) {\n        return orig(p, pattern, ext(def, options));\n    };\n    m.Minimatch = function Minimatch(pattern, options) {\n        return new orig.Minimatch(pattern, ext(def, options));\n    };\n    m.Minimatch.defaults = function defaults(options) {\n        return orig.defaults(ext(def, options)).Minimatch;\n    };\n    m.filter = function filter(pattern, options) {\n        return orig.filter(pattern, ext(def, options));\n    };\n    m.defaults = function defaults(options) {\n        return orig.defaults(ext(def, options));\n    };\n    m.makeRe = function makeRe(pattern, options) {\n        return orig.makeRe(pattern, ext(def, options));\n    };\n    m.braceExpand = function braceExpand(pattern, options) {\n        return orig.braceExpand(pattern, ext(def, options));\n    };\n    m.match = function(list, pattern, options) {\n        return orig.match(list, pattern, ext(def, options));\n    };\n    return m;\n};\nMinimatch.defaults = function(def) {\n    return minimatch.defaults(def).Minimatch;\n};\nfunction minimatch(p, pattern, options) {\n    assertValidPattern(pattern);\n    if (!options) options = {};\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n}\nfunction Minimatch(pattern, options) {\n    if (!(this instanceof Minimatch)) {\n        return new Minimatch(pattern, options);\n    }\n    assertValidPattern(pattern);\n    if (!options) options = {};\n    pattern = pattern.trim();\n    // windows support: need to use /, not \\\n    if (!options.allowWindowsEscape && path.sep !== \"/\") {\n        pattern = pattern.split(path.sep).join(\"/\");\n    }\n    this.options = options;\n    this.set = [];\n    this.pattern = pattern;\n    this.regexp = null;\n    this.negate = false;\n    this.comment = false;\n    this.empty = false;\n    this.partial = !!options.partial;\n    // make the set of regexps etc.\n    this.make();\n}\nMinimatch.prototype.debug = function() {};\nMinimatch.prototype.make = make;\nfunction make() {\n    var pattern = this.pattern;\n    var options = this.options;\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        this.comment = true;\n        return;\n    }\n    if (!pattern) {\n        this.empty = true;\n        return;\n    }\n    // step 1: figure out negation, etc.\n    this.parseNegate();\n    // step 2: expand braces\n    var set = this.globSet = this.braceExpand();\n    if (options.debug) this.debug = function debug() {\n        console.error.apply(console, arguments);\n    };\n    this.debug(this.pattern, set);\n    // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    set = this.globParts = set.map(function(s) {\n        return s.split(slashSplit);\n    });\n    this.debug(this.pattern, set);\n    // glob --> regexps\n    set = set.map(function(s, si, set) {\n        return s.map(this.parse, this);\n    }, this);\n    this.debug(this.pattern, set);\n    // filter out everything that didn't compile properly.\n    set = set.filter(function(s) {\n        return s.indexOf(false) === -1;\n    });\n    this.debug(this.pattern, set);\n    this.set = set;\n}\nMinimatch.prototype.parseNegate = parseNegate;\nfunction parseNegate() {\n    var pattern = this.pattern;\n    var negate = false;\n    var options = this.options;\n    var negateOffset = 0;\n    if (options.nonegate) return;\n    for(var i = 0, l = pattern.length; i < l && pattern.charAt(i) === \"!\"; i++){\n        negate = !negate;\n        negateOffset++;\n    }\n    if (negateOffset) this.pattern = pattern.substr(negateOffset);\n    this.negate = negate;\n}\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function(pattern, options) {\n    return braceExpand(pattern, options);\n};\nMinimatch.prototype.braceExpand = braceExpand;\nfunction braceExpand(pattern, options) {\n    if (!options) {\n        if (this instanceof Minimatch) {\n            options = this.options;\n        } else {\n            options = {};\n        }\n    }\n    pattern = typeof pattern === \"undefined\" ? this.pattern : pattern;\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [\n            pattern\n        ];\n    }\n    return expand(pattern);\n}\nvar MAX_PATTERN_LENGTH = 1024 * 64;\nvar assertValidPattern = function(pattern) {\n    if (typeof pattern !== \"string\") {\n        throw new TypeError(\"invalid pattern\");\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError(\"pattern is too long\");\n    }\n};\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse;\nvar SUBPARSE = {};\nfunction parse(pattern, isSub) {\n    assertValidPattern(pattern);\n    var options = this.options;\n    // shortcuts\n    if (pattern === \"**\") {\n        if (!options.noglobstar) return GLOBSTAR;\n        else pattern = \"*\";\n    }\n    if (pattern === \"\") return \"\";\n    var re = \"\";\n    var hasMagic = !!options.nocase;\n    var escaping = false;\n    // ? => one single character\n    var patternListStack = [];\n    var negativeLists = [];\n    var stateChar;\n    var inClass = false;\n    var reClassStart = -1;\n    var classStart = -1;\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.\n    var patternStart = pattern.charAt(0) === \".\" ? \"\" // anything\n     : options.dot ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";\n    var self = this;\n    function clearStateChar() {\n        if (stateChar) {\n            // we had some state-tracking character\n            // that wasn't consumed by this pass.\n            switch(stateChar){\n                case \"*\":\n                    re += star;\n                    hasMagic = true;\n                    break;\n                case \"?\":\n                    re += qmark;\n                    hasMagic = true;\n                    break;\n                default:\n                    re += \"\\\\\" + stateChar;\n                    break;\n            }\n            self.debug(\"clearStateChar %j %j\", stateChar, re);\n            stateChar = false;\n        }\n    }\n    for(var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++){\n        this.debug(\"%s\t%s %s %j\", pattern, i, re, c);\n        // skip over any that are escaped.\n        if (escaping && reSpecials[c]) {\n            re += \"\\\\\" + c;\n            escaping = false;\n            continue;\n        }\n        switch(c){\n            /* istanbul ignore next */ case \"/\":\n                {\n                    // completely not allowed, even escaped.\n                    // Should already be path-split by now.\n                    return false;\n                }\n            case \"\\\\\":\n                clearStateChar();\n                escaping = true;\n                continue;\n            // the various stateChar values\n            // for the \"extglob\" stuff.\n            case \"?\":\n            case \"*\":\n            case \"+\":\n            case \"@\":\n            case \"!\":\n                this.debug(\"%s\t%s %s %j <-- stateChar\", pattern, i, re, c);\n                // all of those are literals inside a class, except that\n                // the glob [!a] means [^a] in regexp\n                if (inClass) {\n                    this.debug(\"  in class\");\n                    if (c === \"!\" && i === classStart + 1) c = \"^\";\n                    re += c;\n                    continue;\n                }\n                // if we already have a stateChar, then it means\n                // that there was something like ** or +? in there.\n                // Handle the stateChar, then proceed with this one.\n                self.debug(\"call clearStateChar %j\", stateChar);\n                clearStateChar();\n                stateChar = c;\n                // if extglob is disabled, then +(asdf|foo) isn't a thing.\n                // just clear the statechar *now*, rather than even diving into\n                // the patternList stuff.\n                if (options.noext) clearStateChar();\n                continue;\n            case \"(\":\n                if (inClass) {\n                    re += \"(\";\n                    continue;\n                }\n                if (!stateChar) {\n                    re += \"\\\\(\";\n                    continue;\n                }\n                patternListStack.push({\n                    type: stateChar,\n                    start: i - 1,\n                    reStart: re.length,\n                    open: plTypes[stateChar].open,\n                    close: plTypes[stateChar].close\n                });\n                // negation is (?:(?!js)[^/]*)\n                re += stateChar === \"!\" ? \"(?:(?!(?:\" : \"(?:\";\n                this.debug(\"plType %j %j\", stateChar, re);\n                stateChar = false;\n                continue;\n            case \")\":\n                if (inClass || !patternListStack.length) {\n                    re += \"\\\\)\";\n                    continue;\n                }\n                clearStateChar();\n                hasMagic = true;\n                var pl = patternListStack.pop();\n                // negation is (?:(?!js)[^/]*)\n                // The others are (?:<pattern>)<type>\n                re += pl.close;\n                if (pl.type === \"!\") {\n                    negativeLists.push(pl);\n                }\n                pl.reEnd = re.length;\n                continue;\n            case \"|\":\n                if (inClass || !patternListStack.length || escaping) {\n                    re += \"\\\\|\";\n                    escaping = false;\n                    continue;\n                }\n                clearStateChar();\n                re += \"|\";\n                continue;\n            // these are mostly the same in regexp and glob\n            case \"[\":\n                // swallow any state-tracking char before the [\n                clearStateChar();\n                if (inClass) {\n                    re += \"\\\\\" + c;\n                    continue;\n                }\n                inClass = true;\n                classStart = i;\n                reClassStart = re.length;\n                re += c;\n                continue;\n            case \"]\":\n                //  a right bracket shall lose its special\n                //  meaning and represent itself in\n                //  a bracket expression if it occurs\n                //  first in the list.  -- POSIX.2 2.8.3.2\n                if (i === classStart + 1 || !inClass) {\n                    re += \"\\\\\" + c;\n                    escaping = false;\n                    continue;\n                }\n                // handle the case where we left a class open.\n                // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n                // split where the last [ was, make sure we don't have\n                // an invalid re. if so, re-walk the contents of the\n                // would-be class to re-translate any characters that\n                // were passed through as-is\n                // TODO: It would probably be faster to determine this\n                // without a try/catch and a new RegExp, but it's tricky\n                // to do safely.  For now, this is safe and works.\n                var cs = pattern.substring(classStart + 1, i);\n                try {\n                    RegExp(\"[\" + cs + \"]\");\n                } catch (er) {\n                    // not a valid class!\n                    var sp = this.parse(cs, SUBPARSE);\n                    re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0] + \"\\\\]\";\n                    hasMagic = hasMagic || sp[1];\n                    inClass = false;\n                    continue;\n                }\n                // finish up the class.\n                hasMagic = true;\n                inClass = false;\n                re += c;\n                continue;\n            default:\n                // swallow any state char that wasn't consumed\n                clearStateChar();\n                if (escaping) {\n                    // no need\n                    escaping = false;\n                } else if (reSpecials[c] && !(c === \"^\" && inClass)) {\n                    re += \"\\\\\";\n                }\n                re += c;\n        } // switch\n    } // for\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n    if (inClass) {\n        // split where the last [ was, and escape it\n        // this is a huge pita.  We now have to re-walk\n        // the contents of the would-be class to re-translate\n        // any characters that were passed through as-is\n        cs = pattern.substr(classStart + 1);\n        sp = this.parse(cs, SUBPARSE);\n        re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0];\n        hasMagic = hasMagic || sp[1];\n    }\n    // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n    for(pl = patternListStack.pop(); pl; pl = patternListStack.pop()){\n        var tail = re.slice(pl.reStart + pl.open.length);\n        this.debug(\"setting tail\", re, pl);\n        // maybe some even number of \\, then maybe 1 \\, followed by a |\n        tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function(_, $1, $2) {\n            if (!$2) {\n                // the | isn't already escaped, so escape it.\n                $2 = \"\\\\\";\n            }\n            // need to escape all those slashes *again*, without escaping the\n            // one that we need for escaping the | character.  As it works out,\n            // escaping an even number of slashes can be done by simply repeating\n            // it exactly after itself.  That's why this trick works.\n            //\n            // I am sorry that you have to see this.\n            return $1 + $1 + $2 + \"|\";\n        });\n        this.debug(\"tail=%j\\n   %s\", tail, tail, pl, re);\n        var t = pl.type === \"*\" ? star : pl.type === \"?\" ? qmark : \"\\\\\" + pl.type;\n        hasMagic = true;\n        re = re.slice(0, pl.reStart) + t + \"\\\\(\" + tail;\n    }\n    // handle trailing things that only matter at the very end.\n    clearStateChar();\n    if (escaping) {\n        // trailing \\\\\n        re += \"\\\\\\\\\";\n    }\n    // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n    var addPatternStart = false;\n    switch(re.charAt(0)){\n        case \"[\":\n        case \".\":\n        case \"(\":\n            addPatternStart = true;\n    }\n    // Hack to work around lack of negative lookbehind in JS\n    // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n    // like 'a.xyz.yz' doesn't match.  So, the first negative\n    // lookahead, has to look ALL the way ahead, to the end of\n    // the pattern.\n    for(var n = negativeLists.length - 1; n > -1; n--){\n        var nl = negativeLists[n];\n        var nlBefore = re.slice(0, nl.reStart);\n        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);\n        var nlAfter = re.slice(nl.reEnd);\n        nlLast += nlAfter;\n        // Handle nested stuff like *(*.js|!(*.json)), where open parens\n        // mean that we should *not* include the ) in the bit that is considered\n        // \"after\" the negated section.\n        var openParensBefore = nlBefore.split(\"(\").length - 1;\n        var cleanAfter = nlAfter;\n        for(i = 0; i < openParensBefore; i++){\n            cleanAfter = cleanAfter.replace(/\\)[+*?]?/, \"\");\n        }\n        nlAfter = cleanAfter;\n        var dollar = \"\";\n        if (nlAfter === \"\" && isSub !== SUBPARSE) {\n            dollar = \"$\";\n        }\n        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n        re = newRe;\n    }\n    // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n    if (re !== \"\" && hasMagic) {\n        re = \"(?=.)\" + re;\n    }\n    if (addPatternStart) {\n        re = patternStart + re;\n    }\n    // parsing just a piece of a larger pattern.\n    if (isSub === SUBPARSE) {\n        return [\n            re,\n            hasMagic\n        ];\n    }\n    // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n    if (!hasMagic) {\n        return globUnescape(pattern);\n    }\n    var flags = options.nocase ? \"i\" : \"\";\n    try {\n        var regExp = new RegExp(\"^\" + re + \"$\", flags);\n    } catch (er) /* istanbul ignore next - should be impossible */ {\n        // If it was an invalid regular expression, then it can't match\n        // anything.  This trick looks for a character after the end of\n        // the string, which is of course impossible, except in multi-line\n        // mode, but it's not a /m regex.\n        return new RegExp(\"$.\");\n    }\n    regExp._glob = pattern;\n    regExp._src = re;\n    return regExp;\n}\nminimatch.makeRe = function(pattern, options) {\n    return new Minimatch(pattern, options || {}).makeRe();\n};\nMinimatch.prototype.makeRe = makeRe;\nfunction makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp;\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    var set = this.set;\n    if (!set.length) {\n        this.regexp = false;\n        return this.regexp;\n    }\n    var options = this.options;\n    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    var flags = options.nocase ? \"i\" : \"\";\n    var re = set.map(function(pattern) {\n        return pattern.map(function(p) {\n            return p === GLOBSTAR ? twoStar : typeof p === \"string\" ? regExpEscape(p) : p._src;\n        }).join(\"\\\\/\");\n    }).join(\"|\");\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = \"^(?:\" + re + \")$\";\n    // can match anything, as long as it's not this.\n    if (this.negate) re = \"^(?!\" + re + \").*$\";\n    try {\n        this.regexp = new RegExp(re, flags);\n    } catch (ex) /* istanbul ignore next - should be impossible */ {\n        this.regexp = false;\n    }\n    return this.regexp;\n}\nminimatch.match = function(list, pattern, options) {\n    options = options || {};\n    var mm = new Minimatch(pattern, options);\n    list = list.filter(function(f) {\n        return mm.match(f);\n    });\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nMinimatch.prototype.match = function match(f, partial) {\n    if (typeof partial === \"undefined\") partial = this.partial;\n    this.debug(\"match\", f, this.pattern);\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) return false;\n    if (this.empty) return f === \"\";\n    if (f === \"/\" && partial) return true;\n    var options = this.options;\n    // windows: need to use /, not \\\n    if (path.sep !== \"/\") {\n        f = f.split(path.sep).join(\"/\");\n    }\n    // treat the test path as a set of pathparts.\n    f = f.split(slashSplit);\n    this.debug(this.pattern, \"split\", f);\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n    var set = this.set;\n    this.debug(this.pattern, \"set\", set);\n    // Find the basename of the path by looking for the last non-empty segment\n    var filename;\n    var i;\n    for(i = f.length - 1; i >= 0; i--){\n        filename = f[i];\n        if (filename) break;\n    }\n    for(i = 0; i < set.length; i++){\n        var pattern = set[i];\n        var file = f;\n        if (options.matchBase && pattern.length === 1) {\n            file = [\n                filename\n            ];\n        }\n        var hit = this.matchOne(file, pattern, partial);\n        if (hit) {\n            if (options.flipNegate) return true;\n            return !this.negate;\n        }\n    }\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) return false;\n    return this.negate;\n};\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function(file, pattern, partial) {\n    var options = this.options;\n    this.debug(\"matchOne\", {\n        \"this\": this,\n        file: file,\n        pattern: pattern\n    });\n    this.debug(\"matchOne\", file.length, pattern.length);\n    for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){\n        this.debug(\"matchOne loop\");\n        var p = pattern[pi];\n        var f = file[fi];\n        this.debug(pattern, p, f);\n        // should be impossible.\n        // some invalid regexp stuff in the set.\n        /* istanbul ignore if */ if (p === false) return false;\n        if (p === GLOBSTAR) {\n            this.debug(\"GLOBSTAR\", [\n                pattern,\n                p,\n                f\n            ]);\n            // \"**\"\n            // a/**/b/**/c would match the following:\n            // a/b/x/y/z/c\n            // a/x/y/z/b/c\n            // a/b/x/b/x/c\n            // a/b/c\n            // To do this, take the rest of the pattern after\n            // the **, and see if it would match the file remainder.\n            // If so, return success.\n            // If not, the ** \"swallows\" a segment, and try again.\n            // This is recursively awful.\n            //\n            // a/**/b/**/c matching a/b/x/y/z/c\n            // - a matches a\n            // - doublestar\n            //   - matchOne(b/x/y/z/c, b/**/c)\n            //     - b matches b\n            //     - doublestar\n            //       - matchOne(x/y/z/c, c) -> no\n            //       - matchOne(y/z/c, c) -> no\n            //       - matchOne(z/c, c) -> no\n            //       - matchOne(c, c) yes, hit\n            var fr = fi;\n            var pr = pi + 1;\n            if (pr === pl) {\n                this.debug(\"** at the end\");\n                // a ** at the end will just swallow the rest.\n                // We have found a match.\n                // however, it will not swallow /.x, unless\n                // options.dot is set.\n                // . and .. are *never* matched by **, for explosively\n                // exponential reasons.\n                for(; fi < fl; fi++){\n                    if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\") return false;\n                }\n                return true;\n            }\n            // ok, let's see if we can swallow whatever we can.\n            while(fr < fl){\n                var swallowee = file[fr];\n                this.debug(\"\\nglobstar while\", file, fr, pattern, pr, swallowee);\n                // XXX remove this slice.  Just pass the start index.\n                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                    this.debug(\"globstar found match!\", fr, fl, swallowee);\n                    // found a match.\n                    return true;\n                } else {\n                    // can't swallow \".\" or \"..\" ever.\n                    // can only swallow \".foo\" when explicitly asked.\n                    if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {\n                        this.debug(\"dot detected!\", file, fr, pattern, pr);\n                        break;\n                    }\n                    // ** swallows a segment, and continue.\n                    this.debug(\"globstar swallow a segment, and continue\");\n                    fr++;\n                }\n            }\n            // no match was found.\n            // However, in partial mode, we can't say this is necessarily over.\n            // If there's more *pattern* left, then\n            /* istanbul ignore if */ if (partial) {\n                // ran out of file\n                this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);\n                if (fr === fl) return true;\n            }\n            return false;\n        }\n        // something other than **\n        // non-magic patterns just have to match exactly\n        // patterns with magic have been turned into regexps.\n        var hit;\n        if (typeof p === \"string\") {\n            hit = f === p;\n            this.debug(\"string match\", p, f, hit);\n        } else {\n            hit = f.match(p);\n            this.debug(\"pattern match\", p, f, hit);\n        }\n        if (!hit) return false;\n    }\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n        // ran out of pattern and filename at the same time.\n        // an exact hit!\n        return true;\n    } else if (fi === fl) {\n        // ran out of file, but still had pattern left.\n        // this is ok if we're doing the match as part of\n        // a glob fs traversal.\n        return partial;\n    } else /* istanbul ignore else */ if (pi === pl) {\n        // ran out of pattern, still have file left.\n        // this is only acceptable if we're on the very last\n        // empty segment of a file with a trailing slash.\n        // a/* should match a/b/\n        return fi === fl - 1 && file[fi] === \"\";\n    }\n    // should be unreachable.\n    /* istanbul ignore next */ throw new Error(\"wtf?\");\n};\n// replace stuff like \\* with *\nfunction globUnescape(s) {\n    return s.replace(/\\\\(.)/g, \"$1\");\n}\nfunction regExpEscape(s) {\n    return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL21pbmltYXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHQztBQUNqQkEsVUFBVUMsU0FBUyxHQUFHQTtBQUV0QixJQUFJQyxPQUFPO0lBQWUsSUFBSTtRQUFFLE9BQU9DLG1CQUFPQSxDQUFDO0lBQVEsRUFBRSxPQUFPQyxHQUFHLENBQUM7QUFBQyxPQUFRO0lBQzNFQyxLQUFLO0FBQ1A7QUFDQUwsVUFBVUssR0FBRyxHQUFHSCxLQUFLRyxHQUFHO0FBRXhCLElBQUlDLFdBQVdOLFVBQVVNLFFBQVEsR0FBR0wsVUFBVUssUUFBUSxHQUFHLENBQUM7QUFDMUQsSUFBSUMsU0FBU0osbUJBQU9BLENBQUM7QUFFckIsSUFBSUssVUFBVTtJQUNaLEtBQUs7UUFBRUMsTUFBTTtRQUFhQyxPQUFPO0lBQVc7SUFDNUMsS0FBSztRQUFFRCxNQUFNO1FBQU9DLE9BQU87SUFBSztJQUNoQyxLQUFLO1FBQUVELE1BQU07UUFBT0MsT0FBTztJQUFLO0lBQ2hDLEtBQUs7UUFBRUQsTUFBTTtRQUFPQyxPQUFPO0lBQUs7SUFDaEMsS0FBSztRQUFFRCxNQUFNO1FBQU9DLE9BQU87SUFBSTtBQUNqQztBQUVBLGdDQUFnQztBQUNoQyxpREFBaUQ7QUFDakQsSUFBSUMsUUFBUTtBQUVaLGdDQUFnQztBQUNoQyxJQUFJQyxPQUFPRCxRQUFRO0FBRW5CLDREQUE0RDtBQUM1RCwrREFBK0Q7QUFDL0QsNkNBQTZDO0FBQzdDLElBQUlFLGFBQWE7QUFFakIsa0NBQWtDO0FBQ2xDLDZDQUE2QztBQUM3QyxJQUFJQyxlQUFlO0FBRW5CLGdEQUFnRDtBQUNoRCxJQUFJQyxhQUFhQyxRQUFRO0FBRXpCLHNDQUFzQztBQUN0QyxTQUFTQSxRQUFTQyxDQUFDO0lBQ2pCLE9BQU9BLEVBQUVDLEtBQUssQ0FBQyxJQUFJQyxNQUFNLENBQUMsU0FBVUMsR0FBRyxFQUFFQyxDQUFDO1FBQ3hDRCxHQUFHLENBQUNDLEVBQUUsR0FB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QW9EO0lBQ3BELHlEQUF5RDtJQUN6RCw2QkFBNkI7SUFDN0IseUNBQXlDO0lBRXpDLGdFQUFnRTtJQUNoRSxJQUFJRyxPQUFPRSxNQUFNRCxPQUFPM0MsSUFBSTtRQUMxQixvREFBb0Q7UUFDcEQsZ0JBQWdCO1FBQ2hCLE9BQU87SUFDVCxPQUFPLElBQUkwQyxPQUFPRSxJQUFJO1FBQ3BCLCtDQUErQztRQUMvQyxpREFBaUQ7UUFDakQsdUJBQXVCO1FBQ3ZCLE9BQU8xRjtJQUNULE9BQU8sd0JBQXdCLEdBQUcsSUFBSXlGLE9BQU8zQyxJQUFJO1FBQy9DLDRDQUE0QztRQUM1QyxvREFBb0Q7UUFDcEQsaURBQWlEO1FBQ2pELHdCQUF3QjtRQUN4QixPQUFPLE9BQVE0QyxLQUFLLEtBQU9QLElBQUksQ0FBQ0ssR0FBRyxLQUFLO0lBQzFDO0lBRUEseUJBQXlCO0lBQ3pCLHdCQUF3QixHQUN4QixNQUFNLElBQUlNLE1BQU07QUFDbEI7QUFFQSwrQkFBK0I7QUFDL0IsU0FBU3ZCLGFBQWM3RyxDQUFDO0lBQ3RCLE9BQU9BLEVBQUU4RixPQUFPLENBQUMsVUFBVTtBQUM3QjtBQUVBLFNBQVNxQixhQUFjbkgsQ0FBQztJQUN0QixPQUFPQSxFQUFFOEYsT0FBTyxDQUFDLDRCQUE0QjtBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYnZpZGl4LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9taW5pbWF0Y2guanM/NDg1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IG1pbmltYXRjaFxubWluaW1hdGNoLk1pbmltYXRjaCA9IE1pbmltYXRjaFxuXG52YXIgcGF0aCA9IChmdW5jdGlvbiAoKSB7IHRyeSB7IHJldHVybiByZXF1aXJlKCdwYXRoJykgfSBjYXRjaCAoZSkge319KCkpIHx8IHtcbiAgc2VwOiAnLydcbn1cbm1pbmltYXRjaC5zZXAgPSBwYXRoLnNlcFxuXG52YXIgR0xPQlNUQVIgPSBtaW5pbWF0Y2guR0xPQlNUQVIgPSBNaW5pbWF0Y2guR0xPQlNUQVIgPSB7fVxudmFyIGV4cGFuZCA9IHJlcXVpcmUoJ2JyYWNlLWV4cGFuc2lvbicpXG5cbnZhciBwbFR5cGVzID0ge1xuICAnISc6IHsgb3BlbjogJyg/Oig/ISg/OicsIGNsb3NlOiAnKSlbXi9dKj8pJ30sXG4gICc/JzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpPycgfSxcbiAgJysnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJykrJyB9LFxuICAnKic6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSonIH0sXG4gICdAJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpJyB9XG59XG5cbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG4vLyBkb24ndCBuZWVkIHRvIGVzY2FwZSAvIHdoZW4gdXNpbmcgbmV3IFJlZ0V4cCgpXG52YXIgcW1hcmsgPSAnW14vXSdcblxuLy8gKiA9PiBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbnZhciBzdGFyID0gcW1hcmsgKyAnKj8nXG5cbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbnZhciB0d29TdGFyRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFxcXC8pKS4pKj8nXG5cbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxudmFyIHR3b1N0YXJOb0RvdCA9ICcoPzooPyEoPzpcXFxcXFwvfF4pXFxcXC4pLikqPydcblxuLy8gY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZXNjYXBlZCBpbiBSZWdFeHAuXG52YXIgcmVTcGVjaWFscyA9IGNoYXJTZXQoJygpLip7fSs/W11eJFxcXFwhJylcblxuLy8gXCJhYmNcIiAtPiB7IGE6dHJ1ZSwgYjp0cnVlLCBjOnRydWUgfVxuZnVuY3Rpb24gY2hhclNldCAocykge1xuICByZXR1cm4gcy5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChzZXQsIGMpIHtcbiAgICBzZXRbY10gPSB0cnVlXG4gICAgcmV0dXJuIHNldFxuICB9LCB7fSlcbn1cblxuLy8gbm9ybWFsaXplcyBzbGFzaGVzLlxudmFyIHNsYXNoU3BsaXQgPSAvXFwvKy9cblxubWluaW1hdGNoLmZpbHRlciA9IGZpbHRlclxuZnVuY3Rpb24gZmlsdGVyIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHJldHVybiBmdW5jdGlvbiAocCwgaSwgbGlzdCkge1xuICAgIHJldHVybiBtaW5pbWF0Y2gocCwgcGF0dGVybiwgb3B0aW9ucylcbiAgfVxufVxuXG5mdW5jdGlvbiBleHQgKGEsIGIpIHtcbiAgYiA9IGIgfHwge31cbiAgdmFyIHQgPSB7fVxuICBPYmplY3Qua2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdFtrXSA9IGFba11cbiAgfSlcbiAgT2JqZWN0LmtleXMoYikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHRba10gPSBiW2tdXG4gIH0pXG4gIHJldHVybiB0XG59XG5cbm1pbmltYXRjaC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYgfHwgdHlwZW9mIGRlZiAhPT0gJ29iamVjdCcgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaFxuICB9XG5cbiAgdmFyIG9yaWcgPSBtaW5pbWF0Y2hcblxuICB2YXIgbSA9IGZ1bmN0aW9uIG1pbmltYXRjaCAocCwgcGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnKHAsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5NaW5pbWF0Y2ggPSBmdW5jdGlvbiBNaW5pbWF0Y2ggKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IG9yaWcuTWluaW1hdGNoKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG4gIG0uTWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gZGVmYXVsdHMgKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5kZWZhdWx0cyhleHQoZGVmLCBvcHRpb25zKSkuTWluaW1hdGNoXG4gIH1cblxuICBtLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmZpbHRlcihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0uZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyAob3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5tYWtlUmUgPSBmdW5jdGlvbiBtYWtlUmUgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5tYWtlUmUocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLmJyYWNlRXhwYW5kID0gZnVuY3Rpb24gYnJhY2VFeHBhbmQgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5icmFjZUV4cGFuZChwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0ubWF0Y2ggPSBmdW5jdGlvbiAobGlzdCwgcGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLm1hdGNoKGxpc3QsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgcmV0dXJuIG1cbn1cblxuTWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gKGRlZikge1xuICByZXR1cm4gbWluaW1hdGNoLmRlZmF1bHRzKGRlZikuTWluaW1hdGNoXG59XG5cbmZ1bmN0aW9uIG1pbmltYXRjaCAocCwgcGF0dGVybiwgb3B0aW9ucykge1xuICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gIC8vIHNob3J0Y3V0OiBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpLm1hdGNoKHApXG59XG5cbmZ1bmN0aW9uIE1pbmltYXRjaCAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWluaW1hdGNoKSkge1xuICAgIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIH1cblxuICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gIHBhdHRlcm4gPSBwYXR0ZXJuLnRyaW0oKVxuXG4gIC8vIHdpbmRvd3Mgc3VwcG9ydDogbmVlZCB0byB1c2UgLywgbm90IFxcXG4gIGlmICghb3B0aW9ucy5hbGxvd1dpbmRvd3NFc2NhcGUgJiYgcGF0aC5zZXAgIT09ICcvJykge1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5zZXQgPSBbXVxuICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuXG4gIHRoaXMucmVnZXhwID0gbnVsbFxuICB0aGlzLm5lZ2F0ZSA9IGZhbHNlXG4gIHRoaXMuY29tbWVudCA9IGZhbHNlXG4gIHRoaXMuZW1wdHkgPSBmYWxzZVxuICB0aGlzLnBhcnRpYWwgPSAhIW9wdGlvbnMucGFydGlhbFxuXG4gIC8vIG1ha2UgdGhlIHNldCBvZiByZWdleHBzIGV0Yy5cbiAgdGhpcy5tYWtlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9XG5cbk1pbmltYXRjaC5wcm90b3R5cGUubWFrZSA9IG1ha2VcbmZ1bmN0aW9uIG1ha2UgKCkge1xuICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIGVtcHR5IHBhdHRlcm5zIGFuZCBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICB0aGlzLmNvbW1lbnQgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgdGhpcy5lbXB0eSA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHN0ZXAgMTogZmlndXJlIG91dCBuZWdhdGlvbiwgZXRjLlxuICB0aGlzLnBhcnNlTmVnYXRlKClcblxuICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgdmFyIHNldCA9IHRoaXMuZ2xvYlNldCA9IHRoaXMuYnJhY2VFeHBhbmQoKVxuXG4gIGlmIChvcHRpb25zLmRlYnVnKSB0aGlzLmRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7IGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKSB9XG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBzdGVwIDM6IG5vdyB3ZSBoYXZlIGEgc2V0LCBzbyB0dXJuIGVhY2ggb25lIGludG8gYSBzZXJpZXMgb2YgcGF0aC1wb3J0aW9uXG4gIC8vIG1hdGNoaW5nIHBhdHRlcm5zLlxuICAvLyBUaGVzZSB3aWxsIGJlIHJlZ2V4cHMsIGV4Y2VwdCBpbiB0aGUgY2FzZSBvZiBcIioqXCIsIHdoaWNoIGlzXG4gIC8vIHNldCB0byB0aGUgR0xPQlNUQVIgb2JqZWN0IGZvciBnbG9ic3RhciBiZWhhdmlvcixcbiAgLy8gYW5kIHdpbGwgbm90IGNvbnRhaW4gYW55IC8gY2hhcmFjdGVyc1xuICBzZXQgPSB0aGlzLmdsb2JQYXJ0cyA9IHNldC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5zcGxpdChzbGFzaFNwbGl0KVxuICB9KVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gZ2xvYiAtLT4gcmVnZXhwc1xuICBzZXQgPSBzZXQubWFwKGZ1bmN0aW9uIChzLCBzaSwgc2V0KSB7XG4gICAgcmV0dXJuIHMubWFwKHRoaXMucGFyc2UsIHRoaXMpXG4gIH0sIHRoaXMpXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBmaWx0ZXIgb3V0IGV2ZXJ5dGhpbmcgdGhhdCBkaWRuJ3QgY29tcGlsZSBwcm9wZXJseS5cbiAgc2V0ID0gc2V0LmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLmluZGV4T2YoZmFsc2UpID09PSAtMVxuICB9KVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgdGhpcy5zZXQgPSBzZXRcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5wYXJzZU5lZ2F0ZSA9IHBhcnNlTmVnYXRlXG5mdW5jdGlvbiBwYXJzZU5lZ2F0ZSAoKSB7XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gIHZhciBuZWdhdGUgPSBmYWxzZVxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICB2YXIgbmVnYXRlT2Zmc2V0ID0gMFxuXG4gIGlmIChvcHRpb25zLm5vbmVnYXRlKSByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdHRlcm4ubGVuZ3RoXG4gICAgOyBpIDwgbCAmJiBwYXR0ZXJuLmNoYXJBdChpKSA9PT0gJyEnXG4gICAgOyBpKyspIHtcbiAgICBuZWdhdGUgPSAhbmVnYXRlXG4gICAgbmVnYXRlT2Zmc2V0KytcbiAgfVxuXG4gIGlmIChuZWdhdGVPZmZzZXQpIHRoaXMucGF0dGVybiA9IHBhdHRlcm4uc3Vic3RyKG5lZ2F0ZU9mZnNldClcbiAgdGhpcy5uZWdhdGUgPSBuZWdhdGVcbn1cblxuLy8gQnJhY2UgZXhwYW5zaW9uOlxuLy8gYXtiLGN9ZCAtPiBhYmQgYWNkXG4vLyBhe2IsfWMgLT4gYWJjIGFjXG4vLyBhezAuLjN9ZCAtPiBhMGQgYTFkIGEyZCBhM2Rcbi8vIGF7Yixje2QsZX1mfWcgLT4gYWJnIGFjZGZnIGFjZWZnXG4vLyBhe2IsY31ke2UsZn1nIC0+IGFiZGVnIGFjZGVnIGFiZGVnIGFiZGZnXG4vL1xuLy8gSW52YWxpZCBzZXRzIGFyZSBub3QgZXhwYW5kZWQuXG4vLyBhezIuLn1iIC0+IGF7Mi4ufWJcbi8vIGF7Yn1jIC0+IGF7Yn1jXG5taW5pbWF0Y2guYnJhY2VFeHBhbmQgPSBmdW5jdGlvbiAocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gYnJhY2VFeHBhbmQocGF0dGVybiwgb3B0aW9ucylcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5icmFjZUV4cGFuZCA9IGJyYWNlRXhwYW5kXG5cbmZ1bmN0aW9uIGJyYWNlRXhwYW5kIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTWluaW1hdGNoKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cbiAgfVxuXG4gIHBhdHRlcm4gPSB0eXBlb2YgcGF0dGVybiA9PT0gJ3VuZGVmaW5lZCdcbiAgICA/IHRoaXMucGF0dGVybiA6IHBhdHRlcm5cblxuICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICAvLyBUaGFua3MgdG8gWWV0aW5nIExpIDxodHRwczovL2dpdGh1Yi5jb20veWV0aW5nbGk+IGZvclxuICAvLyBpbXByb3ZpbmcgdGhpcyByZWdleHAgdG8gYXZvaWQgYSBSZURPUyB2dWxuZXJhYmlsaXR5LlxuICBpZiAob3B0aW9ucy5ub2JyYWNlIHx8ICEvXFx7KD86KD8hXFx7KS4pKlxcfS8udGVzdChwYXR0ZXJuKSkge1xuICAgIC8vIHNob3J0Y3V0LiBubyBuZWVkIHRvIGV4cGFuZC5cbiAgICByZXR1cm4gW3BhdHRlcm5dXG4gIH1cblxuICByZXR1cm4gZXhwYW5kKHBhdHRlcm4pXG59XG5cbnZhciBNQVhfUEFUVEVSTl9MRU5HVEggPSAxMDI0ICogNjRcbnZhciBhc3NlcnRWYWxpZFBhdHRlcm4gPSBmdW5jdGlvbiAocGF0dGVybikge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXR0ZXJuJylcbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9QQVRURVJOX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdHRlcm4gaXMgdG9vIGxvbmcnKVxuICB9XG59XG5cbi8vIHBhcnNlIGEgY29tcG9uZW50IG9mIHRoZSBleHBhbmRlZCBzZXQuXG4vLyBBdCB0aGlzIHBvaW50LCBubyBwYXR0ZXJuIG1heSBjb250YWluIFwiL1wiIGluIGl0XG4vLyBzbyB3ZSdyZSBnb2luZyB0byByZXR1cm4gYSAyZCBhcnJheSwgd2hlcmUgZWFjaCBlbnRyeSBpcyB0aGUgZnVsbFxuLy8gcGF0dGVybiwgc3BsaXQgb24gJy8nLCBhbmQgdGhlbiB0dXJuZWQgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbi8vIEEgcmVnZXhwIGlzIG1hZGUgYXQgdGhlIGVuZCB3aGljaCBqb2lucyBlYWNoIGFycmF5IHdpdGggYW5cbi8vIGVzY2FwZWQgLywgYW5kIGFub3RoZXIgZnVsbCBvbmUgd2hpY2ggam9pbnMgZWFjaCByZWdleHAgd2l0aCB8LlxuLy9cbi8vIEZvbGxvd2luZyB0aGUgbGVhZCBvZiBCYXNoIDQuMSwgbm90ZSB0aGF0IFwiKipcIiBvbmx5IGhhcyBzcGVjaWFsIG1lYW5pbmdcbi8vIHdoZW4gaXQgaXMgdGhlICpvbmx5KiB0aGluZyBpbiBhIHBhdGggcG9ydGlvbi4gIE90aGVyd2lzZSwgYW55IHNlcmllc1xuLy8gb2YgKiBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xlICouICBHbG9ic3RhciBiZWhhdmlvciBpcyBlbmFibGVkIGJ5XG4vLyBkZWZhdWx0LCBhbmQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgb3B0aW9ucy5ub2dsb2JzdGFyLlxuTWluaW1hdGNoLnByb3RvdHlwZS5wYXJzZSA9IHBhcnNlXG52YXIgU1VCUEFSU0UgPSB7fVxuZnVuY3Rpb24gcGFyc2UgKHBhdHRlcm4sIGlzU3ViKSB7XG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gc2hvcnRjdXRzXG4gIGlmIChwYXR0ZXJuID09PSAnKionKSB7XG4gICAgaWYgKCFvcHRpb25zLm5vZ2xvYnN0YXIpXG4gICAgICByZXR1cm4gR0xPQlNUQVJcbiAgICBlbHNlXG4gICAgICBwYXR0ZXJuID0gJyonXG4gIH1cbiAgaWYgKHBhdHRlcm4gPT09ICcnKSByZXR1cm4gJydcblxuICB2YXIgcmUgPSAnJ1xuICB2YXIgaGFzTWFnaWMgPSAhIW9wdGlvbnMubm9jYXNlXG4gIHZhciBlc2NhcGluZyA9IGZhbHNlXG4gIC8vID8gPT4gb25lIHNpbmdsZSBjaGFyYWN0ZXJcbiAgdmFyIHBhdHRlcm5MaXN0U3RhY2sgPSBbXVxuICB2YXIgbmVnYXRpdmVMaXN0cyA9IFtdXG4gIHZhciBzdGF0ZUNoYXJcbiAgdmFyIGluQ2xhc3MgPSBmYWxzZVxuICB2YXIgcmVDbGFzc1N0YXJ0ID0gLTFcbiAgdmFyIGNsYXNzU3RhcnQgPSAtMVxuICAvLyAuIGFuZCAuLiBuZXZlciBtYXRjaCBhbnl0aGluZyB0aGF0IGRvZXNuJ3Qgc3RhcnQgd2l0aCAuLFxuICAvLyBldmVuIHdoZW4gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICB2YXIgcGF0dGVyblN0YXJ0ID0gcGF0dGVybi5jaGFyQXQoMCkgPT09ICcuJyA/ICcnIC8vIGFueXRoaW5nXG4gIC8vIG5vdCAoc3RhcnQgb3IgLyBmb2xsb3dlZCBieSAuIG9yIC4uIGZvbGxvd2VkIGJ5IC8gb3IgZW5kKVxuICA6IG9wdGlvbnMuZG90ID8gJyg/ISg/Ol58XFxcXFxcLylcXFxcLnsxLDJ9KD86JHxcXFxcXFwvKSknXG4gIDogJyg/IVxcXFwuKSdcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZnVuY3Rpb24gY2xlYXJTdGF0ZUNoYXIgKCkge1xuICAgIGlmIChzdGF0ZUNoYXIpIHtcbiAgICAgIC8vIHdlIGhhZCBzb21lIHN0YXRlLXRyYWNraW5nIGNoYXJhY3RlclxuICAgICAgLy8gdGhhdCB3YXNuJ3QgY29uc3VtZWQgYnkgdGhpcyBwYXNzLlxuICAgICAgc3dpdGNoIChzdGF0ZUNoYXIpIHtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgcmUgKz0gc3RhclxuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICByZSArPSBxbWFya1xuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlICs9ICdcXFxcJyArIHN0YXRlQ2hhclxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgc2VsZi5kZWJ1ZygnY2xlYXJTdGF0ZUNoYXIgJWogJWonLCBzdGF0ZUNoYXIsIHJlKVxuICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0dGVybi5sZW5ndGgsIGNcbiAgICA7IChpIDwgbGVuKSAmJiAoYyA9IHBhdHRlcm4uY2hhckF0KGkpKVxuICAgIDsgaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgLy8gc2tpcCBvdmVyIGFueSB0aGF0IGFyZSBlc2NhcGVkLlxuICAgIGlmIChlc2NhcGluZyAmJiByZVNwZWNpYWxzW2NdKSB7XG4gICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHN3aXRjaCAoYykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGNhc2UgJy8nOiB7XG4gICAgICAgIC8vIGNvbXBsZXRlbHkgbm90IGFsbG93ZWQsIGV2ZW4gZXNjYXBlZC5cbiAgICAgICAgLy8gU2hvdWxkIGFscmVhZHkgYmUgcGF0aC1zcGxpdCBieSBub3cuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBlc2NhcGluZyA9IHRydWVcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIC8vIHRoZSB2YXJpb3VzIHN0YXRlQ2hhciB2YWx1ZXNcbiAgICAgIC8vIGZvciB0aGUgXCJleHRnbG9iXCIgc3R1ZmYuXG4gICAgICBjYXNlICc/JzpcbiAgICAgIGNhc2UgJyonOlxuICAgICAgY2FzZSAnKyc6XG4gICAgICBjYXNlICdAJzpcbiAgICAgIGNhc2UgJyEnOlxuICAgICAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqIDwtLSBzdGF0ZUNoYXInLCBwYXR0ZXJuLCBpLCByZSwgYylcblxuICAgICAgICAvLyBhbGwgb2YgdGhvc2UgYXJlIGxpdGVyYWxzIGluc2lkZSBhIGNsYXNzLCBleGNlcHQgdGhhdFxuICAgICAgICAvLyB0aGUgZ2xvYiBbIWFdIG1lYW5zIFteYV0gaW4gcmVnZXhwXG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnICBpbiBjbGFzcycpXG4gICAgICAgICAgaWYgKGMgPT09ICchJyAmJiBpID09PSBjbGFzc1N0YXJ0ICsgMSkgYyA9ICdeJ1xuICAgICAgICAgIHJlICs9IGNcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgc3RhdGVDaGFyLCB0aGVuIGl0IG1lYW5zXG4gICAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIHNvbWV0aGluZyBsaWtlICoqIG9yICs/IGluIHRoZXJlLlxuICAgICAgICAvLyBIYW5kbGUgdGhlIHN0YXRlQ2hhciwgdGhlbiBwcm9jZWVkIHdpdGggdGhpcyBvbmUuXG4gICAgICAgIHNlbGYuZGVidWcoJ2NhbGwgY2xlYXJTdGF0ZUNoYXIgJWonLCBzdGF0ZUNoYXIpXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgc3RhdGVDaGFyID0gY1xuICAgICAgICAvLyBpZiBleHRnbG9iIGlzIGRpc2FibGVkLCB0aGVuICsoYXNkZnxmb28pIGlzbid0IGEgdGhpbmcuXG4gICAgICAgIC8vIGp1c3QgY2xlYXIgdGhlIHN0YXRlY2hhciAqbm93KiwgcmF0aGVyIHRoYW4gZXZlbiBkaXZpbmcgaW50b1xuICAgICAgICAvLyB0aGUgcGF0dGVybkxpc3Qgc3R1ZmYuXG4gICAgICAgIGlmIChvcHRpb25zLm5vZXh0KSBjbGVhclN0YXRlQ2hhcigpXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICcoJzpcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnKCdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZUNoYXIpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCgnXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdHRlcm5MaXN0U3RhY2sucHVzaCh7XG4gICAgICAgICAgdHlwZTogc3RhdGVDaGFyLFxuICAgICAgICAgIHN0YXJ0OiBpIC0gMSxcbiAgICAgICAgICByZVN0YXJ0OiByZS5sZW5ndGgsXG4gICAgICAgICAgb3BlbjogcGxUeXBlc1tzdGF0ZUNoYXJdLm9wZW4sXG4gICAgICAgICAgY2xvc2U6IHBsVHlwZXNbc3RhdGVDaGFyXS5jbG9zZVxuICAgICAgICB9KVxuICAgICAgICAvLyBuZWdhdGlvbiBpcyAoPzooPyFqcylbXi9dKilcbiAgICAgICAgcmUgKz0gc3RhdGVDaGFyID09PSAnIScgPyAnKD86KD8hKD86JyA6ICcoPzonXG4gICAgICAgIHRoaXMuZGVidWcoJ3BsVHlwZSAlaiAlaicsIHN0YXRlQ2hhciwgcmUpXG4gICAgICAgIHN0YXRlQ2hhciA9IGZhbHNlXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICcpJzpcbiAgICAgICAgaWYgKGluQ2xhc3MgfHwgIXBhdHRlcm5MaXN0U3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwpJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICB2YXIgcGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpXG4gICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICAvLyBUaGUgb3RoZXJzIGFyZSAoPzo8cGF0dGVybj4pPHR5cGU+XG4gICAgICAgIHJlICs9IHBsLmNsb3NlXG4gICAgICAgIGlmIChwbC50eXBlID09PSAnIScpIHtcbiAgICAgICAgICBuZWdhdGl2ZUxpc3RzLnB1c2gocGwpXG4gICAgICAgIH1cbiAgICAgICAgcGwucmVFbmQgPSByZS5sZW5ndGhcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGF0dGVybkxpc3RTdGFjay5sZW5ndGggfHwgZXNjYXBpbmcpIHtcbiAgICAgICAgICByZSArPSAnXFxcXHwnXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIHJlICs9ICd8J1xuICAgICAgY29udGludWVcblxuICAgICAgLy8gdGhlc2UgYXJlIG1vc3RseSB0aGUgc2FtZSBpbiByZWdleHAgYW5kIGdsb2JcbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICAvLyBzd2FsbG93IGFueSBzdGF0ZS10cmFja2luZyBjaGFyIGJlZm9yZSB0aGUgW1xuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG5cbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGluQ2xhc3MgPSB0cnVlXG4gICAgICAgIGNsYXNzU3RhcnQgPSBpXG4gICAgICAgIHJlQ2xhc3NTdGFydCA9IHJlLmxlbmd0aFxuICAgICAgICByZSArPSBjXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICddJzpcbiAgICAgICAgLy8gIGEgcmlnaHQgYnJhY2tldCBzaGFsbCBsb3NlIGl0cyBzcGVjaWFsXG4gICAgICAgIC8vICBtZWFuaW5nIGFuZCByZXByZXNlbnQgaXRzZWxmIGluXG4gICAgICAgIC8vICBhIGJyYWNrZXQgZXhwcmVzc2lvbiBpZiBpdCBvY2N1cnNcbiAgICAgICAgLy8gIGZpcnN0IGluIHRoZSBsaXN0LiAgLS0gUE9TSVguMiAyLjguMy4yXG4gICAgICAgIGlmIChpID09PSBjbGFzc1N0YXJ0ICsgMSB8fCAhaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBsZWZ0IGEgY2xhc3Mgb3Blbi5cbiAgICAgICAgLy8gXCJbei1hXVwiIGlzIHZhbGlkLCBlcXVpdmFsZW50IHRvIFwiXFxbei1hXFxdXCJcbiAgICAgICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIGFuIGludmFsaWQgcmUuIGlmIHNvLCByZS13YWxrIHRoZSBjb250ZW50cyBvZiB0aGVcbiAgICAgICAgLy8gd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlIGFueSBjaGFyYWN0ZXJzIHRoYXRcbiAgICAgICAgLy8gd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgICAgICAvLyBUT0RPOiBJdCB3b3VsZCBwcm9iYWJseSBiZSBmYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoaXNcbiAgICAgICAgLy8gd2l0aG91dCBhIHRyeS9jYXRjaCBhbmQgYSBuZXcgUmVnRXhwLCBidXQgaXQncyB0cmlja3lcbiAgICAgICAgLy8gdG8gZG8gc2FmZWx5LiAgRm9yIG5vdywgdGhpcyBpcyBzYWZlIGFuZCB3b3Jrcy5cbiAgICAgICAgdmFyIGNzID0gcGF0dGVybi5zdWJzdHJpbmcoY2xhc3NTdGFydCArIDEsIGkpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVnRXhwKCdbJyArIGNzICsgJ10nKVxuICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgIC8vIG5vdCBhIHZhbGlkIGNsYXNzIVxuICAgICAgICAgIHZhciBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgICAgICAgIHJlID0gcmUuc3Vic3RyKDAsIHJlQ2xhc3NTdGFydCkgKyAnXFxcXFsnICsgc3BbMF0gKyAnXFxcXF0nXG4gICAgICAgICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBzcFsxXVxuICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5pc2ggdXAgdGhlIGNsYXNzLlxuICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgIHJlICs9IGNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlIGNoYXIgdGhhdCB3YXNuJ3QgY29uc3VtZWRcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAgIC8vIG5vIG5lZWRcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSBpZiAocmVTcGVjaWFsc1tjXVxuICAgICAgICAgICYmICEoYyA9PT0gJ14nICYmIGluQ2xhc3MpKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnXG4gICAgICAgIH1cblxuICAgICAgICByZSArPSBjXG5cbiAgICB9IC8vIHN3aXRjaFxuICB9IC8vIGZvclxuXG4gIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBsZWZ0IGEgY2xhc3Mgb3Blbi5cbiAgLy8gXCJbYWJjXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFthYmNcIlxuICBpZiAoaW5DbGFzcykge1xuICAgIC8vIHNwbGl0IHdoZXJlIHRoZSBsYXN0IFsgd2FzLCBhbmQgZXNjYXBlIGl0XG4gICAgLy8gdGhpcyBpcyBhIGh1Z2UgcGl0YS4gIFdlIG5vdyBoYXZlIHRvIHJlLXdhbGtcbiAgICAvLyB0aGUgY29udGVudHMgb2YgdGhlIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZVxuICAgIC8vIGFueSBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgIGNzID0gcGF0dGVybi5zdWJzdHIoY2xhc3NTdGFydCArIDEpXG4gICAgc3AgPSB0aGlzLnBhcnNlKGNzLCBTVUJQQVJTRSlcbiAgICByZSA9IHJlLnN1YnN0cigwLCByZUNsYXNzU3RhcnQpICsgJ1xcXFxbJyArIHNwWzBdXG4gICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBzcFsxXVxuICB9XG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGhhZCBhICsoIHRoaW5nIGF0IHRoZSAqZW5kKlxuICAvLyBvZiB0aGUgcGF0dGVybi5cbiAgLy8gZWFjaCBwYXR0ZXJuIGxpc3Qgc3RhY2sgYWRkcyAzIGNoYXJzLCBhbmQgd2UgbmVlZCB0byBnbyB0aHJvdWdoXG4gIC8vIGFuZCBlc2NhcGUgYW55IHwgY2hhcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzIGZvciB0aGUgcmVnZXhwLlxuICAvLyBHbyB0aHJvdWdoIGFuZCBlc2NhcGUgdGhlbSwgdGFraW5nIGNhcmUgbm90IHRvIGRvdWJsZS1lc2NhcGUgYW55XG4gIC8vIHwgY2hhcnMgdGhhdCB3ZXJlIGFscmVhZHkgZXNjYXBlZC5cbiAgZm9yIChwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCk7IHBsOyBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCkpIHtcbiAgICB2YXIgdGFpbCA9IHJlLnNsaWNlKHBsLnJlU3RhcnQgKyBwbC5vcGVuLmxlbmd0aClcbiAgICB0aGlzLmRlYnVnKCdzZXR0aW5nIHRhaWwnLCByZSwgcGwpXG4gICAgLy8gbWF5YmUgc29tZSBldmVuIG51bWJlciBvZiBcXCwgdGhlbiBtYXliZSAxIFxcLCBmb2xsb3dlZCBieSBhIHxcbiAgICB0YWlsID0gdGFpbC5yZXBsYWNlKC8oKD86XFxcXHsyfSl7MCw2NH0pKFxcXFw/KVxcfC9nLCBmdW5jdGlvbiAoXywgJDEsICQyKSB7XG4gICAgICBpZiAoISQyKSB7XG4gICAgICAgIC8vIHRoZSB8IGlzbid0IGFscmVhZHkgZXNjYXBlZCwgc28gZXNjYXBlIGl0LlxuICAgICAgICAkMiA9ICdcXFxcJ1xuICAgICAgfVxuXG4gICAgICAvLyBuZWVkIHRvIGVzY2FwZSBhbGwgdGhvc2Ugc2xhc2hlcyAqYWdhaW4qLCB3aXRob3V0IGVzY2FwaW5nIHRoZVxuICAgICAgLy8gb25lIHRoYXQgd2UgbmVlZCBmb3IgZXNjYXBpbmcgdGhlIHwgY2hhcmFjdGVyLiAgQXMgaXQgd29ya3Mgb3V0LFxuICAgICAgLy8gZXNjYXBpbmcgYW4gZXZlbiBudW1iZXIgb2Ygc2xhc2hlcyBjYW4gYmUgZG9uZSBieSBzaW1wbHkgcmVwZWF0aW5nXG4gICAgICAvLyBpdCBleGFjdGx5IGFmdGVyIGl0c2VsZi4gIFRoYXQncyB3aHkgdGhpcyB0cmljayB3b3Jrcy5cbiAgICAgIC8vXG4gICAgICAvLyBJIGFtIHNvcnJ5IHRoYXQgeW91IGhhdmUgdG8gc2VlIHRoaXMuXG4gICAgICByZXR1cm4gJDEgKyAkMSArICQyICsgJ3wnXG4gICAgfSlcblxuICAgIHRoaXMuZGVidWcoJ3RhaWw9JWpcXG4gICAlcycsIHRhaWwsIHRhaWwsIHBsLCByZSlcbiAgICB2YXIgdCA9IHBsLnR5cGUgPT09ICcqJyA/IHN0YXJcbiAgICAgIDogcGwudHlwZSA9PT0gJz8nID8gcW1hcmtcbiAgICAgIDogJ1xcXFwnICsgcGwudHlwZVxuXG4gICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgcmUgPSByZS5zbGljZSgwLCBwbC5yZVN0YXJ0KSArIHQgKyAnXFxcXCgnICsgdGFpbFxuICB9XG5cbiAgLy8gaGFuZGxlIHRyYWlsaW5nIHRoaW5ncyB0aGF0IG9ubHkgbWF0dGVyIGF0IHRoZSB2ZXJ5IGVuZC5cbiAgY2xlYXJTdGF0ZUNoYXIoKVxuICBpZiAoZXNjYXBpbmcpIHtcbiAgICAvLyB0cmFpbGluZyBcXFxcXG4gICAgcmUgKz0gJ1xcXFxcXFxcJ1xuICB9XG5cbiAgLy8gb25seSBuZWVkIHRvIGFwcGx5IHRoZSBub2RvdCBzdGFydCBpZiB0aGUgcmUgc3RhcnRzIHdpdGhcbiAgLy8gc29tZXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgY2FwdHVyZSBhIGRvdFxuICB2YXIgYWRkUGF0dGVyblN0YXJ0ID0gZmFsc2VcbiAgc3dpdGNoIChyZS5jaGFyQXQoMCkpIHtcbiAgICBjYXNlICdbJzogY2FzZSAnLic6IGNhc2UgJygnOiBhZGRQYXR0ZXJuU3RhcnQgPSB0cnVlXG4gIH1cblxuICAvLyBIYWNrIHRvIHdvcmsgYXJvdW5kIGxhY2sgb2YgbmVnYXRpdmUgbG9va2JlaGluZCBpbiBKU1xuICAvLyBBIHBhdHRlcm4gbGlrZTogKi4hKHgpLiEoeXx6KSBuZWVkcyB0byBlbnN1cmUgdGhhdCBhIG5hbWVcbiAgLy8gbGlrZSAnYS54eXoueXonIGRvZXNuJ3QgbWF0Y2guICBTbywgdGhlIGZpcnN0IG5lZ2F0aXZlXG4gIC8vIGxvb2thaGVhZCwgaGFzIHRvIGxvb2sgQUxMIHRoZSB3YXkgYWhlYWQsIHRvIHRoZSBlbmQgb2ZcbiAgLy8gdGhlIHBhdHRlcm4uXG4gIGZvciAodmFyIG4gPSBuZWdhdGl2ZUxpc3RzLmxlbmd0aCAtIDE7IG4gPiAtMTsgbi0tKSB7XG4gICAgdmFyIG5sID0gbmVnYXRpdmVMaXN0c1tuXVxuXG4gICAgdmFyIG5sQmVmb3JlID0gcmUuc2xpY2UoMCwgbmwucmVTdGFydClcbiAgICB2YXIgbmxGaXJzdCA9IHJlLnNsaWNlKG5sLnJlU3RhcnQsIG5sLnJlRW5kIC0gOClcbiAgICB2YXIgbmxMYXN0ID0gcmUuc2xpY2UobmwucmVFbmQgLSA4LCBubC5yZUVuZClcbiAgICB2YXIgbmxBZnRlciA9IHJlLnNsaWNlKG5sLnJlRW5kKVxuXG4gICAgbmxMYXN0ICs9IG5sQWZ0ZXJcblxuICAgIC8vIEhhbmRsZSBuZXN0ZWQgc3R1ZmYgbGlrZSAqKCouanN8ISgqLmpzb24pKSwgd2hlcmUgb3BlbiBwYXJlbnNcbiAgICAvLyBtZWFuIHRoYXQgd2Ugc2hvdWxkICpub3QqIGluY2x1ZGUgdGhlICkgaW4gdGhlIGJpdCB0aGF0IGlzIGNvbnNpZGVyZWRcbiAgICAvLyBcImFmdGVyXCIgdGhlIG5lZ2F0ZWQgc2VjdGlvbi5cbiAgICB2YXIgb3BlblBhcmVuc0JlZm9yZSA9IG5sQmVmb3JlLnNwbGl0KCcoJykubGVuZ3RoIC0gMVxuICAgIHZhciBjbGVhbkFmdGVyID0gbmxBZnRlclxuICAgIGZvciAoaSA9IDA7IGkgPCBvcGVuUGFyZW5zQmVmb3JlOyBpKyspIHtcbiAgICAgIGNsZWFuQWZ0ZXIgPSBjbGVhbkFmdGVyLnJlcGxhY2UoL1xcKVsrKj9dPy8sICcnKVxuICAgIH1cbiAgICBubEFmdGVyID0gY2xlYW5BZnRlclxuXG4gICAgdmFyIGRvbGxhciA9ICcnXG4gICAgaWYgKG5sQWZ0ZXIgPT09ICcnICYmIGlzU3ViICE9PSBTVUJQQVJTRSkge1xuICAgICAgZG9sbGFyID0gJyQnXG4gICAgfVxuICAgIHZhciBuZXdSZSA9IG5sQmVmb3JlICsgbmxGaXJzdCArIG5sQWZ0ZXIgKyBkb2xsYXIgKyBubExhc3RcbiAgICByZSA9IG5ld1JlXG4gIH1cblxuICAvLyBpZiB0aGUgcmUgaXMgbm90IFwiXCIgYXQgdGhpcyBwb2ludCwgdGhlbiB3ZSBuZWVkIHRvIG1ha2Ugc3VyZVxuICAvLyBpdCBkb2Vzbid0IG1hdGNoIGFnYWluc3QgYW4gZW1wdHkgcGF0aCBwYXJ0LlxuICAvLyBPdGhlcndpc2UgYS8qIHdpbGwgbWF0Y2ggYS8sIHdoaWNoIGl0IHNob3VsZCBub3QuXG4gIGlmIChyZSAhPT0gJycgJiYgaGFzTWFnaWMpIHtcbiAgICByZSA9ICcoPz0uKScgKyByZVxuICB9XG5cbiAgaWYgKGFkZFBhdHRlcm5TdGFydCkge1xuICAgIHJlID0gcGF0dGVyblN0YXJ0ICsgcmVcbiAgfVxuXG4gIC8vIHBhcnNpbmcganVzdCBhIHBpZWNlIG9mIGEgbGFyZ2VyIHBhdHRlcm4uXG4gIGlmIChpc1N1YiA9PT0gU1VCUEFSU0UpIHtcbiAgICByZXR1cm4gW3JlLCBoYXNNYWdpY11cbiAgfVxuXG4gIC8vIHNraXAgdGhlIHJlZ2V4cCBmb3Igbm9uLW1hZ2ljYWwgcGF0dGVybnNcbiAgLy8gdW5lc2NhcGUgYW55dGhpbmcgaW4gaXQsIHRob3VnaCwgc28gdGhhdCBpdCdsbCBiZVxuICAvLyBhbiBleGFjdCBtYXRjaCBhZ2FpbnN0IGEgZmlsZSBldGMuXG4gIGlmICghaGFzTWFnaWMpIHtcbiAgICByZXR1cm4gZ2xvYlVuZXNjYXBlKHBhdHRlcm4pXG4gIH1cblxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG4gIHRyeSB7XG4gICAgdmFyIHJlZ0V4cCA9IG5ldyBSZWdFeHAoJ14nICsgcmUgKyAnJCcsIGZsYWdzKVxuICB9IGNhdGNoIChlcikgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBzaG91bGQgYmUgaW1wb3NzaWJsZSAqLyB7XG4gICAgLy8gSWYgaXQgd2FzIGFuIGludmFsaWQgcmVndWxhciBleHByZXNzaW9uLCB0aGVuIGl0IGNhbid0IG1hdGNoXG4gICAgLy8gYW55dGhpbmcuICBUaGlzIHRyaWNrIGxvb2tzIGZvciBhIGNoYXJhY3RlciBhZnRlciB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHN0cmluZywgd2hpY2ggaXMgb2YgY291cnNlIGltcG9zc2libGUsIGV4Y2VwdCBpbiBtdWx0aS1saW5lXG4gICAgLy8gbW9kZSwgYnV0IGl0J3Mgbm90IGEgL20gcmVnZXguXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJyQuJylcbiAgfVxuXG4gIHJlZ0V4cC5fZ2xvYiA9IHBhdHRlcm5cbiAgcmVnRXhwLl9zcmMgPSByZVxuXG4gIHJldHVybiByZWdFeHBcbn1cblxubWluaW1hdGNoLm1ha2VSZSA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMgfHwge30pLm1ha2VSZSgpXG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUubWFrZVJlID0gbWFrZVJlXG5mdW5jdGlvbiBtYWtlUmUgKCkge1xuICBpZiAodGhpcy5yZWdleHAgfHwgdGhpcy5yZWdleHAgPT09IGZhbHNlKSByZXR1cm4gdGhpcy5yZWdleHBcblxuICAvLyBhdCB0aGlzIHBvaW50LCB0aGlzLnNldCBpcyBhIDJkIGFycmF5IG9mIHBhcnRpYWxcbiAgLy8gcGF0dGVybiBzdHJpbmdzLCBvciBcIioqXCIuXG4gIC8vXG4gIC8vIEl0J3MgYmV0dGVyIHRvIHVzZSAubWF0Y2goKS4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkbid0XG4gIC8vIGJlIHVzZWQsIHJlYWxseSwgYnV0IGl0J3MgcHJldHR5IGNvbnZlbmllbnQgc29tZXRpbWVzLFxuICAvLyB3aGVuIHlvdSBqdXN0IHdhbnQgdG8gd29yayB3aXRoIGEgcmVnZXguXG4gIHZhciBzZXQgPSB0aGlzLnNldFxuXG4gIGlmICghc2V0Lmxlbmd0aCkge1xuICAgIHRoaXMucmVnZXhwID0gZmFsc2VcbiAgICByZXR1cm4gdGhpcy5yZWdleHBcbiAgfVxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIHZhciB0d29TdGFyID0gb3B0aW9ucy5ub2dsb2JzdGFyID8gc3RhclxuICAgIDogb3B0aW9ucy5kb3QgPyB0d29TdGFyRG90XG4gICAgOiB0d29TdGFyTm9Eb3RcbiAgdmFyIGZsYWdzID0gb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJ1xuXG4gIHZhciByZSA9IHNldC5tYXAoZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gcGF0dGVybi5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAocCA9PT0gR0xPQlNUQVIpID8gdHdvU3RhclxuICAgICAgOiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSA/IHJlZ0V4cEVzY2FwZShwKVxuICAgICAgOiBwLl9zcmNcbiAgICB9KS5qb2luKCdcXFxcXFwvJylcbiAgfSkuam9pbignfCcpXG5cbiAgLy8gbXVzdCBtYXRjaCBlbnRpcmUgcGF0dGVyblxuICAvLyBlbmRpbmcgaW4gYSAqIG9yICoqIHdpbGwgbWFrZSBpdCBsZXNzIHN0cmljdC5cbiAgcmUgPSAnXig/OicgKyByZSArICcpJCdcblxuICAvLyBjYW4gbWF0Y2ggYW55dGhpbmcsIGFzIGxvbmcgYXMgaXQncyBub3QgdGhpcy5cbiAgaWYgKHRoaXMubmVnYXRlKSByZSA9ICdeKD8hJyArIHJlICsgJykuKiQnXG5cbiAgdHJ5IHtcbiAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmUsIGZsYWdzKVxuICB9IGNhdGNoIChleCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBzaG91bGQgYmUgaW1wb3NzaWJsZSAqLyB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICB9XG4gIHJldHVybiB0aGlzLnJlZ2V4cFxufVxuXG5taW5pbWF0Y2gubWF0Y2ggPSBmdW5jdGlvbiAobGlzdCwgcGF0dGVybiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgbW0gPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIGxpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBtbS5tYXRjaChmKVxuICB9KVxuICBpZiAobW0ub3B0aW9ucy5ub251bGwgJiYgIWxpc3QubGVuZ3RoKSB7XG4gICAgbGlzdC5wdXNoKHBhdHRlcm4pXG4gIH1cbiAgcmV0dXJuIGxpc3Rcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoIChmLCBwYXJ0aWFsKSB7XG4gIGlmICh0eXBlb2YgcGFydGlhbCA9PT0gJ3VuZGVmaW5lZCcpIHBhcnRpYWwgPSB0aGlzLnBhcnRpYWxcbiAgdGhpcy5kZWJ1ZygnbWF0Y2gnLCBmLCB0aGlzLnBhdHRlcm4pXG4gIC8vIHNob3J0LWNpcmN1aXQgaW4gdGhlIGNhc2Ugb2YgYnVzdGVkIHRoaW5ncy5cbiAgLy8gY29tbWVudHMsIGV0Yy5cbiAgaWYgKHRoaXMuY29tbWVudCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0aGlzLmVtcHR5KSByZXR1cm4gZiA9PT0gJydcblxuICBpZiAoZiA9PT0gJy8nICYmIHBhcnRpYWwpIHJldHVybiB0cnVlXG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyB3aW5kb3dzOiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgaWYgKHBhdGguc2VwICE9PSAnLycpIHtcbiAgICBmID0gZi5zcGxpdChwYXRoLnNlcCkuam9pbignLycpXG4gIH1cblxuICAvLyB0cmVhdCB0aGUgdGVzdCBwYXRoIGFzIGEgc2V0IG9mIHBhdGhwYXJ0cy5cbiAgZiA9IGYuc3BsaXQoc2xhc2hTcGxpdClcbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzcGxpdCcsIGYpXG5cbiAgLy8ganVzdCBPTkUgb2YgdGhlIHBhdHRlcm4gc2V0cyBpbiB0aGlzLnNldCBuZWVkcyB0byBtYXRjaFxuICAvLyBpbiBvcmRlciBmb3IgaXQgdG8gYmUgdmFsaWQuICBJZiBuZWdhdGluZywgdGhlbiBqdXN0IG9uZVxuICAvLyBtYXRjaCBtZWFucyB0aGF0IHdlIGhhdmUgZmFpbGVkLlxuICAvLyBFaXRoZXIgd2F5LCByZXR1cm4gb24gdGhlIGZpcnN0IGhpdC5cblxuICB2YXIgc2V0ID0gdGhpcy5zZXRcbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzZXQnLCBzZXQpXG5cbiAgLy8gRmluZCB0aGUgYmFzZW5hbWUgb2YgdGhlIHBhdGggYnkgbG9va2luZyBmb3IgdGhlIGxhc3Qgbm9uLWVtcHR5IHNlZ21lbnRcbiAgdmFyIGZpbGVuYW1lXG4gIHZhciBpXG4gIGZvciAoaSA9IGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBmaWxlbmFtZSA9IGZbaV1cbiAgICBpZiAoZmlsZW5hbWUpIGJyZWFrXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhdHRlcm4gPSBzZXRbaV1cbiAgICB2YXIgZmlsZSA9IGZcbiAgICBpZiAob3B0aW9ucy5tYXRjaEJhc2UgJiYgcGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZpbGUgPSBbZmlsZW5hbWVdXG4gICAgfVxuICAgIHZhciBoaXQgPSB0aGlzLm1hdGNoT25lKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwpXG4gICAgaWYgKGhpdCkge1xuICAgICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiAhdGhpcy5uZWdhdGVcbiAgICB9XG4gIH1cblxuICAvLyBkaWRuJ3QgZ2V0IGFueSBoaXRzLiAgdGhpcyBpcyBzdWNjZXNzIGlmIGl0J3MgYSBuZWdhdGl2ZVxuICAvLyBwYXR0ZXJuLCBmYWlsdXJlIG90aGVyd2lzZS5cbiAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiB0aGlzLm5lZ2F0ZVxufVxuXG4vLyBzZXQgcGFydGlhbCB0byB0cnVlIHRvIHRlc3QgaWYsIGZvciBleGFtcGxlLFxuLy8gXCIvYS9iXCIgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgXCIvKi9iLyovZFwiXG4vLyBQYXJ0aWFsIG1lYW5zLCBpZiB5b3UgcnVuIG91dCBvZiBmaWxlIGJlZm9yZSB5b3UgcnVuXG4vLyBvdXQgb2YgcGF0dGVybiwgdGhlbiB0aGF0J3MgZmluZSwgYXMgbG9uZyBhcyBhbGxcbi8vIHRoZSBwYXJ0cyBtYXRjaC5cbk1pbmltYXRjaC5wcm90b3R5cGUubWF0Y2hPbmUgPSBmdW5jdGlvbiAoZmlsZSwgcGF0dGVybiwgcGFydGlhbCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIHRoaXMuZGVidWcoJ21hdGNoT25lJyxcbiAgICB7ICd0aGlzJzogdGhpcywgZmlsZTogZmlsZSwgcGF0dGVybjogcGF0dGVybiB9KVxuXG4gIHRoaXMuZGVidWcoJ21hdGNoT25lJywgZmlsZS5sZW5ndGgsIHBhdHRlcm4ubGVuZ3RoKVxuXG4gIGZvciAodmFyIGZpID0gMCxcbiAgICAgIHBpID0gMCxcbiAgICAgIGZsID0gZmlsZS5sZW5ndGgsXG4gICAgICBwbCA9IHBhdHRlcm4ubGVuZ3RoXG4gICAgICA7IChmaSA8IGZsKSAmJiAocGkgPCBwbClcbiAgICAgIDsgZmkrKywgcGkrKykge1xuICAgIHRoaXMuZGVidWcoJ21hdGNoT25lIGxvb3AnKVxuICAgIHZhciBwID0gcGF0dGVybltwaV1cbiAgICB2YXIgZiA9IGZpbGVbZmldXG5cbiAgICB0aGlzLmRlYnVnKHBhdHRlcm4sIHAsIGYpXG5cbiAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAvLyBzb21lIGludmFsaWQgcmVnZXhwIHN0dWZmIGluIHRoZSBzZXQuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHAgPT09IGZhbHNlKSByZXR1cm4gZmFsc2VcblxuICAgIGlmIChwID09PSBHTE9CU1RBUikge1xuICAgICAgdGhpcy5kZWJ1ZygnR0xPQlNUQVInLCBbcGF0dGVybiwgcCwgZl0pXG5cbiAgICAgIC8vIFwiKipcIlxuICAgICAgLy8gYS8qKi9iLyoqL2Mgd291bGQgbWF0Y2ggdGhlIGZvbGxvd2luZzpcbiAgICAgIC8vIGEvYi94L3kvei9jXG4gICAgICAvLyBhL3gveS96L2IvY1xuICAgICAgLy8gYS9iL3gvYi94L2NcbiAgICAgIC8vIGEvYi9jXG4gICAgICAvLyBUbyBkbyB0aGlzLCB0YWtlIHRoZSByZXN0IG9mIHRoZSBwYXR0ZXJuIGFmdGVyXG4gICAgICAvLyB0aGUgKiosIGFuZCBzZWUgaWYgaXQgd291bGQgbWF0Y2ggdGhlIGZpbGUgcmVtYWluZGVyLlxuICAgICAgLy8gSWYgc28sIHJldHVybiBzdWNjZXNzLlxuICAgICAgLy8gSWYgbm90LCB0aGUgKiogXCJzd2FsbG93c1wiIGEgc2VnbWVudCwgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgIC8vIFRoaXMgaXMgcmVjdXJzaXZlbHkgYXdmdWwuXG4gICAgICAvL1xuICAgICAgLy8gYS8qKi9iLyoqL2MgbWF0Y2hpbmcgYS9iL3gveS96L2NcbiAgICAgIC8vIC0gYSBtYXRjaGVzIGFcbiAgICAgIC8vIC0gZG91Ymxlc3RhclxuICAgICAgLy8gICAtIG1hdGNoT25lKGIveC95L3ovYywgYi8qKi9jKVxuICAgICAgLy8gICAgIC0gYiBtYXRjaGVzIGJcbiAgICAgIC8vICAgICAtIGRvdWJsZXN0YXJcbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeC95L3ovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeS96L2MsIGMpIC0+IG5vXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKHovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoYywgYykgeWVzLCBoaXRcbiAgICAgIHZhciBmciA9IGZpXG4gICAgICB2YXIgcHIgPSBwaSArIDFcbiAgICAgIGlmIChwciA9PT0gcGwpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZygnKiogYXQgdGhlIGVuZCcpXG4gICAgICAgIC8vIGEgKiogYXQgdGhlIGVuZCB3aWxsIGp1c3Qgc3dhbGxvdyB0aGUgcmVzdC5cbiAgICAgICAgLy8gV2UgaGF2ZSBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAvLyBob3dldmVyLCBpdCB3aWxsIG5vdCBzd2FsbG93IC8ueCwgdW5sZXNzXG4gICAgICAgIC8vIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgICAgICAgLy8gLiBhbmQgLi4gYXJlICpuZXZlciogbWF0Y2hlZCBieSAqKiwgZm9yIGV4cGxvc2l2ZWx5XG4gICAgICAgIC8vIGV4cG9uZW50aWFsIHJlYXNvbnMuXG4gICAgICAgIGZvciAoOyBmaSA8IGZsOyBmaSsrKSB7XG4gICAgICAgICAgaWYgKGZpbGVbZmldID09PSAnLicgfHwgZmlsZVtmaV0gPT09ICcuLicgfHxcbiAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgZmlsZVtmaV0uY2hhckF0KDApID09PSAnLicpKSByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICAvLyBvaywgbGV0J3Mgc2VlIGlmIHdlIGNhbiBzd2FsbG93IHdoYXRldmVyIHdlIGNhbi5cbiAgICAgIHdoaWxlIChmciA8IGZsKSB7XG4gICAgICAgIHZhciBzd2FsbG93ZWUgPSBmaWxlW2ZyXVxuXG4gICAgICAgIHRoaXMuZGVidWcoJ1xcbmdsb2JzdGFyIHdoaWxlJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByLCBzd2FsbG93ZWUpXG5cbiAgICAgICAgLy8gWFhYIHJlbW92ZSB0aGlzIHNsaWNlLiAgSnVzdCBwYXNzIHRoZSBzdGFydCBpbmRleC5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2hPbmUoZmlsZS5zbGljZShmciksIHBhdHRlcm4uc2xpY2UocHIpLCBwYXJ0aWFsKSkge1xuICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIGZvdW5kIG1hdGNoIScsIGZyLCBmbCwgc3dhbGxvd2VlKVxuICAgICAgICAgIC8vIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjYW4ndCBzd2FsbG93IFwiLlwiIG9yIFwiLi5cIiBldmVyLlxuICAgICAgICAgIC8vIGNhbiBvbmx5IHN3YWxsb3cgXCIuZm9vXCIgd2hlbiBleHBsaWNpdGx5IGFza2VkLlxuICAgICAgICAgIGlmIChzd2FsbG93ZWUgPT09ICcuJyB8fCBzd2FsbG93ZWUgPT09ICcuLicgfHxcbiAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgc3dhbGxvd2VlLmNoYXJBdCgwKSA9PT0gJy4nKSkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZG90IGRldGVjdGVkIScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gKiogc3dhbGxvd3MgYSBzZWdtZW50LCBhbmQgY29udGludWUuXG4gICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgc3dhbGxvdyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZScpXG4gICAgICAgICAgZnIrK1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIG1hdGNoIHdhcyBmb3VuZC5cbiAgICAgIC8vIEhvd2V2ZXIsIGluIHBhcnRpYWwgbW9kZSwgd2UgY2FuJ3Qgc2F5IHRoaXMgaXMgbmVjZXNzYXJpbHkgb3Zlci5cbiAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSAqcGF0dGVybiogbGVmdCwgdGhlblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGVcbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuPj4+IG5vIG1hdGNoLCBwYXJ0aWFsPycsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgaWYgKGZyID09PSBmbCkgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuICoqXG4gICAgLy8gbm9uLW1hZ2ljIHBhdHRlcm5zIGp1c3QgaGF2ZSB0byBtYXRjaCBleGFjdGx5XG4gICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICB2YXIgaGl0XG4gICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgaGl0ID0gZiA9PT0gcFxuICAgICAgdGhpcy5kZWJ1Zygnc3RyaW5nIG1hdGNoJywgcCwgZiwgaGl0KVxuICAgIH0gZWxzZSB7XG4gICAgICBoaXQgPSBmLm1hdGNoKHApXG4gICAgICB0aGlzLmRlYnVnKCdwYXR0ZXJuIG1hdGNoJywgcCwgZiwgaGl0KVxuICAgIH1cblxuICAgIGlmICghaGl0KSByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIE5vdGU6IGVuZGluZyBpbiAvIG1lYW5zIHRoYXQgd2UnbGwgZ2V0IGEgZmluYWwgXCJcIlxuICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLiAgVGhpcyBjYW4gb25seSBtYXRjaCBhXG4gIC8vIGNvcnJlc3BvbmRpbmcgXCJcIiBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuICAvLyBJZiB0aGUgZmlsZSBlbmRzIGluIC8sIHRoZW4gaXQgY2FuIG9ubHkgbWF0Y2ggYVxuICAvLyBhIHBhdHRlcm4gdGhhdCBlbmRzIGluIC8sIHVubGVzcyB0aGUgcGF0dGVybiBqdXN0XG4gIC8vIGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBmb3IgaXQuIEJ1dCwgYS9iLyBzaG91bGQgKm5vdCpcbiAgLy8gbWF0Y2ggXCJhL2IvKlwiLCBldmVuIHRob3VnaCBcIlwiIG1hdGNoZXMgYWdhaW5zdCB0aGVcbiAgLy8gW14vXSo/IHBhdHRlcm4sIGV4Y2VwdCBpbiBwYXJ0aWFsIG1vZGUsIHdoZXJlIGl0IG1pZ2h0XG4gIC8vIHNpbXBseSBub3QgYmUgcmVhY2hlZCB5ZXQuXG4gIC8vIEhvd2V2ZXIsIGEvYi8gc2hvdWxkIHN0aWxsIHNhdGlzZnkgYS8qXG5cbiAgLy8gbm93IGVpdGhlciB3ZSBmZWxsIG9mZiB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLCBvciB3ZSdyZSBkb25lLlxuICBpZiAoZmkgPT09IGZsICYmIHBpID09PSBwbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiBhbmQgZmlsZW5hbWUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAvLyBhbiBleGFjdCBoaXQhXG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChmaSA9PT0gZmwpIHtcbiAgICAvLyByYW4gb3V0IG9mIGZpbGUsIGJ1dCBzdGlsbCBoYWQgcGF0dGVybiBsZWZ0LlxuICAgIC8vIHRoaXMgaXMgb2sgaWYgd2UncmUgZG9pbmcgdGhlIG1hdGNoIGFzIHBhcnQgb2ZcbiAgICAvLyBhIGdsb2IgZnMgdHJhdmVyc2FsLlxuICAgIHJldHVybiBwYXJ0aWFsXG4gIH0gZWxzZSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLyBpZiAocGkgPT09IHBsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuLCBzdGlsbCBoYXZlIGZpbGUgbGVmdC5cbiAgICAvLyB0aGlzIGlzIG9ubHkgYWNjZXB0YWJsZSBpZiB3ZSdyZSBvbiB0aGUgdmVyeSBsYXN0XG4gICAgLy8gZW1wdHkgc2VnbWVudCBvZiBhIGZpbGUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgIC8vIGEvKiBzaG91bGQgbWF0Y2ggYS9iL1xuICAgIHJldHVybiAoZmkgPT09IGZsIC0gMSkgJiYgKGZpbGVbZmldID09PSAnJylcbiAgfVxuXG4gIC8vIHNob3VsZCBiZSB1bnJlYWNoYWJsZS5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdGhyb3cgbmV3IEVycm9yKCd3dGY/Jylcbn1cblxuLy8gcmVwbGFjZSBzdHVmZiBsaWtlIFxcKiB3aXRoICpcbmZ1bmN0aW9uIGdsb2JVbmVzY2FwZSAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpXG59XG5cbmZ1bmN0aW9uIHJlZ0V4cEVzY2FwZSAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIm1pbmltYXRjaCIsIk1pbmltYXRjaCIsInBhdGgiLCJyZXF1aXJlIiwiZSIsInNlcCIsIkdMT0JTVEFSIiwiZXhwYW5kIiwicGxUeXBlcyIsIm9wZW4iLCJjbG9zZSIsInFtYXJrIiwic3RhciIsInR3b1N0YXJEb3QiLCJ0d29TdGFyTm9Eb3QiLCJyZVNwZWNpYWxzIiwiY2hhclNldCIsInMiLCJzcGxpdCIsInJlZHVjZSIsInNldCIsImMiLCJzbGFzaFNwbGl0IiwiZmlsdGVyIiwicGF0dGVybiIsIm9wdGlvbnMiLCJwIiwiaSIsImxpc3QiLCJleHQiLCJhIiwiYiIsInQiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkZWZhdWx0cyIsImRlZiIsImxlbmd0aCIsIm9yaWciLCJtIiwibWFrZVJlIiwiYnJhY2VFeHBhbmQiLCJtYXRjaCIsImFzc2VydFZhbGlkUGF0dGVybiIsIm5vY29tbWVudCIsImNoYXJBdCIsInRyaW0iLCJhbGxvd1dpbmRvd3NFc2NhcGUiLCJqb2luIiwicmVnZXhwIiwibmVnYXRlIiwiY29tbWVudCIsImVtcHR5IiwicGFydGlhbCIsIm1ha2UiLCJwcm90b3R5cGUiLCJkZWJ1ZyIsInBhcnNlTmVnYXRlIiwiZ2xvYlNldCIsImNvbnNvbGUiLCJlcnJvciIsImFwcGx5IiwiYXJndW1lbnRzIiwiZ2xvYlBhcnRzIiwibWFwIiwic2kiLCJwYXJzZSIsImluZGV4T2YiLCJuZWdhdGVPZmZzZXQiLCJub25lZ2F0ZSIsImwiLCJzdWJzdHIiLCJub2JyYWNlIiwidGVzdCIsIk1BWF9QQVRURVJOX0xFTkdUSCIsIlR5cGVFcnJvciIsIlNVQlBBUlNFIiwiaXNTdWIiLCJub2dsb2JzdGFyIiwicmUiLCJoYXNNYWdpYyIsIm5vY2FzZSIsImVzY2FwaW5nIiwicGF0dGVybkxpc3RTdGFjayIsIm5lZ2F0aXZlTGlzdHMiLCJzdGF0ZUNoYXIiLCJpbkNsYXNzIiwicmVDbGFzc1N0YXJ0IiwiY2xhc3NTdGFydCIsInBhdHRlcm5TdGFydCIsImRvdCIsInNlbGYiLCJjbGVhclN0YXRlQ2hhciIsImxlbiIsIm5vZXh0IiwicHVzaCIsInR5cGUiLCJzdGFydCIsInJlU3RhcnQiLCJwbCIsInBvcCIsInJlRW5kIiwiY3MiLCJzdWJzdHJpbmciLCJSZWdFeHAiLCJlciIsInNwIiwidGFpbCIsInNsaWNlIiwicmVwbGFjZSIsIl8iLCIkMSIsIiQyIiwiYWRkUGF0dGVyblN0YXJ0IiwibiIsIm5sIiwibmxCZWZvcmUiLCJubEZpcnN0IiwibmxMYXN0IiwibmxBZnRlciIsIm9wZW5QYXJlbnNCZWZvcmUiLCJjbGVhbkFmdGVyIiwiZG9sbGFyIiwibmV3UmUiLCJnbG9iVW5lc2NhcGUiLCJmbGFncyIsInJlZ0V4cCIsIl9nbG9iIiwiX3NyYyIsInR3b1N0YXIiLCJyZWdFeHBFc2NhcGUiLCJleCIsIm1tIiwiZiIsIm5vbnVsbCIsImZpbGVuYW1lIiwiZmlsZSIsIm1hdGNoQmFzZSIsImhpdCIsIm1hdGNoT25lIiwiZmxpcE5lZ2F0ZSIsImZpIiwicGkiLCJmbCIsImZyIiwicHIiLCJzd2FsbG93ZWUiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/minimatch.js\n");

/***/ })

};
;