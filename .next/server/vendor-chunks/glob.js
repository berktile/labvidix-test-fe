/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/glob";
exports.ids = ["vendor-chunks/glob"];
exports.modules = {

/***/ "(ssr)/./node_modules/glob/common.js":
/*!*************************************!*\
  !*** ./node_modules/glob/common.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.setopts = setopts;\nexports.ownProp = ownProp;\nexports.makeAbs = makeAbs;\nexports.finish = finish;\nexports.mark = mark;\nexports.isIgnored = isIgnored;\nexports.childrenIgnored = childrenIgnored;\nfunction ownProp(obj, field) {\n    return Object.prototype.hasOwnProperty.call(obj, field);\n}\nvar path = __webpack_require__(/*! path */ \"path\");\nvar minimatch = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/minimatch/minimatch.js\");\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"(ssr)/./node_modules/path-is-absolute/index.js\");\nvar Minimatch = minimatch.Minimatch;\nfunction alphasort(a, b) {\n    return a.localeCompare(b, \"en\");\n}\nfunction setupIgnores(self, options) {\n    self.ignore = options.ignore || [];\n    if (!Array.isArray(self.ignore)) self.ignore = [\n        self.ignore\n    ];\n    if (self.ignore.length) {\n        self.ignore = self.ignore.map(ignoreMap);\n    }\n}\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap(pattern) {\n    var gmatcher = null;\n    if (pattern.slice(-3) === \"/**\") {\n        var gpattern = pattern.replace(/(\\/\\*\\*)+$/, \"\");\n        gmatcher = new Minimatch(gpattern, {\n            dot: true\n        });\n    }\n    return {\n        matcher: new Minimatch(pattern, {\n            dot: true\n        }),\n        gmatcher: gmatcher\n    };\n}\nfunction setopts(self, pattern, options) {\n    if (!options) options = {};\n    // base-matching: just use globstar for that.\n    if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n        if (options.noglobstar) {\n            throw new Error(\"base matching requires globstar\");\n        }\n        pattern = \"**/\" + pattern;\n    }\n    self.silent = !!options.silent;\n    self.pattern = pattern;\n    self.strict = options.strict !== false;\n    self.realpath = !!options.realpath;\n    self.realpathCache = options.realpathCache || Object.create(null);\n    self.follow = !!options.follow;\n    self.dot = !!options.dot;\n    self.mark = !!options.mark;\n    self.nodir = !!options.nodir;\n    if (self.nodir) self.mark = true;\n    self.sync = !!options.sync;\n    self.nounique = !!options.nounique;\n    self.nonull = !!options.nonull;\n    self.nosort = !!options.nosort;\n    self.nocase = !!options.nocase;\n    self.stat = !!options.stat;\n    self.noprocess = !!options.noprocess;\n    self.absolute = !!options.absolute;\n    self.maxLength = options.maxLength || Infinity;\n    self.cache = options.cache || Object.create(null);\n    self.statCache = options.statCache || Object.create(null);\n    self.symlinks = options.symlinks || Object.create(null);\n    setupIgnores(self, options);\n    self.changedCwd = false;\n    var cwd = process.cwd();\n    if (!ownProp(options, \"cwd\")) self.cwd = cwd;\n    else {\n        self.cwd = path.resolve(options.cwd);\n        self.changedCwd = self.cwd !== cwd;\n    }\n    self.root = options.root || path.resolve(self.cwd, \"/\");\n    self.root = path.resolve(self.root);\n    if (process.platform === \"win32\") self.root = self.root.replace(/\\\\/g, \"/\");\n    // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n    // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n    self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);\n    if (process.platform === \"win32\") self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\");\n    self.nomount = !!options.nomount;\n    // disable comments and negation in Minimatch.\n    // Note that they are not supported in Glob itself anyway.\n    options.nonegate = true;\n    options.nocomment = true;\n    self.minimatch = new Minimatch(pattern, options);\n    self.options = self.minimatch.options;\n}\nfunction finish(self) {\n    var nou = self.nounique;\n    var all = nou ? [] : Object.create(null);\n    for(var i = 0, l = self.matches.length; i < l; i++){\n        var matches = self.matches[i];\n        if (!matches || Object.keys(matches).length === 0) {\n            if (self.nonull) {\n                // do like the shell, and spit out the literal glob\n                var literal = self.minimatch.globSet[i];\n                if (nou) all.push(literal);\n                else all[literal] = true;\n            }\n        } else {\n            // had matches\n            var m = Object.keys(matches);\n            if (nou) all.push.apply(all, m);\n            else m.forEach(function(m) {\n                all[m] = true;\n            });\n        }\n    }\n    if (!nou) all = Object.keys(all);\n    if (!self.nosort) all = all.sort(alphasort);\n    // at *some* point we statted all of these\n    if (self.mark) {\n        for(var i = 0; i < all.length; i++){\n            all[i] = self._mark(all[i]);\n        }\n        if (self.nodir) {\n            all = all.filter(function(e) {\n                var notDir = !/\\/$/.test(e);\n                var c = self.cache[e] || self.cache[makeAbs(self, e)];\n                if (notDir && c) notDir = c !== \"DIR\" && !Array.isArray(c);\n                return notDir;\n            });\n        }\n    }\n    if (self.ignore.length) all = all.filter(function(m) {\n        return !isIgnored(self, m);\n    });\n    self.found = all;\n}\nfunction mark(self, p) {\n    var abs = makeAbs(self, p);\n    var c = self.cache[abs];\n    var m = p;\n    if (c) {\n        var isDir = c === \"DIR\" || Array.isArray(c);\n        var slash = p.slice(-1) === \"/\";\n        if (isDir && !slash) m += \"/\";\n        else if (!isDir && slash) m = m.slice(0, -1);\n        if (m !== p) {\n            var mabs = makeAbs(self, m);\n            self.statCache[mabs] = self.statCache[abs];\n            self.cache[mabs] = self.cache[abs];\n        }\n    }\n    return m;\n}\n// lotta situps...\nfunction makeAbs(self, f) {\n    var abs = f;\n    if (f.charAt(0) === \"/\") {\n        abs = path.join(self.root, f);\n    } else if (isAbsolute(f) || f === \"\") {\n        abs = f;\n    } else if (self.changedCwd) {\n        abs = path.resolve(self.cwd, f);\n    } else {\n        abs = path.resolve(f);\n    }\n    if (process.platform === \"win32\") abs = abs.replace(/\\\\/g, \"/\");\n    return abs;\n}\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored(self, path) {\n    if (!self.ignore.length) return false;\n    return self.ignore.some(function(item) {\n        return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));\n    });\n}\nfunction childrenIgnored(self, path) {\n    if (!self.ignore.length) return false;\n    return self.ignore.some(function(item) {\n        return !!(item.gmatcher && item.gmatcher.match(path));\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S3VDLFVBQVUsRUFBRTtRQUMxQitCLE1BQU1oRixLQUFLb0QsT0FBTyxDQUFDMUMsS0FBS3dDLEdBQUcsRUFBRWtDO0lBQy9CLE9BQU87UUFDTEosTUFBTWhGLEtBQUtvRCxPQUFPLENBQUNnQztJQUNyQjtJQUVBLElBQUlqQyxRQUFRRyxRQUFRLEtBQUssU0FDdkIwQixNQUFNQSxJQUFJMUQsT0FBTyxDQUFDLE9BQU87SUFFM0IsT0FBTzBEO0FBQ1Q7QUFHQSwwRkFBMEY7QUFDMUYscUdBQXFHO0FBQ3JHLFNBQVN4RixVQUFXa0IsSUFBSSxFQUFFVixJQUFJO0lBQzVCLElBQUksQ0FBQ1UsS0FBS0UsTUFBTSxDQUFDRyxNQUFNLEVBQ3JCLE9BQU87SUFFVCxPQUFPTCxLQUFLRSxNQUFNLENBQUMyRSxJQUFJLENBQUMsU0FBU0MsSUFBSTtRQUNuQyxPQUFPQSxLQUFLaEUsT0FBTyxDQUFDaUUsS0FBSyxDQUFDekYsU0FBUyxDQUFDLENBQUV3RixDQUFBQSxLQUFLckUsUUFBUSxJQUFJcUUsS0FBS3JFLFFBQVEsQ0FBQ3NFLEtBQUssQ0FBQ3pGLEtBQUk7SUFDakY7QUFDRjtBQUVBLFNBQVNQLGdCQUFpQmlCLElBQUksRUFBRVYsSUFBSTtJQUNsQyxJQUFJLENBQUNVLEtBQUtFLE1BQU0sQ0FBQ0csTUFBTSxFQUNyQixPQUFPO0lBRVQsT0FBT0wsS0FBS0UsTUFBTSxDQUFDMkUsSUFBSSxDQUFDLFNBQVNDLElBQUk7UUFDbkMsT0FBTyxDQUFDLENBQUVBLENBQUFBLEtBQUtyRSxRQUFRLElBQUlxRSxLQUFLckUsUUFBUSxDQUFDc0UsS0FBSyxDQUFDekYsS0FBSTtJQUNyRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFidmlkaXgtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZ2xvYi9jb21tb24uanM/NzZiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLnNldG9wdHMgPSBzZXRvcHRzXG5leHBvcnRzLm93blByb3AgPSBvd25Qcm9wXG5leHBvcnRzLm1ha2VBYnMgPSBtYWtlQWJzXG5leHBvcnRzLmZpbmlzaCA9IGZpbmlzaFxuZXhwb3J0cy5tYXJrID0gbWFya1xuZXhwb3J0cy5pc0lnbm9yZWQgPSBpc0lnbm9yZWRcbmV4cG9ydHMuY2hpbGRyZW5JZ25vcmVkID0gY2hpbGRyZW5JZ25vcmVkXG5cbmZ1bmN0aW9uIG93blByb3AgKG9iaiwgZmllbGQpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGZpZWxkKVxufVxuXG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpXG52YXIgbWluaW1hdGNoID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKVxudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKFwicGF0aC1pcy1hYnNvbHV0ZVwiKVxudmFyIE1pbmltYXRjaCA9IG1pbmltYXRjaC5NaW5pbWF0Y2hcblxuZnVuY3Rpb24gYWxwaGFzb3J0IChhLCBiKSB7XG4gIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYiwgJ2VuJylcbn1cblxuZnVuY3Rpb24gc2V0dXBJZ25vcmVzIChzZWxmLCBvcHRpb25zKSB7XG4gIHNlbGYuaWdub3JlID0gb3B0aW9ucy5pZ25vcmUgfHwgW11cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoc2VsZi5pZ25vcmUpKVxuICAgIHNlbGYuaWdub3JlID0gW3NlbGYuaWdub3JlXVxuXG4gIGlmIChzZWxmLmlnbm9yZS5sZW5ndGgpIHtcbiAgICBzZWxmLmlnbm9yZSA9IHNlbGYuaWdub3JlLm1hcChpZ25vcmVNYXApXG4gIH1cbn1cblxuLy8gaWdub3JlIHBhdHRlcm5zIGFyZSBhbHdheXMgaW4gZG90OnRydWUgbW9kZS5cbmZ1bmN0aW9uIGlnbm9yZU1hcCAocGF0dGVybikge1xuICB2YXIgZ21hdGNoZXIgPSBudWxsXG4gIGlmIChwYXR0ZXJuLnNsaWNlKC0zKSA9PT0gJy8qKicpIHtcbiAgICB2YXIgZ3BhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoLyhcXC9cXCpcXCopKyQvLCAnJylcbiAgICBnbWF0Y2hlciA9IG5ldyBNaW5pbWF0Y2goZ3BhdHRlcm4sIHsgZG90OiB0cnVlIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hdGNoZXI6IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgeyBkb3Q6IHRydWUgfSksXG4gICAgZ21hdGNoZXI6IGdtYXRjaGVyXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0b3B0cyAoc2VsZiwgcGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgLy8gYmFzZS1tYXRjaGluZzoganVzdCB1c2UgZ2xvYnN0YXIgZm9yIHRoYXQuXG4gIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiAtMSA9PT0gcGF0dGVybi5pbmRleE9mKFwiL1wiKSkge1xuICAgIGlmIChvcHRpb25zLm5vZ2xvYnN0YXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhc2UgbWF0Y2hpbmcgcmVxdWlyZXMgZ2xvYnN0YXJcIilcbiAgICB9XG4gICAgcGF0dGVybiA9IFwiKiovXCIgKyBwYXR0ZXJuXG4gIH1cblxuICBzZWxmLnNpbGVudCA9ICEhb3B0aW9ucy5zaWxlbnRcbiAgc2VsZi5wYXR0ZXJuID0gcGF0dGVyblxuICBzZWxmLnN0cmljdCA9IG9wdGlvbnMuc3RyaWN0ICE9PSBmYWxzZVxuICBzZWxmLnJlYWxwYXRoID0gISFvcHRpb25zLnJlYWxwYXRoXG4gIHNlbGYucmVhbHBhdGhDYWNoZSA9IG9wdGlvbnMucmVhbHBhdGhDYWNoZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHNlbGYuZm9sbG93ID0gISFvcHRpb25zLmZvbGxvd1xuICBzZWxmLmRvdCA9ICEhb3B0aW9ucy5kb3RcbiAgc2VsZi5tYXJrID0gISFvcHRpb25zLm1hcmtcbiAgc2VsZi5ub2RpciA9ICEhb3B0aW9ucy5ub2RpclxuICBpZiAoc2VsZi5ub2RpcilcbiAgICBzZWxmLm1hcmsgPSB0cnVlXG4gIHNlbGYuc3luYyA9ICEhb3B0aW9ucy5zeW5jXG4gIHNlbGYubm91bmlxdWUgPSAhIW9wdGlvbnMubm91bmlxdWVcbiAgc2VsZi5ub251bGwgPSAhIW9wdGlvbnMubm9udWxsXG4gIHNlbGYubm9zb3J0ID0gISFvcHRpb25zLm5vc29ydFxuICBzZWxmLm5vY2FzZSA9ICEhb3B0aW9ucy5ub2Nhc2VcbiAgc2VsZi5zdGF0ID0gISFvcHRpb25zLnN0YXRcbiAgc2VsZi5ub3Byb2Nlc3MgPSAhIW9wdGlvbnMubm9wcm9jZXNzXG4gIHNlbGYuYWJzb2x1dGUgPSAhIW9wdGlvbnMuYWJzb2x1dGVcblxuICBzZWxmLm1heExlbmd0aCA9IG9wdGlvbnMubWF4TGVuZ3RoIHx8IEluZmluaXR5XG4gIHNlbGYuY2FjaGUgPSBvcHRpb25zLmNhY2hlIHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgc2VsZi5zdGF0Q2FjaGUgPSBvcHRpb25zLnN0YXRDYWNoZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHNlbGYuc3ltbGlua3MgPSBvcHRpb25zLnN5bWxpbmtzIHx8IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBzZXR1cElnbm9yZXMoc2VsZiwgb3B0aW9ucylcblxuICBzZWxmLmNoYW5nZWRDd2QgPSBmYWxzZVxuICB2YXIgY3dkID0gcHJvY2Vzcy5jd2QoKVxuICBpZiAoIW93blByb3Aob3B0aW9ucywgXCJjd2RcIikpXG4gICAgc2VsZi5jd2QgPSBjd2RcbiAgZWxzZSB7XG4gICAgc2VsZi5jd2QgPSBwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QpXG4gICAgc2VsZi5jaGFuZ2VkQ3dkID0gc2VsZi5jd2QgIT09IGN3ZFxuICB9XG5cbiAgc2VsZi5yb290ID0gb3B0aW9ucy5yb290IHx8IHBhdGgucmVzb2x2ZShzZWxmLmN3ZCwgXCIvXCIpXG4gIHNlbGYucm9vdCA9IHBhdGgucmVzb2x2ZShzZWxmLnJvb3QpXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpXG4gICAgc2VsZi5yb290ID0gc2VsZi5yb290LnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG5cbiAgLy8gVE9ETzogaXMgYW4gYWJzb2x1dGUgYGN3ZGAgc3VwcG9zZWQgdG8gYmUgcmVzb2x2ZWQgYWdhaW5zdCBgcm9vdGA/XG4gIC8vIGUuZy4geyBjd2Q6ICcvdGVzdCcsIHJvb3Q6IF9fZGlybmFtZSB9ID09PSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnL3Rlc3QnKVxuICBzZWxmLmN3ZEFicyA9IGlzQWJzb2x1dGUoc2VsZi5jd2QpID8gc2VsZi5jd2QgOiBtYWtlQWJzKHNlbGYsIHNlbGYuY3dkKVxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKVxuICAgIHNlbGYuY3dkQWJzID0gc2VsZi5jd2RBYnMucmVwbGFjZSgvXFxcXC9nLCBcIi9cIilcbiAgc2VsZi5ub21vdW50ID0gISFvcHRpb25zLm5vbW91bnRcblxuICAvLyBkaXNhYmxlIGNvbW1lbnRzIGFuZCBuZWdhdGlvbiBpbiBNaW5pbWF0Y2guXG4gIC8vIE5vdGUgdGhhdCB0aGV5IGFyZSBub3Qgc3VwcG9ydGVkIGluIEdsb2IgaXRzZWxmIGFueXdheS5cbiAgb3B0aW9ucy5ub25lZ2F0ZSA9IHRydWVcbiAgb3B0aW9ucy5ub2NvbW1lbnQgPSB0cnVlXG5cbiAgc2VsZi5taW5pbWF0Y2ggPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIHNlbGYub3B0aW9ucyA9IHNlbGYubWluaW1hdGNoLm9wdGlvbnNcbn1cblxuZnVuY3Rpb24gZmluaXNoIChzZWxmKSB7XG4gIHZhciBub3UgPSBzZWxmLm5vdW5pcXVlXG4gIHZhciBhbGwgPSBub3UgPyBbXSA6IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGYubWF0Y2hlcy5sZW5ndGg7IGkgPCBsOyBpICsrKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBzZWxmLm1hdGNoZXNbaV1cbiAgICBpZiAoIW1hdGNoZXMgfHwgT2JqZWN0LmtleXMobWF0Y2hlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoc2VsZi5ub251bGwpIHtcbiAgICAgICAgLy8gZG8gbGlrZSB0aGUgc2hlbGwsIGFuZCBzcGl0IG91dCB0aGUgbGl0ZXJhbCBnbG9iXG4gICAgICAgIHZhciBsaXRlcmFsID0gc2VsZi5taW5pbWF0Y2guZ2xvYlNldFtpXVxuICAgICAgICBpZiAobm91KVxuICAgICAgICAgIGFsbC5wdXNoKGxpdGVyYWwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBhbGxbbGl0ZXJhbF0gPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhZCBtYXRjaGVzXG4gICAgICB2YXIgbSA9IE9iamVjdC5rZXlzKG1hdGNoZXMpXG4gICAgICBpZiAobm91KVxuICAgICAgICBhbGwucHVzaC5hcHBseShhbGwsIG0pXG4gICAgICBlbHNlXG4gICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIGFsbFttXSA9IHRydWVcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpZiAoIW5vdSlcbiAgICBhbGwgPSBPYmplY3Qua2V5cyhhbGwpXG5cbiAgaWYgKCFzZWxmLm5vc29ydClcbiAgICBhbGwgPSBhbGwuc29ydChhbHBoYXNvcnQpXG5cbiAgLy8gYXQgKnNvbWUqIHBvaW50IHdlIHN0YXR0ZWQgYWxsIG9mIHRoZXNlXG4gIGlmIChzZWxmLm1hcmspIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgYWxsW2ldID0gc2VsZi5fbWFyayhhbGxbaV0pXG4gICAgfVxuICAgIGlmIChzZWxmLm5vZGlyKSB7XG4gICAgICBhbGwgPSBhbGwuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBub3REaXIgPSAhKC9cXC8kLy50ZXN0KGUpKVxuICAgICAgICB2YXIgYyA9IHNlbGYuY2FjaGVbZV0gfHwgc2VsZi5jYWNoZVttYWtlQWJzKHNlbGYsIGUpXVxuICAgICAgICBpZiAobm90RGlyICYmIGMpXG4gICAgICAgICAgbm90RGlyID0gYyAhPT0gJ0RJUicgJiYgIUFycmF5LmlzQXJyYXkoYylcbiAgICAgICAgcmV0dXJuIG5vdERpclxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5pZ25vcmUubGVuZ3RoKVxuICAgIGFsbCA9IGFsbC5maWx0ZXIoZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuICFpc0lnbm9yZWQoc2VsZiwgbSlcbiAgICB9KVxuXG4gIHNlbGYuZm91bmQgPSBhbGxcbn1cblxuZnVuY3Rpb24gbWFyayAoc2VsZiwgcCkge1xuICB2YXIgYWJzID0gbWFrZUFicyhzZWxmLCBwKVxuICB2YXIgYyA9IHNlbGYuY2FjaGVbYWJzXVxuICB2YXIgbSA9IHBcbiAgaWYgKGMpIHtcbiAgICB2YXIgaXNEaXIgPSBjID09PSAnRElSJyB8fCBBcnJheS5pc0FycmF5KGMpXG4gICAgdmFyIHNsYXNoID0gcC5zbGljZSgtMSkgPT09ICcvJ1xuXG4gICAgaWYgKGlzRGlyICYmICFzbGFzaClcbiAgICAgIG0gKz0gJy8nXG4gICAgZWxzZSBpZiAoIWlzRGlyICYmIHNsYXNoKVxuICAgICAgbSA9IG0uc2xpY2UoMCwgLTEpXG5cbiAgICBpZiAobSAhPT0gcCkge1xuICAgICAgdmFyIG1hYnMgPSBtYWtlQWJzKHNlbGYsIG0pXG4gICAgICBzZWxmLnN0YXRDYWNoZVttYWJzXSA9IHNlbGYuc3RhdENhY2hlW2Fic11cbiAgICAgIHNlbGYuY2FjaGVbbWFic10gPSBzZWxmLmNhY2hlW2Fic11cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbVxufVxuXG4vLyBsb3R0YSBzaXR1cHMuLi5cbmZ1bmN0aW9uIG1ha2VBYnMgKHNlbGYsIGYpIHtcbiAgdmFyIGFicyA9IGZcbiAgaWYgKGYuY2hhckF0KDApID09PSAnLycpIHtcbiAgICBhYnMgPSBwYXRoLmpvaW4oc2VsZi5yb290LCBmKVxuICB9IGVsc2UgaWYgKGlzQWJzb2x1dGUoZikgfHwgZiA9PT0gJycpIHtcbiAgICBhYnMgPSBmXG4gIH0gZWxzZSBpZiAoc2VsZi5jaGFuZ2VkQ3dkKSB7XG4gICAgYWJzID0gcGF0aC5yZXNvbHZlKHNlbGYuY3dkLCBmKVxuICB9IGVsc2Uge1xuICAgIGFicyA9IHBhdGgucmVzb2x2ZShmKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpXG4gICAgYWJzID0gYWJzLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIHJldHVybiBhYnNcbn1cblxuXG4vLyBSZXR1cm4gdHJ1ZSwgaWYgcGF0dGVybiBlbmRzIHdpdGggZ2xvYnN0YXIgJyoqJywgZm9yIHRoZSBhY2NvbXBhbnlpbmcgcGFyZW50IGRpcmVjdG9yeS5cbi8vIEV4Oi0gSWYgbm9kZV9tb2R1bGVzLyoqIGlzIHRoZSBwYXR0ZXJuLCBhZGQgJ25vZGVfbW9kdWxlcycgdG8gaWdub3JlIGxpc3QgYWxvbmcgd2l0aCBpdCdzIGNvbnRlbnRzXG5mdW5jdGlvbiBpc0lnbm9yZWQgKHNlbGYsIHBhdGgpIHtcbiAgaWYgKCFzZWxmLmlnbm9yZS5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHNlbGYuaWdub3JlLnNvbWUoZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtLm1hdGNoZXIubWF0Y2gocGF0aCkgfHwgISEoaXRlbS5nbWF0Y2hlciAmJiBpdGVtLmdtYXRjaGVyLm1hdGNoKHBhdGgpKVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGlsZHJlbklnbm9yZWQgKHNlbGYsIHBhdGgpIHtcbiAgaWYgKCFzZWxmLmlnbm9yZS5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHNlbGYuaWdub3JlLnNvbWUoZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiAhIShpdGVtLmdtYXRjaGVyICYmIGl0ZW0uZ21hdGNoZXIubWF0Y2gocGF0aCkpXG4gIH0pXG59XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsInNldG9wdHMiLCJvd25Qcm9wIiwibWFrZUFicyIsImZpbmlzaCIsIm1hcmsiLCJpc0lnbm9yZWQiLCJjaGlsZHJlbklnbm9yZWQiLCJvYmoiLCJmaWVsZCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInBhdGgiLCJyZXF1aXJlIiwibWluaW1hdGNoIiwiaXNBYnNvbHV0ZSIsIk1pbmltYXRjaCIsImFscGhhc29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsInNldHVwSWdub3JlcyIsInNlbGYiLCJvcHRpb25zIiwiaWdub3JlIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwibWFwIiwiaWdub3JlTWFwIiwicGF0dGVybiIsImdtYXRjaGVyIiwic2xpY2UiLCJncGF0dGVybiIsInJlcGxhY2UiLCJkb3QiLCJtYXRjaGVyIiwibWF0Y2hCYXNlIiwiaW5kZXhPZiIsIm5vZ2xvYnN0YXIiLCJFcnJvciIsInNpbGVudCIsInN0cmljdCIsInJlYWxwYXRoIiwicmVhbHBhdGhDYWNoZSIsImNyZWF0ZSIsImZvbGxvdyIsIm5vZGlyIiwic3luYyIsIm5vdW5pcXVlIiwibm9udWxsIiwibm9zb3J0Iiwibm9jYXNlIiwic3RhdCIsIm5vcHJvY2VzcyIsImFic29sdXRlIiwibWF4TGVuZ3RoIiwiSW5maW5pdHkiLCJjYWNoZSIsInN0YXRDYWNoZSIsInN5bWxpbmtzIiwiY2hhbmdlZEN3ZCIsImN3ZCIsInByb2Nlc3MiLCJyZXNvbHZlIiwicm9vdCIsInBsYXRmb3JtIiwiY3dkQWJzIiwibm9tb3VudCIsIm5vbmVnYXRlIiwibm9jb21tZW50Iiwibm91IiwiYWxsIiwiaSIsImwiLCJtYXRjaGVzIiwia2V5cyIsImxpdGVyYWwiLCJnbG9iU2V0IiwicHVzaCIsIm0iLCJhcHBseSIsImZvckVhY2giLCJzb3J0IiwiX21hcmsiLCJmaWx0ZXIiLCJlIiwibm90RGlyIiwidGVzdCIsImMiLCJmb3VuZCIsInAiLCJhYnMiLCJpc0RpciIsInNsYXNoIiwibWFicyIsImYiLCJjaGFyQXQiLCJqb2luIiwic29tZSIsIml0ZW0iLCJtYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/glob/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/glob/glob.js":
/*!***********************************!*\
  !*** ./node_modules/glob/glob.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\nmodule.exports = glob;\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar rp = __webpack_require__(/*! fs.realpath */ \"(ssr)/./node_modules/fs.realpath/index.js\");\nvar minimatch = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/minimatch/minimatch.js\");\nvar Minimatch = minimatch.Minimatch;\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar path = __webpack_require__(/*! path */ \"path\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"(ssr)/./node_modules/path-is-absolute/index.js\");\nvar globSync = __webpack_require__(/*! ./sync.js */ \"(ssr)/./node_modules/glob/sync.js\");\nvar common = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/glob/common.js\");\nvar setopts = common.setopts;\nvar ownProp = common.ownProp;\nvar inflight = __webpack_require__(/*! inflight */ \"(ssr)/./node_modules/inflight/inflight.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar childrenIgnored = common.childrenIgnored;\nvar isIgnored = common.isIgnored;\nvar once = __webpack_require__(/*! once */ \"(ssr)/./node_modules/once/once.js\");\nfunction glob(pattern, options, cb) {\n    if (typeof options === \"function\") cb = options, options = {};\n    if (!options) options = {};\n    if (options.sync) {\n        if (cb) throw new TypeError(\"callback provided to sync glob\");\n        return globSync(pattern, options);\n    }\n    return new Glob(pattern, options, cb);\n}\nglob.sync = globSync;\nvar GlobSync = glob.GlobSync = globSync.GlobSync;\n// old api surface\nglob.glob = glob;\nfunction extend(origin, add) {\n    if (add === null || typeof add !== \"object\") {\n        return origin;\n    }\n    var keys = Object.keys(add);\n    var i = keys.length;\n    while(i--){\n        origin[keys[i]] = add[keys[i]];\n    }\n    return origin;\n}\nglob.hasMagic = function(pattern, options_) {\n    var options = extend({}, options_);\n    options.noprocess = true;\n    var g = new Glob(pattern, options);\n    var set = g.minimatch.set;\n    if (!pattern) return false;\n    if (set.length > 1) return true;\n    for(var j = 0; j < set[0].length; j++){\n        if (typeof set[0][j] !== \"string\") return true;\n    }\n    return false;\n};\nglob.Glob = Glob;\ninherits(Glob, EE);\nfunction Glob(pattern, options, cb) {\n    if (typeof options === \"function\") {\n        cb = options;\n        options = null;\n    }\n    if (options && options.sync) {\n        if (cb) throw new TypeError(\"callback provided to sync glob\");\n        return new GlobSync(pattern, options);\n    }\n    if (!(this instanceof Glob)) return new Glob(pattern, options, cb);\n    setopts(this, pattern, options);\n    this._didRealPath = false;\n    // process each pattern in the minimatch set\n    var n = this.minimatch.set.length;\n    // The matches are stored as {<filename>: true,...} so that\n    // duplicates are automagically pruned.\n    // Later, we do an Object.keys() on these.\n    // Keep them as a list so we can fill in when nonull is set.\n    this.matches = new Array(n);\n    if (typeof cb === \"function\") {\n        cb = once(cb);\n        this.on(\"error\", cb);\n        this.on(\"end\", function(matches) {\n            cb(null, matches);\n        });\n    }\n    var self = this;\n    this._processing = 0;\n    this._emitQueue = [];\n    this._processQueue = [];\n    this.paused = false;\n    if (this.noprocess) return this;\n    if (n === 0) return done();\n    var sync = true;\n    for(var i = 0; i < n; i++){\n        this._process(this.minimatch.set[i], i, false, done);\n    }\n    sync = false;\n    function done() {\n        --self._processing;\n        if (self._processing <= 0) {\n            if (sync) {\n                process.nextTick(function() {\n                    self._finish();\n                });\n            } else {\n                self._finish();\n            }\n        }\n    }\n}\nGlob.prototype._finish = function() {\n    assert(this instanceof Glob);\n    if (this.aborted) return;\n    if (this.realpath && !this._didRealpath) return this._realpath();\n    common.finish(this);\n    this.emit(\"end\", this.found);\n};\nGlob.prototype._realpath = function() {\n    if (this._didRealpath) return;\n    this._didRealpath = true;\n    var n = this.matches.length;\n    if (n === 0) return this._finish();\n    var self = this;\n    for(var i = 0; i < this.matches.length; i++)this._realpathSet(i, next);\n    function next() {\n        if (--n === 0) self._finish();\n    }\n};\nGlob.prototype._realpathSet = function(index, cb) {\n    var matchset = this.matches[index];\n    if (!matchset) return cb();\n    var found = Object.keys(matchset);\n    var self = this;\n    var n = found.length;\n    if (n === 0) return cb();\n    var set = this.matches[index] = Object.create(null);\n    found.forEach(function(p, i) {\n        // If there's a problem with the stat, then it means that\n        // one or more of the links in the realpath couldn't be\n        // resolved.  just return the abs value in that case.\n        p = self._makeAbs(p);\n        rp.realpath(p, self.realpathCache, function(er, real) {\n            if (!er) set[real] = true;\n            else if (er.syscall === \"stat\") set[p] = true;\n            else self.emit(\"error\", er) // srsly wtf right here\n            ;\n            if (--n === 0) {\n                self.matches[index] = set;\n                cb();\n            }\n        });\n    });\n};\nGlob.prototype._mark = function(p) {\n    return common.mark(this, p);\n};\nGlob.prototype._makeAbs = function(f) {\n    return common.makeAbs(this, f);\n};\nGlob.prototype.abort = function() {\n    this.aborted = true;\n    this.emit(\"abort\");\n};\nGlob.prototype.pause = function() {\n    if (!this.paused) {\n        this.paused = true;\n        this.emit(\"pause\");\n    }\n};\nGlob.prototype.resume = function() {\n    if (this.paused) {\n        this.emit(\"resume\");\n        this.paused = false;\n        if (this._emitQueue.length) {\n            var eq = this._emitQueue.slice(0);\n            this._emitQueue.length = 0;\n            for(var i = 0; i < eq.length; i++){\n                var e = eq[i];\n                this._emitMatch(e[0], e[1]);\n            }\n        }\n        if (this._processQueue.length) {\n            var pq = this._processQueue.slice(0);\n            this._processQueue.length = 0;\n            for(var i = 0; i < pq.length; i++){\n                var p = pq[i];\n                this._processing--;\n                this._process(p[0], p[1], p[2], p[3]);\n            }\n        }\n    }\n};\nGlob.prototype._process = function(pattern, index, inGlobStar, cb) {\n    assert(this instanceof Glob);\n    assert(typeof cb === \"function\");\n    if (this.aborted) return;\n    this._processing++;\n    if (this.paused) {\n        this._processQueue.push([\n            pattern,\n            index,\n            inGlobStar,\n            cb\n        ]);\n        return;\n    }\n    //console.error('PROCESS %d', this._processing, pattern)\n    // Get the first [n] parts of pattern that are all strings.\n    var n = 0;\n    while(typeof pattern[n] === \"string\"){\n        n++;\n    }\n    // now n is the index of the first one that is *not* a string.\n    // see if there's anything else\n    var prefix;\n    switch(n){\n        // if not, then this is rather simple\n        case pattern.length:\n            this._processSimple(pattern.join(\"/\"), index, cb);\n            return;\n        case 0:\n            // pattern *starts* with some non-trivial item.\n            // going to readdir(cwd), but not include the prefix in matches.\n            prefix = null;\n            break;\n        default:\n            // pattern has some string bits in the front.\n            // whatever it starts with, whether that's 'absolute' like /foo/bar,\n            // or 'relative' like '../baz'\n            prefix = pattern.slice(0, n).join(\"/\");\n            break;\n    }\n    var remain = pattern.slice(n);\n    // get the list of entries.\n    var read;\n    if (prefix === null) read = \".\";\n    else if (isAbsolute(prefix) || isAbsolute(pattern.join(\"/\"))) {\n        if (!prefix || !isAbsolute(prefix)) prefix = \"/\" + prefix;\n        read = prefix;\n    } else read = prefix;\n    var abs = this._makeAbs(read);\n    //if ignored, skip _processing\n    if (childrenIgnored(this, read)) return cb();\n    var isGlobStar = remain[0] === minimatch.GLOBSTAR;\n    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);\n    else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);\n};\nGlob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {\n    var self = this;\n    this._readdir(abs, inGlobStar, function(er, entries) {\n        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);\n    });\n};\nGlob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n    // if the abs isn't a dir, then nothing can match!\n    if (!entries) return cb();\n    // It will only match dot entries if it starts with a dot, or if\n    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n    var pn = remain[0];\n    var negate = !!this.minimatch.negate;\n    var rawGlob = pn._glob;\n    var dotOk = this.dot || rawGlob.charAt(0) === \".\";\n    var matchedEntries = [];\n    for(var i = 0; i < entries.length; i++){\n        var e = entries[i];\n        if (e.charAt(0) !== \".\" || dotOk) {\n            var m;\n            if (negate && !prefix) {\n                m = !e.match(pn);\n            } else {\n                m = e.match(pn);\n            }\n            if (m) matchedEntries.push(e);\n        }\n    }\n    //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n    var len = matchedEntries.length;\n    // If there are no matched entries, then nothing matches.\n    if (len === 0) return cb();\n    // if this is the last remaining pattern bit, then no need for\n    // an additional stat *unless* the user has specified mark or\n    // stat explicitly.  We know they exist, since readdir returned\n    // them.\n    if (remain.length === 1 && !this.mark && !this.stat) {\n        if (!this.matches[index]) this.matches[index] = Object.create(null);\n        for(var i = 0; i < len; i++){\n            var e = matchedEntries[i];\n            if (prefix) {\n                if (prefix !== \"/\") e = prefix + \"/\" + e;\n                else e = prefix + e;\n            }\n            if (e.charAt(0) === \"/\" && !this.nomount) {\n                e = path.join(this.root, e);\n            }\n            this._emitMatch(index, e);\n        }\n        // This was the last one, and no stats were needed\n        return cb();\n    }\n    // now test all matched entries as stand-ins for that part\n    // of the pattern.\n    remain.shift();\n    for(var i = 0; i < len; i++){\n        var e = matchedEntries[i];\n        var newPattern;\n        if (prefix) {\n            if (prefix !== \"/\") e = prefix + \"/\" + e;\n            else e = prefix + e;\n        }\n        this._process([\n            e\n        ].concat(remain), index, inGlobStar, cb);\n    }\n    cb();\n};\nGlob.prototype._emitMatch = function(index, e) {\n    if (this.aborted) return;\n    if (isIgnored(this, e)) return;\n    if (this.paused) {\n        this._emitQueue.push([\n            index,\n            e\n        ]);\n        return;\n    }\n    var abs = isAbsolute(e) ? e : this._makeAbs(e);\n    if (this.mark) e = this._mark(e);\n    if (this.absolute) e = abs;\n    if (this.matches[index][e]) return;\n    if (this.nodir) {\n        var c = this.cache[abs];\n        if (c === \"DIR\" || Array.isArray(c)) return;\n    }\n    this.matches[index][e] = true;\n    var st = this.statCache[abs];\n    if (st) this.emit(\"stat\", e, st);\n    this.emit(\"match\", e);\n};\nGlob.prototype._readdirInGlobStar = function(abs, cb) {\n    if (this.aborted) return;\n    // follow all symlinked directories forever\n    // just proceed as if this is a non-globstar situation\n    if (this.follow) return this._readdir(abs, false, cb);\n    var lstatkey = \"lstat\\x00\" + abs;\n    var self = this;\n    var lstatcb = inflight(lstatkey, lstatcb_);\n    if (lstatcb) fs.lstat(abs, lstatcb);\n    function lstatcb_(er, lstat) {\n        if (er && er.code === \"ENOENT\") return cb();\n        var isSym = lstat && lstat.isSymbolicLink();\n        self.symlinks[abs] = isSym;\n        // If it's not a symlink or a dir, then it's definitely a regular file.\n        // don't bother doing a readdir in that case.\n        if (!isSym && lstat && !lstat.isDirectory()) {\n            self.cache[abs] = \"FILE\";\n            cb();\n        } else self._readdir(abs, false, cb);\n    }\n};\nGlob.prototype._readdir = function(abs, inGlobStar, cb) {\n    if (this.aborted) return;\n    cb = inflight(\"readdir\\x00\" + abs + \"\\x00\" + inGlobStar, cb);\n    if (!cb) return;\n    //console.error('RD %j %j', +inGlobStar, abs)\n    if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);\n    if (ownProp(this.cache, abs)) {\n        var c = this.cache[abs];\n        if (!c || c === \"FILE\") return cb();\n        if (Array.isArray(c)) return cb(null, c);\n    }\n    var self = this;\n    fs.readdir(abs, readdirCb(this, abs, cb));\n};\nfunction readdirCb(self, abs, cb) {\n    return function(er, entries) {\n        if (er) self._readdirError(abs, er, cb);\n        else self._readdirEntries(abs, entries, cb);\n    };\n}\nGlob.prototype._readdirEntries = function(abs, entries, cb) {\n    if (this.aborted) return;\n    // if we haven't asked to stat everything, then just\n    // assume that everything in there exists, so we can avoid\n    // having to stat it a second time.\n    if (!this.mark && !this.stat) {\n        for(var i = 0; i < entries.length; i++){\n            var e = entries[i];\n            if (abs === \"/\") e = abs + e;\n            else e = abs + \"/\" + e;\n            this.cache[e] = true;\n        }\n    }\n    this.cache[abs] = entries;\n    return cb(null, entries);\n};\nGlob.prototype._readdirError = function(f, er, cb) {\n    if (this.aborted) return;\n    // handle errors, and cache the information\n    switch(er.code){\n        case \"ENOTSUP\":\n        case \"ENOTDIR\":\n            var abs = this._makeAbs(f);\n            this.cache[abs] = \"FILE\";\n            if (abs === this.cwdAbs) {\n                var error = new Error(er.code + \" invalid cwd \" + this.cwd);\n                error.path = this.cwd;\n                error.code = er.code;\n                this.emit(\"error\", error);\n                this.abort();\n            }\n            break;\n        case \"ENOENT\":\n        case \"ELOOP\":\n        case \"ENAMETOOLONG\":\n        case \"UNKNOWN\":\n            this.cache[this._makeAbs(f)] = false;\n            break;\n        default:\n            this.cache[this._makeAbs(f)] = false;\n            if (this.strict) {\n                this.emit(\"error\", er);\n                // If the error is handled, then we abort\n                // if not, we threw out of here\n                this.abort();\n            }\n            if (!this.silent) console.error(\"glob error\", er);\n            break;\n    }\n    return cb();\n};\nGlob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {\n    var self = this;\n    this._readdir(abs, inGlobStar, function(er, entries) {\n        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);\n    });\n};\nGlob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n    //console.error('pgs2', prefix, remain[0], entries)\n    // no entries means not a dir, so it can never have matches\n    // foo.txt/** doesn't match foo.txt\n    if (!entries) return cb();\n    // test without the globstar, and with every child both below\n    // and replacing the globstar.\n    var remainWithoutGlobStar = remain.slice(1);\n    var gspref = prefix ? [\n        prefix\n    ] : [];\n    var noGlobStar = gspref.concat(remainWithoutGlobStar);\n    // the noGlobStar pattern exits the inGlobStar state\n    this._process(noGlobStar, index, false, cb);\n    var isSym = this.symlinks[abs];\n    var len = entries.length;\n    // If it's a symlink, and we're in a globstar, then stop\n    if (isSym && inGlobStar) return cb();\n    for(var i = 0; i < len; i++){\n        var e = entries[i];\n        if (e.charAt(0) === \".\" && !this.dot) continue;\n        // these two cases enter the inGlobStar state\n        var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n        this._process(instead, index, true, cb);\n        var below = gspref.concat(entries[i], remain);\n        this._process(below, index, true, cb);\n    }\n    cb();\n};\nGlob.prototype._processSimple = function(prefix, index, cb) {\n    // XXX review this.  Shouldn't it be doing the mounting etc\n    // before doing stat?  kinda weird?\n    var self = this;\n    this._stat(prefix, function(er, exists) {\n        self._processSimple2(prefix, index, er, exists, cb);\n    });\n};\nGlob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {\n    //console.error('ps2', prefix, exists)\n    if (!this.matches[index]) this.matches[index] = Object.create(null);\n    // If it doesn't exist, then just mark the lack of results\n    if (!exists) return cb();\n    if (prefix && isAbsolute(prefix) && !this.nomount) {\n        var trail = /[\\/\\\\]$/.test(prefix);\n        if (prefix.charAt(0) === \"/\") {\n            prefix = path.join(this.root, prefix);\n        } else {\n            prefix = path.resolve(this.root, prefix);\n            if (trail) prefix += \"/\";\n        }\n    }\n    if (process.platform === \"win32\") prefix = prefix.replace(/\\\\/g, \"/\");\n    // Mark this as a match\n    this._emitMatch(index, prefix);\n    cb();\n};\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function(f, cb) {\n    var abs = this._makeAbs(f);\n    var needDir = f.slice(-1) === \"/\";\n    if (f.length > this.maxLength) return cb();\n    if (!this.stat && ownProp(this.cache, abs)) {\n        var c = this.cache[abs];\n        if (Array.isArray(c)) c = \"DIR\";\n        // It exists, but maybe not how we need it\n        if (!needDir || c === \"DIR\") return cb(null, c);\n        if (needDir && c === \"FILE\") return cb();\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n    }\n    var exists;\n    var stat = this.statCache[abs];\n    if (stat !== undefined) {\n        if (stat === false) return cb(null, stat);\n        else {\n            var type = stat.isDirectory() ? \"DIR\" : \"FILE\";\n            if (needDir && type === \"FILE\") return cb();\n            else return cb(null, type, stat);\n        }\n    }\n    var self = this;\n    var statcb = inflight(\"stat\\x00\" + abs, lstatcb_);\n    if (statcb) fs.lstat(abs, statcb);\n    function lstatcb_(er, lstat) {\n        if (lstat && lstat.isSymbolicLink()) {\n            // If it's a symlink, then treat it as the target, unless\n            // the target does not exist, then treat it as a file.\n            return fs.stat(abs, function(er, stat) {\n                if (er) self._stat2(f, abs, null, lstat, cb);\n                else self._stat2(f, abs, er, stat, cb);\n            });\n        } else {\n            self._stat2(f, abs, er, lstat, cb);\n        }\n    }\n};\nGlob.prototype._stat2 = function(f, abs, er, stat, cb) {\n    if (er && (er.code === \"ENOENT\" || er.code === \"ENOTDIR\")) {\n        this.statCache[abs] = false;\n        return cb();\n    }\n    var needDir = f.slice(-1) === \"/\";\n    this.statCache[abs] = stat;\n    if (abs.slice(-1) === \"/\" && stat && !stat.isDirectory()) return cb(null, false, stat);\n    var c = true;\n    if (stat) c = stat.isDirectory() ? \"DIR\" : \"FILE\";\n    this.cache[abs] = this.cache[abs] || c;\n    if (needDir && c === \"FILE\") return cb();\n    return cb(null, c, stat);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQUUsRUFBRXlDLElBQUksRUFBRTNGLEVBQUU7SUFDcEQsSUFBSWtELE1BQU9BLENBQUFBLEdBQUc0RCxJQUFJLEtBQUssWUFBWTVELEdBQUc0RCxJQUFJLEtBQUssU0FBUSxHQUFJO1FBQ3pELElBQUksQ0FBQ1AsU0FBUyxDQUFDL0IsSUFBSSxHQUFHO1FBQ3RCLE9BQU94RTtJQUNUO0lBRUEsSUFBSTRJLFVBQVVyRixFQUFFTSxLQUFLLENBQUMsQ0FBQyxPQUFPO0lBQzlCLElBQUksQ0FBQzBDLFNBQVMsQ0FBQy9CLElBQUksR0FBR21CO0lBRXRCLElBQUluQixJQUFJWCxLQUFLLENBQUMsQ0FBQyxPQUFPLE9BQU84QixRQUFRLENBQUNBLEtBQUt1QixXQUFXLElBQ3BELE9BQU9sSCxHQUFHLE1BQU0sT0FBTzJGO0lBRXpCLElBQUlRLElBQUk7SUFDUixJQUFJUixNQUNGUSxJQUFJUixLQUFLdUIsV0FBVyxLQUFLLFFBQVE7SUFDbkMsSUFBSSxDQUFDZCxLQUFLLENBQUM1QixJQUFJLEdBQUcsSUFBSSxDQUFDNEIsS0FBSyxDQUFDNUIsSUFBSSxJQUFJMkI7SUFFckMsSUFBSXlDLFdBQVd6QyxNQUFNLFFBQ25CLE9BQU9uRztJQUVULE9BQU9BLEdBQUcsTUFBTW1HLEdBQUdSO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFidmlkaXgtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZ2xvYi9nbG9iLmpzPzQxYmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQXBwcm9hY2g6XG4vL1xuLy8gMS4gR2V0IHRoZSBtaW5pbWF0Y2ggc2V0XG4vLyAyLiBGb3IgZWFjaCBwYXR0ZXJuIGluIHRoZSBzZXQsIFBST0NFU1MocGF0dGVybiwgZmFsc2UpXG4vLyAzLiBTdG9yZSBtYXRjaGVzIHBlci1zZXQsIHRoZW4gdW5pcSB0aGVtXG4vL1xuLy8gUFJPQ0VTUyhwYXR0ZXJuLCBpbkdsb2JTdGFyKVxuLy8gR2V0IHRoZSBmaXJzdCBbbl0gaXRlbXMgZnJvbSBwYXR0ZXJuIHRoYXQgYXJlIGFsbCBzdHJpbmdzXG4vLyBKb2luIHRoZXNlIHRvZ2V0aGVyLiAgVGhpcyBpcyBQUkVGSVguXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1vcmUgcmVtYWluaW5nLCB0aGVuIHN0YXQoUFJFRklYKSBhbmRcbi8vICAgYWRkIHRvIG1hdGNoZXMgaWYgaXQgc3VjY2VlZHMuICBFTkQuXG4vL1xuLy8gSWYgaW5HbG9iU3RhciBhbmQgUFJFRklYIGlzIHN5bWxpbmsgYW5kIHBvaW50cyB0byBkaXJcbi8vICAgc2V0IEVOVFJJRVMgPSBbXVxuLy8gZWxzZSByZWFkZGlyKFBSRUZJWCkgYXMgRU5UUklFU1xuLy8gICBJZiBmYWlsLCBFTkRcbi8vXG4vLyB3aXRoIEVOVFJJRVNcbi8vICAgSWYgcGF0dGVybltuXSBpcyBHTE9CU1RBUlxuLy8gICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgZ2xvYnN0YXIgbWF0Y2ggaXMgZW1wdHlcbi8vICAgICAvLyBieSBwcnVuaW5nIGl0IG91dCwgYW5kIHRlc3RpbmcgdGhlIHJlc3VsdGluZyBwYXR0ZXJuXG4vLyAgICAgUFJPQ0VTUyhwYXR0ZXJuWzAuLm5dICsgcGF0dGVybltuKzEgLi4gJF0sIGZhbHNlKVxuLy8gICAgIC8vIGhhbmRsZSBvdGhlciBjYXNlcy5cbi8vICAgICBmb3IgRU5UUlkgaW4gRU5UUklFUyAobm90IGRvdGZpbGVzKVxuLy8gICAgICAgLy8gYXR0YWNoIGdsb2JzdGFyICsgdGFpbCBvbnRvIHRoZSBlbnRyeVxuLy8gICAgICAgLy8gTWFyayB0aGF0IHRoaXMgZW50cnkgaXMgYSBnbG9ic3RhciBtYXRjaFxuLy8gICAgICAgUFJPQ0VTUyhwYXR0ZXJuWzAuLm5dICsgRU5UUlkgKyBwYXR0ZXJuW24gLi4gJF0sIHRydWUpXG4vL1xuLy8gICBlbHNlIC8vIG5vdCBnbG9ic3RhclxuLy8gICAgIGZvciBFTlRSWSBpbiBFTlRSSUVTIChub3QgZG90ZmlsZXMsIHVubGVzcyBwYXR0ZXJuW25dIGlzIGRvdClcbi8vICAgICAgIFRlc3QgRU5UUlkgYWdhaW5zdCBwYXR0ZXJuW25dXG4vLyAgICAgICBJZiBmYWlscywgY29udGludWVcbi8vICAgICAgIElmIHBhc3NlcywgUFJPQ0VTUyhwYXR0ZXJuWzAuLm5dICsgaXRlbSArIHBhdHRlcm5bbisxIC4uICRdKVxuLy9cbi8vIENhdmVhdDpcbi8vICAgQ2FjaGUgYWxsIHN0YXRzIGFuZCByZWFkZGlycyByZXN1bHRzIHRvIG1pbmltaXplIHN5c2NhbGwuICBTaW5jZSBhbGxcbi8vICAgd2UgZXZlciBjYXJlIGFib3V0IGlzIGV4aXN0ZW5jZSBhbmQgZGlyZWN0b3J5LW5lc3MsIHdlIGNhbiBqdXN0IGtlZXBcbi8vICAgYHRydWVgIGZvciBmaWxlcywgYW5kIFtjaGlsZHJlbiwuLi5dIGZvciBkaXJlY3Rvcmllcywgb3IgYGZhbHNlYCBmb3Jcbi8vICAgdGhpbmdzIHRoYXQgZG9uJ3QgZXhpc3QuXG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYlxuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcnAgPSByZXF1aXJlKCdmcy5yZWFscGF0aCcpXG52YXIgbWluaW1hdGNoID0gcmVxdWlyZSgnbWluaW1hdGNoJylcbnZhciBNaW5pbWF0Y2ggPSBtaW5pbWF0Y2guTWluaW1hdGNoXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBpc0Fic29sdXRlID0gcmVxdWlyZSgncGF0aC1pcy1hYnNvbHV0ZScpXG52YXIgZ2xvYlN5bmMgPSByZXF1aXJlKCcuL3N5bmMuanMnKVxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJylcbnZhciBzZXRvcHRzID0gY29tbW9uLnNldG9wdHNcbnZhciBvd25Qcm9wID0gY29tbW9uLm93blByb3BcbnZhciBpbmZsaWdodCA9IHJlcXVpcmUoJ2luZmxpZ2h0JylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG52YXIgY2hpbGRyZW5JZ25vcmVkID0gY29tbW9uLmNoaWxkcmVuSWdub3JlZFxudmFyIGlzSWdub3JlZCA9IGNvbW1vbi5pc0lnbm9yZWRcblxudmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcblxuZnVuY3Rpb24gZ2xvYiAocGF0dGVybiwgb3B0aW9ucywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSB7fVxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gIGlmIChvcHRpb25zLnN5bmMpIHtcbiAgICBpZiAoY2IpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2InKVxuICAgIHJldHVybiBnbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMsIGNiKVxufVxuXG5nbG9iLnN5bmMgPSBnbG9iU3luY1xudmFyIEdsb2JTeW5jID0gZ2xvYi5HbG9iU3luYyA9IGdsb2JTeW5jLkdsb2JTeW5jXG5cbi8vIG9sZCBhcGkgc3VyZmFjZVxuZ2xvYi5nbG9iID0gZ2xvYlxuXG5mdW5jdGlvbiBleHRlbmQgKG9yaWdpbiwgYWRkKSB7XG4gIGlmIChhZGQgPT09IG51bGwgfHwgdHlwZW9mIGFkZCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3JpZ2luXG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZClcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dXG4gIH1cbiAgcmV0dXJuIG9yaWdpblxufVxuXG5nbG9iLmhhc01hZ2ljID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnNfKSB7XG4gIHZhciBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zXylcbiAgb3B0aW9ucy5ub3Byb2Nlc3MgPSB0cnVlXG5cbiAgdmFyIGcgPSBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zKVxuICB2YXIgc2V0ID0gZy5taW5pbWF0Y2guc2V0XG5cbiAgaWYgKCFwYXR0ZXJuKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGlmIChzZXQubGVuZ3RoID4gMSlcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgc2V0WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgaWYgKHR5cGVvZiBzZXRbMF1bal0gIT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5nbG9iLkdsb2IgPSBHbG9iXG5pbmhlcml0cyhHbG9iLCBFRSlcbmZ1bmN0aW9uIEdsb2IgKHBhdHRlcm4sIG9wdGlvbnMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBudWxsXG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN5bmMpIHtcbiAgICBpZiAoY2IpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2InKVxuICAgIHJldHVybiBuZXcgR2xvYlN5bmMocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHbG9iKSlcbiAgICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucywgY2IpXG5cbiAgc2V0b3B0cyh0aGlzLCBwYXR0ZXJuLCBvcHRpb25zKVxuICB0aGlzLl9kaWRSZWFsUGF0aCA9IGZhbHNlXG5cbiAgLy8gcHJvY2VzcyBlYWNoIHBhdHRlcm4gaW4gdGhlIG1pbmltYXRjaCBzZXRcbiAgdmFyIG4gPSB0aGlzLm1pbmltYXRjaC5zZXQubGVuZ3RoXG5cbiAgLy8gVGhlIG1hdGNoZXMgYXJlIHN0b3JlZCBhcyB7PGZpbGVuYW1lPjogdHJ1ZSwuLi59IHNvIHRoYXRcbiAgLy8gZHVwbGljYXRlcyBhcmUgYXV0b21hZ2ljYWxseSBwcnVuZWQuXG4gIC8vIExhdGVyLCB3ZSBkbyBhbiBPYmplY3Qua2V5cygpIG9uIHRoZXNlLlxuICAvLyBLZWVwIHRoZW0gYXMgYSBsaXN0IHNvIHdlIGNhbiBmaWxsIGluIHdoZW4gbm9udWxsIGlzIHNldC5cbiAgdGhpcy5tYXRjaGVzID0gbmV3IEFycmF5KG4pXG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb25jZShjYilcbiAgICB0aGlzLm9uKCdlcnJvcicsIGNiKVxuICAgIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uIChtYXRjaGVzKSB7XG4gICAgICBjYihudWxsLCBtYXRjaGVzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcHJvY2Vzc2luZyA9IDBcblxuICB0aGlzLl9lbWl0UXVldWUgPSBbXVxuICB0aGlzLl9wcm9jZXNzUXVldWUgPSBbXVxuICB0aGlzLnBhdXNlZCA9IGZhbHNlXG5cbiAgaWYgKHRoaXMubm9wcm9jZXNzKVxuICAgIHJldHVybiB0aGlzXG5cbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIGRvbmUoKVxuXG4gIHZhciBzeW5jID0gdHJ1ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkgKyspIHtcbiAgICB0aGlzLl9wcm9jZXNzKHRoaXMubWluaW1hdGNoLnNldFtpXSwgaSwgZmFsc2UsIGRvbmUpXG4gIH1cbiAgc3luYyA9IGZhbHNlXG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgLS1zZWxmLl9wcm9jZXNzaW5nXG4gICAgaWYgKHNlbGYuX3Byb2Nlc3NpbmcgPD0gMCkge1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5fZmluaXNoKClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX2ZpbmlzaCgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgR2xvYilcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5yZWFscGF0aCAmJiAhdGhpcy5fZGlkUmVhbHBhdGgpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWxwYXRoKClcblxuICBjb21tb24uZmluaXNoKHRoaXMpXG4gIHRoaXMuZW1pdCgnZW5kJywgdGhpcy5mb3VuZClcbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWxwYXRoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlkUmVhbHBhdGgpXG4gICAgcmV0dXJuXG5cbiAgdGhpcy5fZGlkUmVhbHBhdGggPSB0cnVlXG5cbiAgdmFyIG4gPSB0aGlzLm1hdGNoZXMubGVuZ3RoXG4gIGlmIChuID09PSAwKVxuICAgIHJldHVybiB0aGlzLl9maW5pc2goKVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWF0Y2hlcy5sZW5ndGg7IGkrKylcbiAgICB0aGlzLl9yZWFscGF0aFNldChpLCBuZXh0KVxuXG4gIGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIGlmICgtLW4gPT09IDApXG4gICAgICBzZWxmLl9maW5pc2goKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFscGF0aFNldCA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgdmFyIG1hdGNoc2V0ID0gdGhpcy5tYXRjaGVzW2luZGV4XVxuICBpZiAoIW1hdGNoc2V0KVxuICAgIHJldHVybiBjYigpXG5cbiAgdmFyIGZvdW5kID0gT2JqZWN0LmtleXMobWF0Y2hzZXQpXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgbiA9IGZvdW5kLmxlbmd0aFxuXG4gIGlmIChuID09PSAwKVxuICAgIHJldHVybiBjYigpXG5cbiAgdmFyIHNldCA9IHRoaXMubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIGZvdW5kLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAvLyBJZiB0aGVyZSdzIGEgcHJvYmxlbSB3aXRoIHRoZSBzdGF0LCB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICAvLyBvbmUgb3IgbW9yZSBvZiB0aGUgbGlua3MgaW4gdGhlIHJlYWxwYXRoIGNvdWxkbid0IGJlXG4gICAgLy8gcmVzb2x2ZWQuICBqdXN0IHJldHVybiB0aGUgYWJzIHZhbHVlIGluIHRoYXQgY2FzZS5cbiAgICBwID0gc2VsZi5fbWFrZUFicyhwKVxuICAgIHJwLnJlYWxwYXRoKHAsIHNlbGYucmVhbHBhdGhDYWNoZSwgZnVuY3Rpb24gKGVyLCByZWFsKSB7XG4gICAgICBpZiAoIWVyKVxuICAgICAgICBzZXRbcmVhbF0gPSB0cnVlXG4gICAgICBlbHNlIGlmIChlci5zeXNjYWxsID09PSAnc3RhdCcpXG4gICAgICAgIHNldFtwXSA9IHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVyKSAvLyBzcnNseSB3dGYgcmlnaHQgaGVyZVxuXG4gICAgICBpZiAoLS1uID09PSAwKSB7XG4gICAgICAgIHNlbGYubWF0Y2hlc1tpbmRleF0gPSBzZXRcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG5cbkdsb2IucHJvdG90eXBlLl9tYXJrID0gZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIGNvbW1vbi5tYXJrKHRoaXMsIHApXG59XG5cbkdsb2IucHJvdG90eXBlLl9tYWtlQWJzID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIGNvbW1vbi5tYWtlQWJzKHRoaXMsIGYpXG59XG5cbkdsb2IucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFib3J0ZWQgPSB0cnVlXG4gIHRoaXMuZW1pdCgnYWJvcnQnKVxufVxuXG5HbG9iLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgIHRoaXMucGF1c2VkID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgncGF1c2UnKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKVxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgICBpZiAodGhpcy5fZW1pdFF1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIGVxID0gdGhpcy5fZW1pdFF1ZXVlLnNsaWNlKDApXG4gICAgICB0aGlzLl9lbWl0UXVldWUubGVuZ3RoID0gMFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcS5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIGUgPSBlcVtpXVxuICAgICAgICB0aGlzLl9lbWl0TWF0Y2goZVswXSwgZVsxXSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHZhciBwcSA9IHRoaXMuX3Byb2Nlc3NRdWV1ZS5zbGljZSgwKVxuICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlLmxlbmd0aCA9IDBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHEubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHZhciBwID0gcHFbaV1cbiAgICAgICAgdGhpcy5fcHJvY2Vzc2luZy0tXG4gICAgICAgIHRoaXMuX3Byb2Nlc3MocFswXSwgcFsxXSwgcFsyXSwgcFszXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3MgPSBmdW5jdGlvbiAocGF0dGVybiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKSB7XG4gIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgR2xvYilcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIHRoaXMuX3Byb2Nlc3NpbmcrK1xuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLl9wcm9jZXNzUXVldWUucHVzaChbcGF0dGVybiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiXSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vY29uc29sZS5lcnJvcignUFJPQ0VTUyAlZCcsIHRoaXMuX3Byb2Nlc3NpbmcsIHBhdHRlcm4pXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBbbl0gcGFydHMgb2YgcGF0dGVybiB0aGF0IGFyZSBhbGwgc3RyaW5ncy5cbiAgdmFyIG4gPSAwXG4gIHdoaWxlICh0eXBlb2YgcGF0dGVybltuXSA9PT0gJ3N0cmluZycpIHtcbiAgICBuICsrXG4gIH1cbiAgLy8gbm93IG4gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyAqbm90KiBhIHN0cmluZy5cblxuICAvLyBzZWUgaWYgdGhlcmUncyBhbnl0aGluZyBlbHNlXG4gIHZhciBwcmVmaXhcbiAgc3dpdGNoIChuKSB7XG4gICAgLy8gaWYgbm90LCB0aGVuIHRoaXMgaXMgcmF0aGVyIHNpbXBsZVxuICAgIGNhc2UgcGF0dGVybi5sZW5ndGg6XG4gICAgICB0aGlzLl9wcm9jZXNzU2ltcGxlKHBhdHRlcm4uam9pbignLycpLCBpbmRleCwgY2IpXG4gICAgICByZXR1cm5cblxuICAgIGNhc2UgMDpcbiAgICAgIC8vIHBhdHRlcm4gKnN0YXJ0cyogd2l0aCBzb21lIG5vbi10cml2aWFsIGl0ZW0uXG4gICAgICAvLyBnb2luZyB0byByZWFkZGlyKGN3ZCksIGJ1dCBub3QgaW5jbHVkZSB0aGUgcHJlZml4IGluIG1hdGNoZXMuXG4gICAgICBwcmVmaXggPSBudWxsXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHBhdHRlcm4gaGFzIHNvbWUgc3RyaW5nIGJpdHMgaW4gdGhlIGZyb250LlxuICAgICAgLy8gd2hhdGV2ZXIgaXQgc3RhcnRzIHdpdGgsIHdoZXRoZXIgdGhhdCdzICdhYnNvbHV0ZScgbGlrZSAvZm9vL2JhcixcbiAgICAgIC8vIG9yICdyZWxhdGl2ZScgbGlrZSAnLi4vYmF6J1xuICAgICAgcHJlZml4ID0gcGF0dGVybi5zbGljZSgwLCBuKS5qb2luKCcvJylcbiAgICAgIGJyZWFrXG4gIH1cblxuICB2YXIgcmVtYWluID0gcGF0dGVybi5zbGljZShuKVxuXG4gIC8vIGdldCB0aGUgbGlzdCBvZiBlbnRyaWVzLlxuICB2YXIgcmVhZFxuICBpZiAocHJlZml4ID09PSBudWxsKVxuICAgIHJlYWQgPSAnLidcbiAgZWxzZSBpZiAoaXNBYnNvbHV0ZShwcmVmaXgpIHx8IGlzQWJzb2x1dGUocGF0dGVybi5qb2luKCcvJykpKSB7XG4gICAgaWYgKCFwcmVmaXggfHwgIWlzQWJzb2x1dGUocHJlZml4KSlcbiAgICAgIHByZWZpeCA9ICcvJyArIHByZWZpeFxuICAgIHJlYWQgPSBwcmVmaXhcbiAgfSBlbHNlXG4gICAgcmVhZCA9IHByZWZpeFxuXG4gIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKHJlYWQpXG5cbiAgLy9pZiBpZ25vcmVkLCBza2lwIF9wcm9jZXNzaW5nXG4gIGlmIChjaGlsZHJlbklnbm9yZWQodGhpcywgcmVhZCkpXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgaXNHbG9iU3RhciA9IHJlbWFpblswXSA9PT0gbWluaW1hdGNoLkdMT0JTVEFSXG4gIGlmIChpc0dsb2JTdGFyKVxuICAgIHRoaXMuX3Byb2Nlc3NHbG9iU3RhcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG4gIGVsc2VcbiAgICB0aGlzLl9wcm9jZXNzUmVhZGRpcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzUmVhZGRpciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyLCBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICByZXR1cm4gc2VsZi5fcHJvY2Vzc1JlYWRkaXIyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBlbnRyaWVzLCBjYilcbiAgfSlcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NSZWFkZGlyMiA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpIHtcblxuICAvLyBpZiB0aGUgYWJzIGlzbid0IGEgZGlyLCB0aGVuIG5vdGhpbmcgY2FuIG1hdGNoIVxuICBpZiAoIWVudHJpZXMpXG4gICAgcmV0dXJuIGNiKClcblxuICAvLyBJdCB3aWxsIG9ubHkgbWF0Y2ggZG90IGVudHJpZXMgaWYgaXQgc3RhcnRzIHdpdGggYSBkb3QsIG9yIGlmXG4gIC8vIGRvdCBpcyBzZXQuICBTdHVmZiBsaWtlIEAoLmZvb3wuYmFyKSBpc24ndCBhbGxvd2VkLlxuICB2YXIgcG4gPSByZW1haW5bMF1cbiAgdmFyIG5lZ2F0ZSA9ICEhdGhpcy5taW5pbWF0Y2gubmVnYXRlXG4gIHZhciByYXdHbG9iID0gcG4uX2dsb2JcbiAgdmFyIGRvdE9rID0gdGhpcy5kb3QgfHwgcmF3R2xvYi5jaGFyQXQoMCkgPT09ICcuJ1xuXG4gIHZhciBtYXRjaGVkRW50cmllcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSAhPT0gJy4nIHx8IGRvdE9rKSB7XG4gICAgICB2YXIgbVxuICAgICAgaWYgKG5lZ2F0ZSAmJiAhcHJlZml4KSB7XG4gICAgICAgIG0gPSAhZS5tYXRjaChwbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBlLm1hdGNoKHBuKVxuICAgICAgfVxuICAgICAgaWYgKG0pXG4gICAgICAgIG1hdGNoZWRFbnRyaWVzLnB1c2goZSlcbiAgICB9XG4gIH1cblxuICAvL2NvbnNvbGUuZXJyb3IoJ3ByZDInLCBwcmVmaXgsIGVudHJpZXMsIHJlbWFpblswXS5fZ2xvYiwgbWF0Y2hlZEVudHJpZXMpXG5cbiAgdmFyIGxlbiA9IG1hdGNoZWRFbnRyaWVzLmxlbmd0aFxuICAvLyBJZiB0aGVyZSBhcmUgbm8gbWF0Y2hlZCBlbnRyaWVzLCB0aGVuIG5vdGhpbmcgbWF0Y2hlcy5cbiAgaWYgKGxlbiA9PT0gMClcbiAgICByZXR1cm4gY2IoKVxuXG4gIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgcmVtYWluaW5nIHBhdHRlcm4gYml0LCB0aGVuIG5vIG5lZWQgZm9yXG4gIC8vIGFuIGFkZGl0aW9uYWwgc3RhdCAqdW5sZXNzKiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIG1hcmsgb3JcbiAgLy8gc3RhdCBleHBsaWNpdGx5LiAgV2Uga25vdyB0aGV5IGV4aXN0LCBzaW5jZSByZWFkZGlyIHJldHVybmVkXG4gIC8vIHRoZW0uXG5cbiAgaWYgKHJlbWFpbi5sZW5ndGggPT09IDEgJiYgIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoZXNbaW5kZXhdKVxuICAgICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgICB2YXIgZSA9IG1hdGNoZWRFbnRyaWVzW2ldXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09ICcvJylcbiAgICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZSA9IHByZWZpeCArIGVcbiAgICAgIH1cblxuICAgICAgaWYgKGUuY2hhckF0KDApID09PSAnLycgJiYgIXRoaXMubm9tb3VudCkge1xuICAgICAgICBlID0gcGF0aC5qb2luKHRoaXMucm9vdCwgZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgZSlcbiAgICB9XG4gICAgLy8gVGhpcyB3YXMgdGhlIGxhc3Qgb25lLCBhbmQgbm8gc3RhdHMgd2VyZSBuZWVkZWRcbiAgICByZXR1cm4gY2IoKVxuICB9XG5cbiAgLy8gbm93IHRlc3QgYWxsIG1hdGNoZWQgZW50cmllcyBhcyBzdGFuZC1pbnMgZm9yIHRoYXQgcGFydFxuICAvLyBvZiB0aGUgcGF0dGVybi5cbiAgcmVtYWluLnNoaWZ0KClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKyspIHtcbiAgICB2YXIgZSA9IG1hdGNoZWRFbnRyaWVzW2ldXG4gICAgdmFyIG5ld1BhdHRlcm5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBpZiAocHJlZml4ICE9PSAnLycpXG4gICAgICAgIGUgPSBwcmVmaXggKyAnLycgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBwcmVmaXggKyBlXG4gICAgfVxuICAgIHRoaXMuX3Byb2Nlc3MoW2VdLmNvbmNhdChyZW1haW4pLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG4gIH1cbiAgY2IoKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fZW1pdE1hdGNoID0gZnVuY3Rpb24gKGluZGV4LCBlKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgaWYgKGlzSWdub3JlZCh0aGlzLCBlKSlcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLl9lbWl0UXVldWUucHVzaChbaW5kZXgsIGVdKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGFicyA9IGlzQWJzb2x1dGUoZSkgPyBlIDogdGhpcy5fbWFrZUFicyhlKVxuXG4gIGlmICh0aGlzLm1hcmspXG4gICAgZSA9IHRoaXMuX21hcmsoZSlcblxuICBpZiAodGhpcy5hYnNvbHV0ZSlcbiAgICBlID0gYWJzXG5cbiAgaWYgKHRoaXMubWF0Y2hlc1tpbmRleF1bZV0pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHRoaXMubm9kaXIpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuICAgIGlmIChjID09PSAnRElSJyB8fCBBcnJheS5pc0FycmF5KGMpKVxuICAgICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLm1hdGNoZXNbaW5kZXhdW2VdID0gdHJ1ZVxuXG4gIHZhciBzdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKHN0KVxuICAgIHRoaXMuZW1pdCgnc3RhdCcsIGUsIHN0KVxuXG4gIHRoaXMuZW1pdCgnbWF0Y2gnLCBlKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckluR2xvYlN0YXIgPSBmdW5jdGlvbiAoYWJzLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGZvbGxvdyBhbGwgc3ltbGlua2VkIGRpcmVjdG9yaWVzIGZvcmV2ZXJcbiAgLy8ganVzdCBwcm9jZWVkIGFzIGlmIHRoaXMgaXMgYSBub24tZ2xvYnN0YXIgc2l0dWF0aW9uXG4gIGlmICh0aGlzLmZvbGxvdylcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpcihhYnMsIGZhbHNlLCBjYilcblxuICB2YXIgbHN0YXRrZXkgPSAnbHN0YXRcXDAnICsgYWJzXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgbHN0YXRjYiA9IGluZmxpZ2h0KGxzdGF0a2V5LCBsc3RhdGNiXylcblxuICBpZiAobHN0YXRjYilcbiAgICBmcy5sc3RhdChhYnMsIGxzdGF0Y2IpXG5cbiAgZnVuY3Rpb24gbHN0YXRjYl8gKGVyLCBsc3RhdCkge1xuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICB2YXIgaXNTeW0gPSBsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpXG4gICAgc2VsZi5zeW1saW5rc1thYnNdID0gaXNTeW1cblxuICAgIC8vIElmIGl0J3Mgbm90IGEgc3ltbGluayBvciBhIGRpciwgdGhlbiBpdCdzIGRlZmluaXRlbHkgYSByZWd1bGFyIGZpbGUuXG4gICAgLy8gZG9uJ3QgYm90aGVyIGRvaW5nIGEgcmVhZGRpciBpbiB0aGF0IGNhc2UuXG4gICAgaWYgKCFpc1N5bSAmJiBsc3RhdCAmJiAhbHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgc2VsZi5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBjYigpXG4gICAgfSBlbHNlXG4gICAgICBzZWxmLl9yZWFkZGlyKGFicywgZmFsc2UsIGNiKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyID0gZnVuY3Rpb24gKGFicywgaW5HbG9iU3RhciwgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICBjYiA9IGluZmxpZ2h0KCdyZWFkZGlyXFwwJythYnMrJ1xcMCcraW5HbG9iU3RhciwgY2IpXG4gIGlmICghY2IpXG4gICAgcmV0dXJuXG5cbiAgLy9jb25zb2xlLmVycm9yKCdSRCAlaiAlaicsICtpbkdsb2JTdGFyLCBhYnMpXG4gIGlmIChpbkdsb2JTdGFyICYmICFvd25Qcm9wKHRoaXMuc3ltbGlua3MsIGFicykpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXJJbkdsb2JTdGFyKGFicywgY2IpXG5cbiAgaWYgKG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKCFjIHx8IGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVybiBjYihudWxsLCBjKVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGZzLnJlYWRkaXIoYWJzLCByZWFkZGlyQ2IodGhpcywgYWJzLCBjYikpXG59XG5cbmZ1bmN0aW9uIHJlYWRkaXJDYiAoc2VsZiwgYWJzLCBjYikge1xuICByZXR1cm4gZnVuY3Rpb24gKGVyLCBlbnRyaWVzKSB7XG4gICAgaWYgKGVyKVxuICAgICAgc2VsZi5fcmVhZGRpckVycm9yKGFicywgZXIsIGNiKVxuICAgIGVsc2VcbiAgICAgIHNlbGYuX3JlYWRkaXJFbnRyaWVzKGFicywgZW50cmllcywgY2IpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWRkaXJFbnRyaWVzID0gZnVuY3Rpb24gKGFicywgZW50cmllcywgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICAvLyBpZiB3ZSBoYXZlbid0IGFza2VkIHRvIHN0YXQgZXZlcnl0aGluZywgdGhlbiBqdXN0XG4gIC8vIGFzc3VtZSB0aGF0IGV2ZXJ5dGhpbmcgaW4gdGhlcmUgZXhpc3RzLCBzbyB3ZSBjYW4gYXZvaWRcbiAgLy8gaGF2aW5nIHRvIHN0YXQgaXQgYSBzZWNvbmQgdGltZS5cbiAgaWYgKCF0aGlzLm1hcmsgJiYgIXRoaXMuc3RhdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgICAgaWYgKGFicyA9PT0gJy8nKVxuICAgICAgICBlID0gYWJzICsgZVxuICAgICAgZWxzZVxuICAgICAgICBlID0gYWJzICsgJy8nICsgZVxuICAgICAgdGhpcy5jYWNoZVtlXSA9IHRydWVcbiAgICB9XG4gIH1cblxuICB0aGlzLmNhY2hlW2Fic10gPSBlbnRyaWVzXG4gIHJldHVybiBjYihudWxsLCBlbnRyaWVzKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckVycm9yID0gZnVuY3Rpb24gKGYsIGVyLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGhhbmRsZSBlcnJvcnMsIGFuZCBjYWNoZSB0aGUgaW5mb3JtYXRpb25cbiAgc3dpdGNoIChlci5jb2RlKSB7XG4gICAgY2FzZSAnRU5PVFNVUCc6IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8yMDVcbiAgICBjYXNlICdFTk9URElSJzogLy8gdG90YWxseSBub3JtYWwuIG1lYW5zIGl0ICpkb2VzKiBleGlzdC5cbiAgICAgIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKGYpXG4gICAgICB0aGlzLmNhY2hlW2Fic10gPSAnRklMRSdcbiAgICAgIGlmIChhYnMgPT09IHRoaXMuY3dkQWJzKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihlci5jb2RlICsgJyBpbnZhbGlkIGN3ZCAnICsgdGhpcy5jd2QpXG4gICAgICAgIGVycm9yLnBhdGggPSB0aGlzLmN3ZFxuICAgICAgICBlcnJvci5jb2RlID0gZXIuY29kZVxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gICAgICAgIHRoaXMuYWJvcnQoKVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ0VOT0VOVCc6IC8vIG5vdCB0ZXJyaWJseSB1bnVzdWFsXG4gICAgY2FzZSAnRUxPT1AnOlxuICAgIGNhc2UgJ0VOQU1FVE9PTE9ORyc6XG4gICAgY2FzZSAnVU5LTk9XTic6XG4gICAgICB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZildID0gZmFsc2VcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OiAvLyBzb21lIHVudXN1YWwgZXJyb3IuICBUcmVhdCBhcyBmYWlsdXJlLlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgICAvLyBJZiB0aGUgZXJyb3IgaXMgaGFuZGxlZCwgdGhlbiB3ZSBhYm9ydFxuICAgICAgICAvLyBpZiBub3QsIHdlIHRocmV3IG91dCBvZiBoZXJlXG4gICAgICAgIHRoaXMuYWJvcnQoKVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnNpbGVudClcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2xvYiBlcnJvcicsIGVyKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHJldHVybiBjYigpXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzR2xvYlN0YXIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkZGlyKGFicywgaW5HbG9iU3RhciwgZnVuY3Rpb24gKGVyLCBlbnRyaWVzKSB7XG4gICAgc2VsZi5fcHJvY2Vzc0dsb2JTdGFyMihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpXG4gIH0pXG59XG5cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhcjIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGVudHJpZXMsIGNiKSB7XG4gIC8vY29uc29sZS5lcnJvcigncGdzMicsIHByZWZpeCwgcmVtYWluWzBdLCBlbnRyaWVzKVxuXG4gIC8vIG5vIGVudHJpZXMgbWVhbnMgbm90IGEgZGlyLCBzbyBpdCBjYW4gbmV2ZXIgaGF2ZSBtYXRjaGVzXG4gIC8vIGZvby50eHQvKiogZG9lc24ndCBtYXRjaCBmb28udHh0XG4gIGlmICghZW50cmllcylcbiAgICByZXR1cm4gY2IoKVxuXG4gIC8vIHRlc3Qgd2l0aG91dCB0aGUgZ2xvYnN0YXIsIGFuZCB3aXRoIGV2ZXJ5IGNoaWxkIGJvdGggYmVsb3dcbiAgLy8gYW5kIHJlcGxhY2luZyB0aGUgZ2xvYnN0YXIuXG4gIHZhciByZW1haW5XaXRob3V0R2xvYlN0YXIgPSByZW1haW4uc2xpY2UoMSlcbiAgdmFyIGdzcHJlZiA9IHByZWZpeCA/IFsgcHJlZml4IF0gOiBbXVxuICB2YXIgbm9HbG9iU3RhciA9IGdzcHJlZi5jb25jYXQocmVtYWluV2l0aG91dEdsb2JTdGFyKVxuXG4gIC8vIHRoZSBub0dsb2JTdGFyIHBhdHRlcm4gZXhpdHMgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgdGhpcy5fcHJvY2Vzcyhub0dsb2JTdGFyLCBpbmRleCwgZmFsc2UsIGNiKVxuXG4gIHZhciBpc1N5bSA9IHRoaXMuc3ltbGlua3NbYWJzXVxuICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGhcblxuICAvLyBJZiBpdCdzIGEgc3ltbGluaywgYW5kIHdlJ3JlIGluIGEgZ2xvYnN0YXIsIHRoZW4gc3RvcFxuICBpZiAoaXNTeW0gJiYgaW5HbG9iU3RhcilcbiAgICByZXR1cm4gY2IoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcuJyAmJiAhdGhpcy5kb3QpXG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gdGhlc2UgdHdvIGNhc2VzIGVudGVyIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gICAgdmFyIGluc3RlYWQgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbldpdGhvdXRHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzKGluc3RlYWQsIGluZGV4LCB0cnVlLCBjYilcblxuICAgIHZhciBiZWxvdyA9IGdzcHJlZi5jb25jYXQoZW50cmllc1tpXSwgcmVtYWluKVxuICAgIHRoaXMuX3Byb2Nlc3MoYmVsb3csIGluZGV4LCB0cnVlLCBjYilcbiAgfVxuXG4gIGNiKClcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NTaW1wbGUgPSBmdW5jdGlvbiAocHJlZml4LCBpbmRleCwgY2IpIHtcbiAgLy8gWFhYIHJldmlldyB0aGlzLiAgU2hvdWxkbid0IGl0IGJlIGRvaW5nIHRoZSBtb3VudGluZyBldGNcbiAgLy8gYmVmb3JlIGRvaW5nIHN0YXQ/ICBraW5kYSB3ZWlyZD9cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3N0YXQocHJlZml4LCBmdW5jdGlvbiAoZXIsIGV4aXN0cykge1xuICAgIHNlbGYuX3Byb2Nlc3NTaW1wbGUyKHByZWZpeCwgaW5kZXgsIGVyLCBleGlzdHMsIGNiKVxuICB9KVxufVxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NTaW1wbGUyID0gZnVuY3Rpb24gKHByZWZpeCwgaW5kZXgsIGVyLCBleGlzdHMsIGNiKSB7XG5cbiAgLy9jb25zb2xlLmVycm9yKCdwczInLCBwcmVmaXgsIGV4aXN0cylcblxuICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAvLyBJZiBpdCBkb2Vzbid0IGV4aXN0LCB0aGVuIGp1c3QgbWFyayB0aGUgbGFjayBvZiByZXN1bHRzXG4gIGlmICghZXhpc3RzKVxuICAgIHJldHVybiBjYigpXG5cbiAgaWYgKHByZWZpeCAmJiBpc0Fic29sdXRlKHByZWZpeCkgJiYgIXRoaXMubm9tb3VudCkge1xuICAgIHZhciB0cmFpbCA9IC9bXFwvXFxcXF0kLy50ZXN0KHByZWZpeClcbiAgICBpZiAocHJlZml4LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBwcmVmaXggPSBwYXRoLmpvaW4odGhpcy5yb290LCBwcmVmaXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IHBhdGgucmVzb2x2ZSh0aGlzLnJvb3QsIHByZWZpeClcbiAgICAgIGlmICh0cmFpbClcbiAgICAgICAgcHJlZml4ICs9ICcvJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICAvLyBNYXJrIHRoaXMgYXMgYSBtYXRjaFxuICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIHByZWZpeClcbiAgY2IoKVxufVxuXG4vLyBSZXR1cm5zIGVpdGhlciAnRElSJywgJ0ZJTEUnLCBvciBmYWxzZVxuR2xvYi5wcm90b3R5cGUuX3N0YXQgPSBmdW5jdGlvbiAoZiwgY2IpIHtcbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZilcbiAgdmFyIG5lZWREaXIgPSBmLnNsaWNlKC0xKSA9PT0gJy8nXG5cbiAgaWYgKGYubGVuZ3RoID4gdGhpcy5tYXhMZW5ndGgpXG4gICAgcmV0dXJuIGNiKClcblxuICBpZiAoIXRoaXMuc3RhdCAmJiBvd25Qcm9wKHRoaXMuY2FjaGUsIGFicykpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpXG4gICAgICBjID0gJ0RJUidcblxuICAgIC8vIEl0IGV4aXN0cywgYnV0IG1heWJlIG5vdCBob3cgd2UgbmVlZCBpdFxuICAgIGlmICghbmVlZERpciB8fCBjID09PSAnRElSJylcbiAgICAgIHJldHVybiBjYihudWxsLCBjKVxuXG4gICAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgICAgcmV0dXJuIGNiKClcblxuICAgIC8vIG90aGVyd2lzZSB3ZSBoYXZlIHRvIHN0YXQsIGJlY2F1c2UgbWF5YmUgYz10cnVlXG4gICAgLy8gaWYgd2Uga25vdyBpdCBleGlzdHMsIGJ1dCBub3Qgd2hhdCBpdCBpcy5cbiAgfVxuXG4gIHZhciBleGlzdHNcbiAgdmFyIHN0YXQgPSB0aGlzLnN0YXRDYWNoZVthYnNdXG4gIGlmIChzdGF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc3RhdCA9PT0gZmFsc2UpXG4gICAgICByZXR1cm4gY2IobnVsbCwgc3RhdClcbiAgICBlbHNlIHtcbiAgICAgIHZhciB0eXBlID0gc3RhdC5pc0RpcmVjdG9yeSgpID8gJ0RJUicgOiAnRklMRSdcbiAgICAgIGlmIChuZWVkRGlyICYmIHR5cGUgPT09ICdGSUxFJylcbiAgICAgICAgcmV0dXJuIGNiKClcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHR5cGUsIHN0YXQpXG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBzdGF0Y2IgPSBpbmZsaWdodCgnc3RhdFxcMCcgKyBhYnMsIGxzdGF0Y2JfKVxuICBpZiAoc3RhdGNiKVxuICAgIGZzLmxzdGF0KGFicywgc3RhdGNiKVxuXG4gIGZ1bmN0aW9uIGxzdGF0Y2JfIChlciwgbHN0YXQpIHtcbiAgICBpZiAobHN0YXQgJiYgbHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgLy8gSWYgaXQncyBhIHN5bWxpbmssIHRoZW4gdHJlYXQgaXQgYXMgdGhlIHRhcmdldCwgdW5sZXNzXG4gICAgICAvLyB0aGUgdGFyZ2V0IGRvZXMgbm90IGV4aXN0LCB0aGVuIHRyZWF0IGl0IGFzIGEgZmlsZS5cbiAgICAgIHJldHVybiBmcy5zdGF0KGFicywgZnVuY3Rpb24gKGVyLCBzdGF0KSB7XG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICBzZWxmLl9zdGF0MihmLCBhYnMsIG51bGwsIGxzdGF0LCBjYilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNlbGYuX3N0YXQyKGYsIGFicywgZXIsIHN0YXQsIGNiKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fc3RhdDIoZiwgYWJzLCBlciwgbHN0YXQsIGNiKVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fc3RhdDIgPSBmdW5jdGlvbiAoZiwgYWJzLCBlciwgc3RhdCwgY2IpIHtcbiAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PRU5UJyB8fCBlci5jb2RlID09PSAnRU5PVERJUicpKSB7XG4gICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgcmV0dXJuIGNiKClcbiAgfVxuXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuICB0aGlzLnN0YXRDYWNoZVthYnNdID0gc3RhdFxuXG4gIGlmIChhYnMuc2xpY2UoLTEpID09PSAnLycgJiYgc3RhdCAmJiAhc3RhdC5pc0RpcmVjdG9yeSgpKVxuICAgIHJldHVybiBjYihudWxsLCBmYWxzZSwgc3RhdClcblxuICB2YXIgYyA9IHRydWVcbiAgaWYgKHN0YXQpXG4gICAgYyA9IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdESVInIDogJ0ZJTEUnXG4gIHRoaXMuY2FjaGVbYWJzXSA9IHRoaXMuY2FjaGVbYWJzXSB8fCBjXG5cbiAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgIHJldHVybiBjYigpXG5cbiAgcmV0dXJuIGNiKG51bGwsIGMsIHN0YXQpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImdsb2IiLCJmcyIsInJlcXVpcmUiLCJycCIsIm1pbmltYXRjaCIsIk1pbmltYXRjaCIsImluaGVyaXRzIiwiRUUiLCJFdmVudEVtaXR0ZXIiLCJwYXRoIiwiYXNzZXJ0IiwiaXNBYnNvbHV0ZSIsImdsb2JTeW5jIiwiY29tbW9uIiwic2V0b3B0cyIsIm93blByb3AiLCJpbmZsaWdodCIsInV0aWwiLCJjaGlsZHJlbklnbm9yZWQiLCJpc0lnbm9yZWQiLCJvbmNlIiwicGF0dGVybiIsIm9wdGlvbnMiLCJjYiIsInN5bmMiLCJUeXBlRXJyb3IiLCJHbG9iIiwiR2xvYlN5bmMiLCJleHRlbmQiLCJvcmlnaW4iLCJhZGQiLCJrZXlzIiwiT2JqZWN0IiwiaSIsImxlbmd0aCIsImhhc01hZ2ljIiwib3B0aW9uc18iLCJub3Byb2Nlc3MiLCJnIiwic2V0IiwiaiIsIl9kaWRSZWFsUGF0aCIsIm4iLCJtYXRjaGVzIiwiQXJyYXkiLCJvbiIsInNlbGYiLCJfcHJvY2Vzc2luZyIsIl9lbWl0UXVldWUiLCJfcHJvY2Vzc1F1ZXVlIiwicGF1c2VkIiwiZG9uZSIsIl9wcm9jZXNzIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiX2ZpbmlzaCIsInByb3RvdHlwZSIsImFib3J0ZWQiLCJyZWFscGF0aCIsIl9kaWRSZWFscGF0aCIsIl9yZWFscGF0aCIsImZpbmlzaCIsImVtaXQiLCJmb3VuZCIsIl9yZWFscGF0aFNldCIsIm5leHQiLCJpbmRleCIsIm1hdGNoc2V0IiwiY3JlYXRlIiwiZm9yRWFjaCIsInAiLCJfbWFrZUFicyIsInJlYWxwYXRoQ2FjaGUiLCJlciIsInJlYWwiLCJzeXNjYWxsIiwiX21hcmsiLCJtYXJrIiwiZiIsIm1ha2VBYnMiLCJhYm9ydCIsInBhdXNlIiwicmVzdW1lIiwiZXEiLCJzbGljZSIsImUiLCJfZW1pdE1hdGNoIiwicHEiLCJpbkdsb2JTdGFyIiwicHVzaCIsInByZWZpeCIsIl9wcm9jZXNzU2ltcGxlIiwiam9pbiIsInJlbWFpbiIsInJlYWQiLCJhYnMiLCJpc0dsb2JTdGFyIiwiR0xPQlNUQVIiLCJfcHJvY2Vzc0dsb2JTdGFyIiwiX3Byb2Nlc3NSZWFkZGlyIiwiX3JlYWRkaXIiLCJlbnRyaWVzIiwiX3Byb2Nlc3NSZWFkZGlyMiIsInBuIiwibmVnYXRlIiwicmF3R2xvYiIsIl9nbG9iIiwiZG90T2siLCJkb3QiLCJjaGFyQXQiLCJtYXRjaGVkRW50cmllcyIsIm0iLCJtYXRjaCIsImxlbiIsInN0YXQiLCJub21vdW50Iiwicm9vdCIsInNoaWZ0IiwibmV3UGF0dGVybiIsImNvbmNhdCIsImFic29sdXRlIiwibm9kaXIiLCJjIiwiY2FjaGUiLCJpc0FycmF5Iiwic3QiLCJzdGF0Q2FjaGUiLCJfcmVhZGRpckluR2xvYlN0YXIiLCJmb2xsb3ciLCJsc3RhdGtleSIsImxzdGF0Y2IiLCJsc3RhdGNiXyIsImxzdGF0IiwiY29kZSIsImlzU3ltIiwiaXNTeW1ib2xpY0xpbmsiLCJzeW1saW5rcyIsImlzRGlyZWN0b3J5IiwicmVhZGRpciIsInJlYWRkaXJDYiIsIl9yZWFkZGlyRXJyb3IiLCJfcmVhZGRpckVudHJpZXMiLCJjd2RBYnMiLCJlcnJvciIsIkVycm9yIiwiY3dkIiwic3RyaWN0Iiwic2lsZW50IiwiY29uc29sZSIsIl9wcm9jZXNzR2xvYlN0YXIyIiwicmVtYWluV2l0aG91dEdsb2JTdGFyIiwiZ3NwcmVmIiwibm9HbG9iU3RhciIsImluc3RlYWQiLCJiZWxvdyIsIl9zdGF0IiwiZXhpc3RzIiwiX3Byb2Nlc3NTaW1wbGUyIiwidHJhaWwiLCJ0ZXN0IiwicmVzb2x2ZSIsInBsYXRmb3JtIiwicmVwbGFjZSIsIm5lZWREaXIiLCJtYXhMZW5ndGgiLCJ1bmRlZmluZWQiLCJ0eXBlIiwic3RhdGNiIiwiX3N0YXQyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/glob/glob.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/glob/sync.js":
/*!***********************************!*\
  !*** ./node_modules/glob/sync.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = globSync;\nglobSync.GlobSync = GlobSync;\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar rp = __webpack_require__(/*! fs.realpath */ \"(ssr)/./node_modules/fs.realpath/index.js\");\nvar minimatch = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/minimatch/minimatch.js\");\nvar Minimatch = minimatch.Minimatch;\nvar Glob = (__webpack_require__(/*! ./glob.js */ \"(ssr)/./node_modules/glob/glob.js\").Glob);\nvar util = __webpack_require__(/*! util */ \"util\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"(ssr)/./node_modules/path-is-absolute/index.js\");\nvar common = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/glob/common.js\");\nvar setopts = common.setopts;\nvar ownProp = common.ownProp;\nvar childrenIgnored = common.childrenIgnored;\nvar isIgnored = common.isIgnored;\nfunction globSync(pattern, options) {\n    if (typeof options === \"function\" || arguments.length === 3) throw new TypeError(\"callback provided to sync glob\\n\" + \"See: https://github.com/isaacs/node-glob/issues/167\");\n    return new GlobSync(pattern, options).found;\n}\nfunction GlobSync(pattern, options) {\n    if (!pattern) throw new Error(\"must provide pattern\");\n    if (typeof options === \"function\" || arguments.length === 3) throw new TypeError(\"callback provided to sync glob\\n\" + \"See: https://github.com/isaacs/node-glob/issues/167\");\n    if (!(this instanceof GlobSync)) return new GlobSync(pattern, options);\n    setopts(this, pattern, options);\n    if (this.noprocess) return this;\n    var n = this.minimatch.set.length;\n    this.matches = new Array(n);\n    for(var i = 0; i < n; i++){\n        this._process(this.minimatch.set[i], i, false);\n    }\n    this._finish();\n}\nGlobSync.prototype._finish = function() {\n    assert(this instanceof GlobSync);\n    if (this.realpath) {\n        var self = this;\n        this.matches.forEach(function(matchset, index) {\n            var set = self.matches[index] = Object.create(null);\n            for(var p in matchset){\n                try {\n                    p = self._makeAbs(p);\n                    var real = rp.realpathSync(p, self.realpathCache);\n                    set[real] = true;\n                } catch (er) {\n                    if (er.syscall === \"stat\") set[self._makeAbs(p)] = true;\n                    else throw er;\n                }\n            }\n        });\n    }\n    common.finish(this);\n};\nGlobSync.prototype._process = function(pattern, index, inGlobStar) {\n    assert(this instanceof GlobSync);\n    // Get the first [n] parts of pattern that are all strings.\n    var n = 0;\n    while(typeof pattern[n] === \"string\"){\n        n++;\n    }\n    // now n is the index of the first one that is *not* a string.\n    // See if there's anything else\n    var prefix;\n    switch(n){\n        // if not, then this is rather simple\n        case pattern.length:\n            this._processSimple(pattern.join(\"/\"), index);\n            return;\n        case 0:\n            // pattern *starts* with some non-trivial item.\n            // going to readdir(cwd), but not include the prefix in matches.\n            prefix = null;\n            break;\n        default:\n            // pattern has some string bits in the front.\n            // whatever it starts with, whether that's 'absolute' like /foo/bar,\n            // or 'relative' like '../baz'\n            prefix = pattern.slice(0, n).join(\"/\");\n            break;\n    }\n    var remain = pattern.slice(n);\n    // get the list of entries.\n    var read;\n    if (prefix === null) read = \".\";\n    else if (isAbsolute(prefix) || isAbsolute(pattern.join(\"/\"))) {\n        if (!prefix || !isAbsolute(prefix)) prefix = \"/\" + prefix;\n        read = prefix;\n    } else read = prefix;\n    var abs = this._makeAbs(read);\n    //if ignored, skip processing\n    if (childrenIgnored(this, read)) return;\n    var isGlobStar = remain[0] === minimatch.GLOBSTAR;\n    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);\n    else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);\n};\nGlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {\n    var entries = this._readdir(abs, inGlobStar);\n    // if the abs isn't a dir, then nothing can match!\n    if (!entries) return;\n    // It will only match dot entries if it starts with a dot, or if\n    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n    var pn = remain[0];\n    var negate = !!this.minimatch.negate;\n    var rawGlob = pn._glob;\n    var dotOk = this.dot || rawGlob.charAt(0) === \".\";\n    var matchedEntries = [];\n    for(var i = 0; i < entries.length; i++){\n        var e = entries[i];\n        if (e.charAt(0) !== \".\" || dotOk) {\n            var m;\n            if (negate && !prefix) {\n                m = !e.match(pn);\n            } else {\n                m = e.match(pn);\n            }\n            if (m) matchedEntries.push(e);\n        }\n    }\n    var len = matchedEntries.length;\n    // If there are no matched entries, then nothing matches.\n    if (len === 0) return;\n    // if this is the last remaining pattern bit, then no need for\n    // an additional stat *unless* the user has specified mark or\n    // stat explicitly.  We know they exist, since readdir returned\n    // them.\n    if (remain.length === 1 && !this.mark && !this.stat) {\n        if (!this.matches[index]) this.matches[index] = Object.create(null);\n        for(var i = 0; i < len; i++){\n            var e = matchedEntries[i];\n            if (prefix) {\n                if (prefix.slice(-1) !== \"/\") e = prefix + \"/\" + e;\n                else e = prefix + e;\n            }\n            if (e.charAt(0) === \"/\" && !this.nomount) {\n                e = path.join(this.root, e);\n            }\n            this._emitMatch(index, e);\n        }\n        // This was the last one, and no stats were needed\n        return;\n    }\n    // now test all matched entries as stand-ins for that part\n    // of the pattern.\n    remain.shift();\n    for(var i = 0; i < len; i++){\n        var e = matchedEntries[i];\n        var newPattern;\n        if (prefix) newPattern = [\n            prefix,\n            e\n        ];\n        else newPattern = [\n            e\n        ];\n        this._process(newPattern.concat(remain), index, inGlobStar);\n    }\n};\nGlobSync.prototype._emitMatch = function(index, e) {\n    if (isIgnored(this, e)) return;\n    var abs = this._makeAbs(e);\n    if (this.mark) e = this._mark(e);\n    if (this.absolute) {\n        e = abs;\n    }\n    if (this.matches[index][e]) return;\n    if (this.nodir) {\n        var c = this.cache[abs];\n        if (c === \"DIR\" || Array.isArray(c)) return;\n    }\n    this.matches[index][e] = true;\n    if (this.stat) this._stat(e);\n};\nGlobSync.prototype._readdirInGlobStar = function(abs) {\n    // follow all symlinked directories forever\n    // just proceed as if this is a non-globstar situation\n    if (this.follow) return this._readdir(abs, false);\n    var entries;\n    var lstat;\n    var stat;\n    try {\n        lstat = fs.lstatSync(abs);\n    } catch (er) {\n        if (er.code === \"ENOENT\") {\n            // lstat failed, doesn't exist\n            return null;\n        }\n    }\n    var isSym = lstat && lstat.isSymbolicLink();\n    this.symlinks[abs] = isSym;\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = \"FILE\";\n    else entries = this._readdir(abs, false);\n    return entries;\n};\nGlobSync.prototype._readdir = function(abs, inGlobStar) {\n    var entries;\n    if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);\n    if (ownProp(this.cache, abs)) {\n        var c = this.cache[abs];\n        if (!c || c === \"FILE\") return null;\n        if (Array.isArray(c)) return c;\n    }\n    try {\n        return this._readdirEntries(abs, fs.readdirSync(abs));\n    } catch (er) {\n        this._readdirError(abs, er);\n        return null;\n    }\n};\nGlobSync.prototype._readdirEntries = function(abs, entries) {\n    // if we haven't asked to stat everything, then just\n    // assume that everything in there exists, so we can avoid\n    // having to stat it a second time.\n    if (!this.mark && !this.stat) {\n        for(var i = 0; i < entries.length; i++){\n            var e = entries[i];\n            if (abs === \"/\") e = abs + e;\n            else e = abs + \"/\" + e;\n            this.cache[e] = true;\n        }\n    }\n    this.cache[abs] = entries;\n    // mark and cache dir-ness\n    return entries;\n};\nGlobSync.prototype._readdirError = function(f, er) {\n    // handle errors, and cache the information\n    switch(er.code){\n        case \"ENOTSUP\":\n        case \"ENOTDIR\":\n            var abs = this._makeAbs(f);\n            this.cache[abs] = \"FILE\";\n            if (abs === this.cwdAbs) {\n                var error = new Error(er.code + \" invalid cwd \" + this.cwd);\n                error.path = this.cwd;\n                error.code = er.code;\n                throw error;\n            }\n            break;\n        case \"ENOENT\":\n        case \"ELOOP\":\n        case \"ENAMETOOLONG\":\n        case \"UNKNOWN\":\n            this.cache[this._makeAbs(f)] = false;\n            break;\n        default:\n            this.cache[this._makeAbs(f)] = false;\n            if (this.strict) throw er;\n            if (!this.silent) console.error(\"glob error\", er);\n            break;\n    }\n};\nGlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {\n    var entries = this._readdir(abs, inGlobStar);\n    // no entries means not a dir, so it can never have matches\n    // foo.txt/** doesn't match foo.txt\n    if (!entries) return;\n    // test without the globstar, and with every child both below\n    // and replacing the globstar.\n    var remainWithoutGlobStar = remain.slice(1);\n    var gspref = prefix ? [\n        prefix\n    ] : [];\n    var noGlobStar = gspref.concat(remainWithoutGlobStar);\n    // the noGlobStar pattern exits the inGlobStar state\n    this._process(noGlobStar, index, false);\n    var len = entries.length;\n    var isSym = this.symlinks[abs];\n    // If it's a symlink, and we're in a globstar, then stop\n    if (isSym && inGlobStar) return;\n    for(var i = 0; i < len; i++){\n        var e = entries[i];\n        if (e.charAt(0) === \".\" && !this.dot) continue;\n        // these two cases enter the inGlobStar state\n        var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n        this._process(instead, index, true);\n        var below = gspref.concat(entries[i], remain);\n        this._process(below, index, true);\n    }\n};\nGlobSync.prototype._processSimple = function(prefix, index) {\n    // XXX review this.  Shouldn't it be doing the mounting etc\n    // before doing stat?  kinda weird?\n    var exists = this._stat(prefix);\n    if (!this.matches[index]) this.matches[index] = Object.create(null);\n    // If it doesn't exist, then just mark the lack of results\n    if (!exists) return;\n    if (prefix && isAbsolute(prefix) && !this.nomount) {\n        var trail = /[\\/\\\\]$/.test(prefix);\n        if (prefix.charAt(0) === \"/\") {\n            prefix = path.join(this.root, prefix);\n        } else {\n            prefix = path.resolve(this.root, prefix);\n            if (trail) prefix += \"/\";\n        }\n    }\n    if (process.platform === \"win32\") prefix = prefix.replace(/\\\\/g, \"/\");\n    // Mark this as a match\n    this._emitMatch(index, prefix);\n};\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function(f) {\n    var abs = this._makeAbs(f);\n    var needDir = f.slice(-1) === \"/\";\n    if (f.length > this.maxLength) return false;\n    if (!this.stat && ownProp(this.cache, abs)) {\n        var c = this.cache[abs];\n        if (Array.isArray(c)) c = \"DIR\";\n        // It exists, but maybe not how we need it\n        if (!needDir || c === \"DIR\") return c;\n        if (needDir && c === \"FILE\") return false;\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n    }\n    var exists;\n    var stat = this.statCache[abs];\n    if (!stat) {\n        var lstat;\n        try {\n            lstat = fs.lstatSync(abs);\n        } catch (er) {\n            if (er && (er.code === \"ENOENT\" || er.code === \"ENOTDIR\")) {\n                this.statCache[abs] = false;\n                return false;\n            }\n        }\n        if (lstat && lstat.isSymbolicLink()) {\n            try {\n                stat = fs.statSync(abs);\n            } catch (er) {\n                stat = lstat;\n            }\n        } else {\n            stat = lstat;\n        }\n    }\n    this.statCache[abs] = stat;\n    var c = true;\n    if (stat) c = stat.isDirectory() ? \"DIR\" : \"FILE\";\n    this.cache[abs] = this.cache[abs] || c;\n    if (needDir && c === \"FILE\") return false;\n    return c;\n};\nGlobSync.prototype._mark = function(p) {\n    return common.mark(this, p);\n};\nGlobSync.prototype._makeAbs = function(f) {\n    return common.makeAbs(this, f);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEtBQUssR0FBRyxTQUFVM0MsQ0FBQztJQUNwQyxPQUFPNUIsT0FBTytELElBQUksQ0FBQyxJQUFJLEVBQUVuQztBQUMzQjtBQUVBdkMsU0FBUytCLFNBQVMsQ0FBQ1MsUUFBUSxHQUFHLFNBQVU2RCxDQUFDO0lBQ3ZDLE9BQU8xRixPQUFPaUgsT0FBTyxDQUFDLElBQUksRUFBRXZCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFidmlkaXgtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZ2xvYi9zeW5jLmpzPzhlN2QiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBnbG9iU3luY1xuZ2xvYlN5bmMuR2xvYlN5bmMgPSBHbG9iU3luY1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcnAgPSByZXF1aXJlKCdmcy5yZWFscGF0aCcpXG52YXIgbWluaW1hdGNoID0gcmVxdWlyZSgnbWluaW1hdGNoJylcbnZhciBNaW5pbWF0Y2ggPSBtaW5pbWF0Y2guTWluaW1hdGNoXG52YXIgR2xvYiA9IHJlcXVpcmUoJy4vZ2xvYi5qcycpLkdsb2JcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUoJ3BhdGgtaXMtYWJzb2x1dGUnKVxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJylcbnZhciBzZXRvcHRzID0gY29tbW9uLnNldG9wdHNcbnZhciBvd25Qcm9wID0gY29tbW9uLm93blByb3BcbnZhciBjaGlsZHJlbklnbm9yZWQgPSBjb21tb24uY2hpbGRyZW5JZ25vcmVkXG52YXIgaXNJZ25vcmVkID0gY29tbW9uLmlzSWdub3JlZFxuXG5mdW5jdGlvbiBnbG9iU3luYyAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2JcXG4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzE2NycpXG5cbiAgcmV0dXJuIG5ldyBHbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKS5mb3VuZFxufVxuXG5mdW5jdGlvbiBHbG9iU3luYyAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIXBhdHRlcm4pXG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHByb3ZpZGUgcGF0dGVybicpXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDMpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgcHJvdmlkZWQgdG8gc3luYyBnbG9iXFxuJytcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8xNjcnKVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHbG9iU3luYykpXG4gICAgcmV0dXJuIG5ldyBHbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKVxuXG4gIHNldG9wdHModGhpcywgcGF0dGVybiwgb3B0aW9ucylcblxuICBpZiAodGhpcy5ub3Byb2Nlc3MpXG4gICAgcmV0dXJuIHRoaXNcblxuICB2YXIgbiA9IHRoaXMubWluaW1hdGNoLnNldC5sZW5ndGhcbiAgdGhpcy5tYXRjaGVzID0gbmV3IEFycmF5KG4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSArKykge1xuICAgIHRoaXMuX3Byb2Nlc3ModGhpcy5taW5pbWF0Y2guc2V0W2ldLCBpLCBmYWxzZSlcbiAgfVxuICB0aGlzLl9maW5pc2goKVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iU3luYylcbiAgaWYgKHRoaXMucmVhbHBhdGgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB0aGlzLm1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2hzZXQsIGluZGV4KSB7XG4gICAgICB2YXIgc2V0ID0gc2VsZi5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIGZvciAodmFyIHAgaW4gbWF0Y2hzZXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gc2VsZi5fbWFrZUFicyhwKVxuICAgICAgICAgIHZhciByZWFsID0gcnAucmVhbHBhdGhTeW5jKHAsIHNlbGYucmVhbHBhdGhDYWNoZSlcbiAgICAgICAgICBzZXRbcmVhbF0gPSB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgaWYgKGVyLnN5c2NhbGwgPT09ICdzdGF0JylcbiAgICAgICAgICAgIHNldFtzZWxmLl9tYWtlQWJzKHApXSA9IHRydWVcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBjb21tb24uZmluaXNoKHRoaXMpXG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24gKHBhdHRlcm4sIGluZGV4LCBpbkdsb2JTdGFyKSB7XG4gIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgR2xvYlN5bmMpXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBbbl0gcGFydHMgb2YgcGF0dGVybiB0aGF0IGFyZSBhbGwgc3RyaW5ncy5cbiAgdmFyIG4gPSAwXG4gIHdoaWxlICh0eXBlb2YgcGF0dGVybltuXSA9PT0gJ3N0cmluZycpIHtcbiAgICBuICsrXG4gIH1cbiAgLy8gbm93IG4gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyAqbm90KiBhIHN0cmluZy5cblxuICAvLyBTZWUgaWYgdGhlcmUncyBhbnl0aGluZyBlbHNlXG4gIHZhciBwcmVmaXhcbiAgc3dpdGNoIChuKSB7XG4gICAgLy8gaWYgbm90LCB0aGVuIHRoaXMgaXMgcmF0aGVyIHNpbXBsZVxuICAgIGNhc2UgcGF0dGVybi5sZW5ndGg6XG4gICAgICB0aGlzLl9wcm9jZXNzU2ltcGxlKHBhdHRlcm4uam9pbignLycpLCBpbmRleClcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAwOlxuICAgICAgLy8gcGF0dGVybiAqc3RhcnRzKiB3aXRoIHNvbWUgbm9uLXRyaXZpYWwgaXRlbS5cbiAgICAgIC8vIGdvaW5nIHRvIHJlYWRkaXIoY3dkKSwgYnV0IG5vdCBpbmNsdWRlIHRoZSBwcmVmaXggaW4gbWF0Y2hlcy5cbiAgICAgIHByZWZpeCA9IG51bGxcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gcGF0dGVybiBoYXMgc29tZSBzdHJpbmcgYml0cyBpbiB0aGUgZnJvbnQuXG4gICAgICAvLyB3aGF0ZXZlciBpdCBzdGFydHMgd2l0aCwgd2hldGhlciB0aGF0J3MgJ2Fic29sdXRlJyBsaWtlIC9mb28vYmFyLFxuICAgICAgLy8gb3IgJ3JlbGF0aXZlJyBsaWtlICcuLi9iYXonXG4gICAgICBwcmVmaXggPSBwYXR0ZXJuLnNsaWNlKDAsIG4pLmpvaW4oJy8nKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHZhciByZW1haW4gPSBwYXR0ZXJuLnNsaWNlKG4pXG5cbiAgLy8gZ2V0IHRoZSBsaXN0IG9mIGVudHJpZXMuXG4gIHZhciByZWFkXG4gIGlmIChwcmVmaXggPT09IG51bGwpXG4gICAgcmVhZCA9ICcuJ1xuICBlbHNlIGlmIChpc0Fic29sdXRlKHByZWZpeCkgfHwgaXNBYnNvbHV0ZShwYXR0ZXJuLmpvaW4oJy8nKSkpIHtcbiAgICBpZiAoIXByZWZpeCB8fCAhaXNBYnNvbHV0ZShwcmVmaXgpKVxuICAgICAgcHJlZml4ID0gJy8nICsgcHJlZml4XG4gICAgcmVhZCA9IHByZWZpeFxuICB9IGVsc2VcbiAgICByZWFkID0gcHJlZml4XG5cbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMocmVhZClcblxuICAvL2lmIGlnbm9yZWQsIHNraXAgcHJvY2Vzc2luZ1xuICBpZiAoY2hpbGRyZW5JZ25vcmVkKHRoaXMsIHJlYWQpKVxuICAgIHJldHVyblxuXG4gIHZhciBpc0dsb2JTdGFyID0gcmVtYWluWzBdID09PSBtaW5pbWF0Y2guR0xPQlNUQVJcbiAgaWYgKGlzR2xvYlN0YXIpXG4gICAgdGhpcy5fcHJvY2Vzc0dsb2JTdGFyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyKVxuICBlbHNlXG4gICAgdGhpcy5fcHJvY2Vzc1JlYWRkaXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIpXG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzUmVhZGRpciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcikge1xuICB2YXIgZW50cmllcyA9IHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyKVxuXG4gIC8vIGlmIHRoZSBhYnMgaXNuJ3QgYSBkaXIsIHRoZW4gbm90aGluZyBjYW4gbWF0Y2ghXG4gIGlmICghZW50cmllcylcbiAgICByZXR1cm5cblxuICAvLyBJdCB3aWxsIG9ubHkgbWF0Y2ggZG90IGVudHJpZXMgaWYgaXQgc3RhcnRzIHdpdGggYSBkb3QsIG9yIGlmXG4gIC8vIGRvdCBpcyBzZXQuICBTdHVmZiBsaWtlIEAoLmZvb3wuYmFyKSBpc24ndCBhbGxvd2VkLlxuICB2YXIgcG4gPSByZW1haW5bMF1cbiAgdmFyIG5lZ2F0ZSA9ICEhdGhpcy5taW5pbWF0Y2gubmVnYXRlXG4gIHZhciByYXdHbG9iID0gcG4uX2dsb2JcbiAgdmFyIGRvdE9rID0gdGhpcy5kb3QgfHwgcmF3R2xvYi5jaGFyQXQoMCkgPT09ICcuJ1xuXG4gIHZhciBtYXRjaGVkRW50cmllcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSAhPT0gJy4nIHx8IGRvdE9rKSB7XG4gICAgICB2YXIgbVxuICAgICAgaWYgKG5lZ2F0ZSAmJiAhcHJlZml4KSB7XG4gICAgICAgIG0gPSAhZS5tYXRjaChwbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBlLm1hdGNoKHBuKVxuICAgICAgfVxuICAgICAgaWYgKG0pXG4gICAgICAgIG1hdGNoZWRFbnRyaWVzLnB1c2goZSlcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gbWF0Y2hlZEVudHJpZXMubGVuZ3RoXG4gIC8vIElmIHRoZXJlIGFyZSBubyBtYXRjaGVkIGVudHJpZXMsIHRoZW4gbm90aGluZyBtYXRjaGVzLlxuICBpZiAobGVuID09PSAwKVxuICAgIHJldHVyblxuXG4gIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgcmVtYWluaW5nIHBhdHRlcm4gYml0LCB0aGVuIG5vIG5lZWQgZm9yXG4gIC8vIGFuIGFkZGl0aW9uYWwgc3RhdCAqdW5sZXNzKiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIG1hcmsgb3JcbiAgLy8gc3RhdCBleHBsaWNpdGx5LiAgV2Uga25vdyB0aGV5IGV4aXN0LCBzaW5jZSByZWFkZGlyIHJldHVybmVkXG4gIC8vIHRoZW0uXG5cbiAgaWYgKHJlbWFpbi5sZW5ndGggPT09IDEgJiYgIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoZXNbaW5kZXhdKVxuICAgICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgICB2YXIgZSA9IG1hdGNoZWRFbnRyaWVzW2ldXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXguc2xpY2UoLTEpICE9PSAnLycpXG4gICAgICAgICAgZSA9IHByZWZpeCArICcvJyArIGVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUgPSBwcmVmaXggKyBlXG4gICAgICB9XG5cbiAgICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy8nICYmICF0aGlzLm5vbW91bnQpIHtcbiAgICAgICAgZSA9IHBhdGguam9pbih0aGlzLnJvb3QsIGUpXG4gICAgICB9XG4gICAgICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIGUpXG4gICAgfVxuICAgIC8vIFRoaXMgd2FzIHRoZSBsYXN0IG9uZSwgYW5kIG5vIHN0YXRzIHdlcmUgbmVlZGVkXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBub3cgdGVzdCBhbGwgbWF0Y2hlZCBlbnRyaWVzIGFzIHN0YW5kLWlucyBmb3IgdGhhdCBwYXJ0XG4gIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICByZW1haW4uc2hpZnQoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArKykge1xuICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICB2YXIgbmV3UGF0dGVyblxuICAgIGlmIChwcmVmaXgpXG4gICAgICBuZXdQYXR0ZXJuID0gW3ByZWZpeCwgZV1cbiAgICBlbHNlXG4gICAgICBuZXdQYXR0ZXJuID0gW2VdXG4gICAgdGhpcy5fcHJvY2VzcyhuZXdQYXR0ZXJuLmNvbmNhdChyZW1haW4pLCBpbmRleCwgaW5HbG9iU3RhcilcbiAgfVxufVxuXG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fZW1pdE1hdGNoID0gZnVuY3Rpb24gKGluZGV4LCBlKSB7XG4gIGlmIChpc0lnbm9yZWQodGhpcywgZSkpXG4gICAgcmV0dXJuXG5cbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZSlcblxuICBpZiAodGhpcy5tYXJrKVxuICAgIGUgPSB0aGlzLl9tYXJrKGUpXG5cbiAgaWYgKHRoaXMuYWJzb2x1dGUpIHtcbiAgICBlID0gYWJzXG4gIH1cblxuICBpZiAodGhpcy5tYXRjaGVzW2luZGV4XVtlXSlcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5ub2Rpcikge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKGMgPT09ICdESVInIHx8IEFycmF5LmlzQXJyYXkoYykpXG4gICAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMubWF0Y2hlc1tpbmRleF1bZV0gPSB0cnVlXG5cbiAgaWYgKHRoaXMuc3RhdClcbiAgICB0aGlzLl9zdGF0KGUpXG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9yZWFkZGlySW5HbG9iU3RhciA9IGZ1bmN0aW9uIChhYnMpIHtcbiAgLy8gZm9sbG93IGFsbCBzeW1saW5rZWQgZGlyZWN0b3JpZXMgZm9yZXZlclxuICAvLyBqdXN0IHByb2NlZWQgYXMgaWYgdGhpcyBpcyBhIG5vbi1nbG9ic3RhciBzaXR1YXRpb25cbiAgaWYgKHRoaXMuZm9sbG93KVxuICAgIHJldHVybiB0aGlzLl9yZWFkZGlyKGFicywgZmFsc2UpXG5cbiAgdmFyIGVudHJpZXNcbiAgdmFyIGxzdGF0XG4gIHZhciBzdGF0XG4gIHRyeSB7XG4gICAgbHN0YXQgPSBmcy5sc3RhdFN5bmMoYWJzKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgLy8gbHN0YXQgZmFpbGVkLCBkb2Vzbid0IGV4aXN0XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHZhciBpc1N5bSA9IGxzdGF0ICYmIGxzdGF0LmlzU3ltYm9saWNMaW5rKClcbiAgdGhpcy5zeW1saW5rc1thYnNdID0gaXNTeW1cblxuICAvLyBJZiBpdCdzIG5vdCBhIHN5bWxpbmsgb3IgYSBkaXIsIHRoZW4gaXQncyBkZWZpbml0ZWx5IGEgcmVndWxhciBmaWxlLlxuICAvLyBkb24ndCBib3RoZXIgZG9pbmcgYSByZWFkZGlyIGluIHRoYXQgY2FzZS5cbiAgaWYgKCFpc1N5bSAmJiBsc3RhdCAmJiAhbHN0YXQuaXNEaXJlY3RvcnkoKSlcbiAgICB0aGlzLmNhY2hlW2Fic10gPSAnRklMRSdcbiAgZWxzZVxuICAgIGVudHJpZXMgPSB0aGlzLl9yZWFkZGlyKGFicywgZmFsc2UpXG5cbiAgcmV0dXJuIGVudHJpZXNcbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9yZWFkZGlyID0gZnVuY3Rpb24gKGFicywgaW5HbG9iU3Rhcikge1xuICB2YXIgZW50cmllc1xuXG4gIGlmIChpbkdsb2JTdGFyICYmICFvd25Qcm9wKHRoaXMuc3ltbGlua3MsIGFicykpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXJJbkdsb2JTdGFyKGFicylcblxuICBpZiAob3duUHJvcCh0aGlzLmNhY2hlLCBhYnMpKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoIWMgfHwgYyA9PT0gJ0ZJTEUnKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKVxuICAgICAgcmV0dXJuIGNcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXJFbnRyaWVzKGFicywgZnMucmVhZGRpclN5bmMoYWJzKSlcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICB0aGlzLl9yZWFkZGlyRXJyb3IoYWJzLCBlcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpckVudHJpZXMgPSBmdW5jdGlvbiAoYWJzLCBlbnRyaWVzKSB7XG4gIC8vIGlmIHdlIGhhdmVuJ3QgYXNrZWQgdG8gc3RhdCBldmVyeXRoaW5nLCB0aGVuIGp1c3RcbiAgLy8gYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpbiB0aGVyZSBleGlzdHMsIHNvIHdlIGNhbiBhdm9pZFxuICAvLyBoYXZpbmcgdG8gc3RhdCBpdCBhIHNlY29uZCB0aW1lLlxuICBpZiAoIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgICBpZiAoYWJzID09PSAnLycpXG4gICAgICAgIGUgPSBhYnMgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBhYnMgKyAnLycgKyBlXG4gICAgICB0aGlzLmNhY2hlW2VdID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IGVudHJpZXNcblxuICAvLyBtYXJrIGFuZCBjYWNoZSBkaXItbmVzc1xuICByZXR1cm4gZW50cmllc1xufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXJFcnJvciA9IGZ1bmN0aW9uIChmLCBlcikge1xuICAvLyBoYW5kbGUgZXJyb3JzLCBhbmQgY2FjaGUgdGhlIGluZm9ybWF0aW9uXG4gIHN3aXRjaCAoZXIuY29kZSkge1xuICAgIGNhc2UgJ0VOT1RTVVAnOiAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvMjA1XG4gICAgY2FzZSAnRU5PVERJUic6IC8vIHRvdGFsbHkgbm9ybWFsLiBtZWFucyBpdCAqZG9lcyogZXhpc3QuXG4gICAgICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICAgICAgdGhpcy5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBpZiAoYWJzID09PSB0aGlzLmN3ZEFicykge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXIuY29kZSArICcgaW52YWxpZCBjd2QgJyArIHRoaXMuY3dkKVxuICAgICAgICBlcnJvci5wYXRoID0gdGhpcy5jd2RcbiAgICAgICAgZXJyb3IuY29kZSA9IGVyLmNvZGVcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdFTk9FTlQnOiAvLyBub3QgdGVycmlibHkgdW51c3VhbFxuICAgIGNhc2UgJ0VMT09QJzpcbiAgICBjYXNlICdFTkFNRVRPT0xPTkcnOlxuICAgIGNhc2UgJ1VOS05PV04nOlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDogLy8gc29tZSB1bnVzdWFsIGVycm9yLiAgVHJlYXQgYXMgZmFpbHVyZS5cbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgaWYgKHRoaXMuc3RyaWN0KVxuICAgICAgICB0aHJvdyBlclxuICAgICAgaWYgKCF0aGlzLnNpbGVudClcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2xvYiBlcnJvcicsIGVyKVxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcikge1xuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIpXG5cbiAgLy8gbm8gZW50cmllcyBtZWFucyBub3QgYSBkaXIsIHNvIGl0IGNhbiBuZXZlciBoYXZlIG1hdGNoZXNcbiAgLy8gZm9vLnR4dC8qKiBkb2Vzbid0IG1hdGNoIGZvby50eHRcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVyblxuXG4gIC8vIHRlc3Qgd2l0aG91dCB0aGUgZ2xvYnN0YXIsIGFuZCB3aXRoIGV2ZXJ5IGNoaWxkIGJvdGggYmVsb3dcbiAgLy8gYW5kIHJlcGxhY2luZyB0aGUgZ2xvYnN0YXIuXG4gIHZhciByZW1haW5XaXRob3V0R2xvYlN0YXIgPSByZW1haW4uc2xpY2UoMSlcbiAgdmFyIGdzcHJlZiA9IHByZWZpeCA/IFsgcHJlZml4IF0gOiBbXVxuICB2YXIgbm9HbG9iU3RhciA9IGdzcHJlZi5jb25jYXQocmVtYWluV2l0aG91dEdsb2JTdGFyKVxuXG4gIC8vIHRoZSBub0dsb2JTdGFyIHBhdHRlcm4gZXhpdHMgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgdGhpcy5fcHJvY2Vzcyhub0dsb2JTdGFyLCBpbmRleCwgZmFsc2UpXG5cbiAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoXG4gIHZhciBpc1N5bSA9IHRoaXMuc3ltbGlua3NbYWJzXVxuXG4gIC8vIElmIGl0J3MgYSBzeW1saW5rLCBhbmQgd2UncmUgaW4gYSBnbG9ic3RhciwgdGhlbiBzdG9wXG4gIGlmIChpc1N5bSAmJiBpbkdsb2JTdGFyKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcuJyAmJiAhdGhpcy5kb3QpXG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gdGhlc2UgdHdvIGNhc2VzIGVudGVyIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gICAgdmFyIGluc3RlYWQgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbldpdGhvdXRHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzKGluc3RlYWQsIGluZGV4LCB0cnVlKVxuXG4gICAgdmFyIGJlbG93ID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW4pXG4gICAgdGhpcy5fcHJvY2VzcyhiZWxvdywgaW5kZXgsIHRydWUpXG4gIH1cbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzU2ltcGxlID0gZnVuY3Rpb24gKHByZWZpeCwgaW5kZXgpIHtcbiAgLy8gWFhYIHJldmlldyB0aGlzLiAgU2hvdWxkbid0IGl0IGJlIGRvaW5nIHRoZSBtb3VudGluZyBldGNcbiAgLy8gYmVmb3JlIGRvaW5nIHN0YXQ/ICBraW5kYSB3ZWlyZD9cbiAgdmFyIGV4aXN0cyA9IHRoaXMuX3N0YXQocHJlZml4KVxuXG4gIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4ganVzdCBtYXJrIHRoZSBsYWNrIG9mIHJlc3VsdHNcbiAgaWYgKCFleGlzdHMpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHByZWZpeCAmJiBpc0Fic29sdXRlKHByZWZpeCkgJiYgIXRoaXMubm9tb3VudCkge1xuICAgIHZhciB0cmFpbCA9IC9bXFwvXFxcXF0kLy50ZXN0KHByZWZpeClcbiAgICBpZiAocHJlZml4LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBwcmVmaXggPSBwYXRoLmpvaW4odGhpcy5yb290LCBwcmVmaXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IHBhdGgucmVzb2x2ZSh0aGlzLnJvb3QsIHByZWZpeClcbiAgICAgIGlmICh0cmFpbClcbiAgICAgICAgcHJlZml4ICs9ICcvJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICAvLyBNYXJrIHRoaXMgYXMgYSBtYXRjaFxuICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIHByZWZpeClcbn1cblxuLy8gUmV0dXJucyBlaXRoZXIgJ0RJUicsICdGSUxFJywgb3IgZmFsc2Vcbkdsb2JTeW5jLnByb3RvdHlwZS5fc3RhdCA9IGZ1bmN0aW9uIChmKSB7XG4gIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKGYpXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuXG4gIGlmIChmLmxlbmd0aCA+IHRoaXMubWF4TGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGlmICghdGhpcy5zdGF0ICYmIG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIGMgPSAnRElSJ1xuXG4gICAgLy8gSXQgZXhpc3RzLCBidXQgbWF5YmUgbm90IGhvdyB3ZSBuZWVkIGl0XG4gICAgaWYgKCFuZWVkRGlyIHx8IGMgPT09ICdESVInKVxuICAgICAgcmV0dXJuIGNcblxuICAgIGlmIChuZWVkRGlyICYmIGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGhhdmUgdG8gc3RhdCwgYmVjYXVzZSBtYXliZSBjPXRydWVcbiAgICAvLyBpZiB3ZSBrbm93IGl0IGV4aXN0cywgYnV0IG5vdCB3aGF0IGl0IGlzLlxuICB9XG5cbiAgdmFyIGV4aXN0c1xuICB2YXIgc3RhdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKCFzdGF0KSB7XG4gICAgdmFyIGxzdGF0XG4gICAgdHJ5IHtcbiAgICAgIGxzdGF0ID0gZnMubHN0YXRTeW5jKGFicylcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PRU5UJyB8fCBlci5jb2RlID09PSAnRU5PVERJUicpKSB7XG4gICAgICAgIHRoaXMuc3RhdENhY2hlW2Fic10gPSBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobHN0YXQgJiYgbHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhdCA9IGZzLnN0YXRTeW5jKGFicylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHN0YXQgPSBsc3RhdFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ID0gbHN0YXRcbiAgICB9XG4gIH1cblxuICB0aGlzLnN0YXRDYWNoZVthYnNdID0gc3RhdFxuXG4gIHZhciBjID0gdHJ1ZVxuICBpZiAoc3RhdClcbiAgICBjID0gc3RhdC5pc0RpcmVjdG9yeSgpID8gJ0RJUicgOiAnRklMRSdcblxuICB0aGlzLmNhY2hlW2Fic10gPSB0aGlzLmNhY2hlW2Fic10gfHwgY1xuXG4gIGlmIChuZWVkRGlyICYmIGMgPT09ICdGSUxFJylcbiAgICByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gY1xufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX21hcmsgPSBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gY29tbW9uLm1hcmsodGhpcywgcClcbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9tYWtlQWJzID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIGNvbW1vbi5tYWtlQWJzKHRoaXMsIGYpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImdsb2JTeW5jIiwiR2xvYlN5bmMiLCJmcyIsInJlcXVpcmUiLCJycCIsIm1pbmltYXRjaCIsIk1pbmltYXRjaCIsIkdsb2IiLCJ1dGlsIiwicGF0aCIsImFzc2VydCIsImlzQWJzb2x1dGUiLCJjb21tb24iLCJzZXRvcHRzIiwib3duUHJvcCIsImNoaWxkcmVuSWdub3JlZCIsImlzSWdub3JlZCIsInBhdHRlcm4iLCJvcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiZm91bmQiLCJFcnJvciIsIm5vcHJvY2VzcyIsIm4iLCJzZXQiLCJtYXRjaGVzIiwiQXJyYXkiLCJpIiwiX3Byb2Nlc3MiLCJfZmluaXNoIiwicHJvdG90eXBlIiwicmVhbHBhdGgiLCJzZWxmIiwiZm9yRWFjaCIsIm1hdGNoc2V0IiwiaW5kZXgiLCJPYmplY3QiLCJjcmVhdGUiLCJwIiwiX21ha2VBYnMiLCJyZWFsIiwicmVhbHBhdGhTeW5jIiwicmVhbHBhdGhDYWNoZSIsImVyIiwic3lzY2FsbCIsImZpbmlzaCIsImluR2xvYlN0YXIiLCJwcmVmaXgiLCJfcHJvY2Vzc1NpbXBsZSIsImpvaW4iLCJzbGljZSIsInJlbWFpbiIsInJlYWQiLCJhYnMiLCJpc0dsb2JTdGFyIiwiR0xPQlNUQVIiLCJfcHJvY2Vzc0dsb2JTdGFyIiwiX3Byb2Nlc3NSZWFkZGlyIiwiZW50cmllcyIsIl9yZWFkZGlyIiwicG4iLCJuZWdhdGUiLCJyYXdHbG9iIiwiX2dsb2IiLCJkb3RPayIsImRvdCIsImNoYXJBdCIsIm1hdGNoZWRFbnRyaWVzIiwiZSIsIm0iLCJtYXRjaCIsInB1c2giLCJsZW4iLCJtYXJrIiwic3RhdCIsIm5vbW91bnQiLCJyb290IiwiX2VtaXRNYXRjaCIsInNoaWZ0IiwibmV3UGF0dGVybiIsImNvbmNhdCIsIl9tYXJrIiwiYWJzb2x1dGUiLCJub2RpciIsImMiLCJjYWNoZSIsImlzQXJyYXkiLCJfc3RhdCIsIl9yZWFkZGlySW5HbG9iU3RhciIsImZvbGxvdyIsImxzdGF0IiwibHN0YXRTeW5jIiwiY29kZSIsImlzU3ltIiwiaXNTeW1ib2xpY0xpbmsiLCJzeW1saW5rcyIsImlzRGlyZWN0b3J5IiwiX3JlYWRkaXJFbnRyaWVzIiwicmVhZGRpclN5bmMiLCJfcmVhZGRpckVycm9yIiwiZiIsImN3ZEFicyIsImVycm9yIiwiY3dkIiwic3RyaWN0Iiwic2lsZW50IiwiY29uc29sZSIsInJlbWFpbldpdGhvdXRHbG9iU3RhciIsImdzcHJlZiIsIm5vR2xvYlN0YXIiLCJpbnN0ZWFkIiwiYmVsb3ciLCJleGlzdHMiLCJ0cmFpbCIsInRlc3QiLCJyZXNvbHZlIiwicHJvY2VzcyIsInBsYXRmb3JtIiwicmVwbGFjZSIsIm5lZWREaXIiLCJtYXhMZW5ndGgiLCJzdGF0Q2FjaGUiLCJzdGF0U3luYyIsIm1ha2VBYnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/glob/sync.js\n");

/***/ })

};
;