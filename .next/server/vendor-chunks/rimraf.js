/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rimraf";
exports.ids = ["vendor-chunks/rimraf"];
exports.modules = {

/***/ "(ssr)/./node_modules/rimraf/rimraf.js":
/*!***************************************!*\
  !*** ./node_modules/rimraf/rimraf.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! assert */ \"assert\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nlet glob = undefined;\ntry {\n    glob = __webpack_require__(/*! glob */ \"(ssr)/./node_modules/glob/glob.js\");\n} catch (_err) {\n// treat glob as optional.\n}\nconst defaultGlobOpts = {\n    nosort: true,\n    silent: true\n};\n// for EMFILE handling\nlet timeout = 0;\nconst isWindows = process.platform === \"win32\";\nconst defaults = (options)=>{\n    const methods = [\n        \"unlink\",\n        \"chmod\",\n        \"stat\",\n        \"lstat\",\n        \"rmdir\",\n        \"readdir\"\n    ];\n    methods.forEach((m)=>{\n        options[m] = options[m] || fs[m];\n        m = m + \"Sync\";\n        options[m] = options[m] || fs[m];\n    });\n    options.maxBusyTries = options.maxBusyTries || 3;\n    options.emfileWait = options.emfileWait || 1000;\n    if (options.glob === false) {\n        options.disableGlob = true;\n    }\n    if (options.disableGlob !== true && glob === undefined) {\n        throw Error(\"glob dependency not found, set `options.disableGlob = true` if intentional\");\n    }\n    options.disableGlob = options.disableGlob || false;\n    options.glob = options.glob || defaultGlobOpts;\n};\nconst rimraf = (p, options, cb)=>{\n    if (typeof options === \"function\") {\n        cb = options;\n        options = {};\n    }\n    assert(p, \"rimraf: missing path\");\n    assert.equal(typeof p, \"string\", \"rimraf: path should be a string\");\n    assert.equal(typeof cb, \"function\", \"rimraf: callback function required\");\n    assert(options, \"rimraf: invalid options argument provided\");\n    assert.equal(typeof options, \"object\", \"rimraf: options should be object\");\n    defaults(options);\n    let busyTries = 0;\n    let errState = null;\n    let n = 0;\n    const next = (er)=>{\n        errState = errState || er;\n        if (--n === 0) cb(errState);\n    };\n    const afterGlob = (er, results)=>{\n        if (er) return cb(er);\n        n = results.length;\n        if (n === 0) return cb();\n        results.forEach((p)=>{\n            const CB = (er)=>{\n                if (er) {\n                    if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") && busyTries < options.maxBusyTries) {\n                        busyTries++;\n                        // try again, with the same exact callback as this one.\n                        return setTimeout(()=>rimraf_(p, options, CB), busyTries * 100);\n                    }\n                    // this one won't happen if graceful-fs is used.\n                    if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n                        return setTimeout(()=>rimraf_(p, options, CB), timeout++);\n                    }\n                    // already gone\n                    if (er.code === \"ENOENT\") er = null;\n                }\n                timeout = 0;\n                next(er);\n            };\n            rimraf_(p, options, CB);\n        });\n    };\n    if (options.disableGlob || !glob.hasMagic(p)) return afterGlob(null, [\n        p\n    ]);\n    options.lstat(p, (er, stat)=>{\n        if (!er) return afterGlob(null, [\n            p\n        ]);\n        glob(p, options.glob, afterGlob);\n    });\n};\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nconst rimraf_ = (p, options, cb)=>{\n    assert(p);\n    assert(options);\n    assert(typeof cb === \"function\");\n    // sunos lets the root user unlink directories, which is... weird.\n    // so we have to lstat here and make sure it's not a dir.\n    options.lstat(p, (er, st)=>{\n        if (er && er.code === \"ENOENT\") return cb(null);\n        // Windows can EPERM on stat.  Life is suffering.\n        if (er && er.code === \"EPERM\" && isWindows) fixWinEPERM(p, options, er, cb);\n        if (st && st.isDirectory()) return rmdir(p, options, er, cb);\n        options.unlink(p, (er)=>{\n            if (er) {\n                if (er.code === \"ENOENT\") return cb(null);\n                if (er.code === \"EPERM\") return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb);\n                if (er.code === \"EISDIR\") return rmdir(p, options, er, cb);\n            }\n            return cb(er);\n        });\n    });\n};\nconst fixWinEPERM = (p, options, er, cb)=>{\n    assert(p);\n    assert(options);\n    assert(typeof cb === \"function\");\n    options.chmod(p, 438, (er2)=>{\n        if (er2) cb(er2.code === \"ENOENT\" ? null : er);\n        else options.stat(p, (er3, stats)=>{\n            if (er3) cb(er3.code === \"ENOENT\" ? null : er);\n            else if (stats.isDirectory()) rmdir(p, options, er, cb);\n            else options.unlink(p, cb);\n        });\n    });\n};\nconst fixWinEPERMSync = (p, options, er)=>{\n    assert(p);\n    assert(options);\n    try {\n        options.chmodSync(p, 438);\n    } catch (er2) {\n        if (er2.code === \"ENOENT\") return;\n        else throw er;\n    }\n    let stats;\n    try {\n        stats = options.statSync(p);\n    } catch (er3) {\n        if (er3.code === \"ENOENT\") return;\n        else throw er;\n    }\n    if (stats.isDirectory()) rmdirSync(p, options, er);\n    else options.unlinkSync(p);\n};\nconst rmdir = (p, options, originalEr, cb)=>{\n    assert(p);\n    assert(options);\n    assert(typeof cb === \"function\");\n    // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n    // if we guessed wrong, and it's not a directory, then\n    // raise the original error.\n    options.rmdir(p, (er)=>{\n        if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")) rmkids(p, options, cb);\n        else if (er && er.code === \"ENOTDIR\") cb(originalEr);\n        else cb(er);\n    });\n};\nconst rmkids = (p, options, cb)=>{\n    assert(p);\n    assert(options);\n    assert(typeof cb === \"function\");\n    options.readdir(p, (er, files)=>{\n        if (er) return cb(er);\n        let n = files.length;\n        if (n === 0) return options.rmdir(p, cb);\n        let errState;\n        files.forEach((f)=>{\n            rimraf(path.join(p, f), options, (er)=>{\n                if (errState) return;\n                if (er) return cb(errState = er);\n                if (--n === 0) options.rmdir(p, cb);\n            });\n        });\n    });\n};\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nconst rimrafSync = (p, options)=>{\n    options = options || {};\n    defaults(options);\n    assert(p, \"rimraf: missing path\");\n    assert.equal(typeof p, \"string\", \"rimraf: path should be a string\");\n    assert(options, \"rimraf: missing options\");\n    assert.equal(typeof options, \"object\", \"rimraf: options should be object\");\n    let results;\n    if (options.disableGlob || !glob.hasMagic(p)) {\n        results = [\n            p\n        ];\n    } else {\n        try {\n            options.lstatSync(p);\n            results = [\n                p\n            ];\n        } catch (er) {\n            results = glob.sync(p, options.glob);\n        }\n    }\n    if (!results.length) return;\n    for(let i = 0; i < results.length; i++){\n        const p = results[i];\n        let st;\n        try {\n            st = options.lstatSync(p);\n        } catch (er) {\n            if (er.code === \"ENOENT\") return;\n            // Windows can EPERM on stat.  Life is suffering.\n            if (er.code === \"EPERM\" && isWindows) fixWinEPERMSync(p, options, er);\n        }\n        try {\n            // sunos lets the root user unlink directories, which is... weird.\n            if (st && st.isDirectory()) rmdirSync(p, options, null);\n            else options.unlinkSync(p);\n        } catch (er) {\n            if (er.code === \"ENOENT\") return;\n            if (er.code === \"EPERM\") return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);\n            if (er.code !== \"EISDIR\") throw er;\n            rmdirSync(p, options, er);\n        }\n    }\n};\nconst rmdirSync = (p, options, originalEr)=>{\n    assert(p);\n    assert(options);\n    try {\n        options.rmdirSync(p);\n    } catch (er) {\n        if (er.code === \"ENOENT\") return;\n        if (er.code === \"ENOTDIR\") throw originalEr;\n        if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\") rmkidsSync(p, options);\n    }\n};\nconst rmkidsSync = (p, options)=>{\n    assert(p);\n    assert(options);\n    options.readdirSync(p).forEach((f)=>rimrafSync(path.join(p, f), options));\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const retries = isWindows ? 100 : 1;\n    let i = 0;\n    do {\n        let threw = true;\n        try {\n            const ret = options.rmdirSync(p, options);\n            threw = false;\n            return ret;\n        } finally{\n            if (++i < retries && threw) continue;\n        }\n    }while (true);\n};\nmodule.exports = rimraf;\nrimraf.sync = rimrafSync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQ1IsR0FBRztRQUNELElBQUlJLFFBQVE7UUFDWixJQUFJO1lBQ0YsTUFBTUMsTUFBTXZELFFBQVF1QyxTQUFTLENBQUM5QixHQUFHVDtZQUNqQ3NELFFBQVE7WUFDUixPQUFPQztRQUNULFNBQVU7WUFDUixJQUFJLEVBQUVMLElBQUlHLFdBQVdDLE9BQ25CO1FBQ0o7SUFDRixRQUFTLE1BQUs7QUFDaEI7QUFFQUUsT0FBT0MsT0FBTyxHQUFHakQ7QUFDakJBLE9BQU95QyxJQUFJLEdBQUdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFidmlkaXgtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcmltcmFmL3JpbXJhZi5qcz8yYTRmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIilcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKVxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIilcbmxldCBnbG9iID0gdW5kZWZpbmVkXG50cnkge1xuICBnbG9iID0gcmVxdWlyZShcImdsb2JcIilcbn0gY2F0Y2ggKF9lcnIpIHtcbiAgLy8gdHJlYXQgZ2xvYiBhcyBvcHRpb25hbC5cbn1cblxuY29uc3QgZGVmYXVsdEdsb2JPcHRzID0ge1xuICBub3NvcnQ6IHRydWUsXG4gIHNpbGVudDogdHJ1ZVxufVxuXG4vLyBmb3IgRU1GSUxFIGhhbmRsaW5nXG5sZXQgdGltZW91dCA9IDBcblxuY29uc3QgaXNXaW5kb3dzID0gKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIilcblxuY29uc3QgZGVmYXVsdHMgPSBvcHRpb25zID0+IHtcbiAgY29uc3QgbWV0aG9kcyA9IFtcbiAgICAndW5saW5rJyxcbiAgICAnY2htb2QnLFxuICAgICdzdGF0JyxcbiAgICAnbHN0YXQnLFxuICAgICdybWRpcicsXG4gICAgJ3JlYWRkaXInXG4gIF1cbiAgbWV0aG9kcy5mb3JFYWNoKG0gPT4ge1xuICAgIG9wdGlvbnNbbV0gPSBvcHRpb25zW21dIHx8IGZzW21dXG4gICAgbSA9IG0gKyAnU3luYydcbiAgICBvcHRpb25zW21dID0gb3B0aW9uc1ttXSB8fCBmc1ttXVxuICB9KVxuXG4gIG9wdGlvbnMubWF4QnVzeVRyaWVzID0gb3B0aW9ucy5tYXhCdXN5VHJpZXMgfHwgM1xuICBvcHRpb25zLmVtZmlsZVdhaXQgPSBvcHRpb25zLmVtZmlsZVdhaXQgfHwgMTAwMFxuICBpZiAob3B0aW9ucy5nbG9iID09PSBmYWxzZSkge1xuICAgIG9wdGlvbnMuZGlzYWJsZUdsb2IgPSB0cnVlXG4gIH1cbiAgaWYgKG9wdGlvbnMuZGlzYWJsZUdsb2IgIT09IHRydWUgJiYgZ2xvYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2dsb2IgZGVwZW5kZW5jeSBub3QgZm91bmQsIHNldCBgb3B0aW9ucy5kaXNhYmxlR2xvYiA9IHRydWVgIGlmIGludGVudGlvbmFsJylcbiAgfVxuICBvcHRpb25zLmRpc2FibGVHbG9iID0gb3B0aW9ucy5kaXNhYmxlR2xvYiB8fCBmYWxzZVxuICBvcHRpb25zLmdsb2IgPSBvcHRpb25zLmdsb2IgfHwgZGVmYXVsdEdsb2JPcHRzXG59XG5cbmNvbnN0IHJpbXJhZiA9IChwLCBvcHRpb25zLCBjYikgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGFzc2VydChwLCAncmltcmFmOiBtaXNzaW5nIHBhdGgnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIHAsICdzdHJpbmcnLCAncmltcmFmOiBwYXRoIHNob3VsZCBiZSBhIHN0cmluZycpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgY2IsICdmdW5jdGlvbicsICdyaW1yYWY6IGNhbGxiYWNrIGZ1bmN0aW9uIHJlcXVpcmVkJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IGludmFsaWQgb3B0aW9ucyBhcmd1bWVudCBwcm92aWRlZCcpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgZGVmYXVsdHMob3B0aW9ucylcblxuICBsZXQgYnVzeVRyaWVzID0gMFxuICBsZXQgZXJyU3RhdGUgPSBudWxsXG4gIGxldCBuID0gMFxuXG4gIGNvbnN0IG5leHQgPSAoZXIpID0+IHtcbiAgICBlcnJTdGF0ZSA9IGVyclN0YXRlIHx8IGVyXG4gICAgaWYgKC0tbiA9PT0gMClcbiAgICAgIGNiKGVyclN0YXRlKVxuICB9XG5cbiAgY29uc3QgYWZ0ZXJHbG9iID0gKGVyLCByZXN1bHRzKSA9PiB7XG4gICAgaWYgKGVyKVxuICAgICAgcmV0dXJuIGNiKGVyKVxuXG4gICAgbiA9IHJlc3VsdHMubGVuZ3RoXG4gICAgaWYgKG4gPT09IDApXG4gICAgICByZXR1cm4gY2IoKVxuXG4gICAgcmVzdWx0cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgY29uc3QgQ0IgPSAoZXIpID0+IHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgaWYgKChlci5jb2RlID09PSBcIkVCVVNZXCIgfHwgZXIuY29kZSA9PT0gXCJFTk9URU1QVFlcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpICYmXG4gICAgICAgICAgICAgIGJ1c3lUcmllcyA8IG9wdGlvbnMubWF4QnVzeVRyaWVzKSB7XG4gICAgICAgICAgICBidXN5VHJpZXMgKytcbiAgICAgICAgICAgIC8vIHRyeSBhZ2Fpbiwgd2l0aCB0aGUgc2FtZSBleGFjdCBjYWxsYmFjayBhcyB0aGlzIG9uZS5cbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHJpbXJhZl8ocCwgb3B0aW9ucywgQ0IpLCBidXN5VHJpZXMgKiAxMDApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdGhpcyBvbmUgd29uJ3QgaGFwcGVuIGlmIGdyYWNlZnVsLWZzIGlzIHVzZWQuXG4gICAgICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRU1GSUxFXCIgJiYgdGltZW91dCA8IG9wdGlvbnMuZW1maWxlV2FpdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gcmltcmFmXyhwLCBvcHRpb25zLCBDQiksIHRpbWVvdXQgKyspXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWxyZWFkeSBnb25lXG4gICAgICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpIGVyID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgdGltZW91dCA9IDBcbiAgICAgICAgbmV4dChlcilcbiAgICAgIH1cbiAgICAgIHJpbXJhZl8ocCwgb3B0aW9ucywgQ0IpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChvcHRpb25zLmRpc2FibGVHbG9iIHx8ICFnbG9iLmhhc01hZ2ljKHApKVxuICAgIHJldHVybiBhZnRlckdsb2IobnVsbCwgW3BdKVxuXG4gIG9wdGlvbnMubHN0YXQocCwgKGVyLCBzdGF0KSA9PiB7XG4gICAgaWYgKCFlcilcbiAgICAgIHJldHVybiBhZnRlckdsb2IobnVsbCwgW3BdKVxuXG4gICAgZ2xvYihwLCBvcHRpb25zLmdsb2IsIGFmdGVyR2xvYilcbiAgfSlcblxufVxuXG4vLyBUd28gcG9zc2libGUgc3RyYXRlZ2llcy5cbi8vIDEuIEFzc3VtZSBpdCdzIGEgZmlsZS4gIHVubGluayBpdCwgdGhlbiBkbyB0aGUgZGlyIHN0dWZmIG9uIEVQRVJNIG9yIEVJU0RJUlxuLy8gMi4gQXNzdW1lIGl0J3MgYSBkaXJlY3RvcnkuICByZWFkZGlyLCB0aGVuIGRvIHRoZSBmaWxlIHN0dWZmIG9uIEVOT1RESVJcbi8vXG4vLyBCb3RoIHJlc3VsdCBpbiBhbiBleHRyYSBzeXNjYWxsIHdoZW4geW91IGd1ZXNzIHdyb25nLiAgSG93ZXZlciwgdGhlcmVcbi8vIGFyZSBsaWtlbHkgZmFyIG1vcmUgbm9ybWFsIGZpbGVzIGluIHRoZSB3b3JsZCB0aGFuIGRpcmVjdG9yaWVzLiAgVGhpc1xuLy8gaXMgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBhIHRoZSBhdmVyYWdlIG51bWJlciBvZiBmaWxlcyBwZXJcbi8vIGRpcmVjdG9yeSBpcyA+PSAxLlxuLy9cbi8vIElmIGFueW9uZSBldmVyIGNvbXBsYWlucyBhYm91dCB0aGlzLCB0aGVuIEkgZ3Vlc3MgdGhlIHN0cmF0ZWd5IGNvdWxkXG4vLyBiZSBtYWRlIGNvbmZpZ3VyYWJsZSBzb21laG93LiAgQnV0IHVudGlsIHRoZW4sIFlBR05JLlxuY29uc3QgcmltcmFmXyA9IChwLCBvcHRpb25zLCBjYikgPT4ge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgLy8gc3Vub3MgbGV0cyB0aGUgcm9vdCB1c2VyIHVubGluayBkaXJlY3Rvcmllcywgd2hpY2ggaXMuLi4gd2VpcmQuXG4gIC8vIHNvIHdlIGhhdmUgdG8gbHN0YXQgaGVyZSBhbmQgbWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlyLlxuICBvcHRpb25zLmxzdGF0KHAsIChlciwgc3QpID0+IHtcbiAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgIHJldHVybiBjYihudWxsKVxuXG4gICAgLy8gV2luZG93cyBjYW4gRVBFUk0gb24gc3RhdC4gIExpZmUgaXMgc3VmZmVyaW5nLlxuICAgIGlmIChlciAmJiBlci5jb2RlID09PSBcIkVQRVJNXCIgJiYgaXNXaW5kb3dzKVxuICAgICAgZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuXG4gICAgaWYgKHN0ICYmIHN0LmlzRGlyZWN0b3J5KCkpXG4gICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuXG4gICAgb3B0aW9ucy51bmxpbmsocCwgZXIgPT4ge1xuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIGlmIChlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgICAgIHJldHVybiBjYihudWxsKVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gXCJFUEVSTVwiKVxuICAgICAgICAgIHJldHVybiAoaXNXaW5kb3dzKVxuICAgICAgICAgICAgPyBmaXhXaW5FUEVSTShwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgICAgICA6IHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRUlTRElSXCIpXG4gICAgICAgICAgcmV0dXJuIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYihlcilcbiAgICB9KVxuICB9KVxufVxuXG5jb25zdCBmaXhXaW5FUEVSTSA9IChwLCBvcHRpb25zLCBlciwgY2IpID0+IHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIG9wdGlvbnMuY2htb2QocCwgMG82NjYsIGVyMiA9PiB7XG4gICAgaWYgKGVyMilcbiAgICAgIGNiKGVyMi5jb2RlID09PSBcIkVOT0VOVFwiID8gbnVsbCA6IGVyKVxuICAgIGVsc2VcbiAgICAgIG9wdGlvbnMuc3RhdChwLCAoZXIzLCBzdGF0cykgPT4ge1xuICAgICAgICBpZiAoZXIzKVxuICAgICAgICAgIGNiKGVyMy5jb2RlID09PSBcIkVOT0VOVFwiID8gbnVsbCA6IGVyKVxuICAgICAgICBlbHNlIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAgIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9wdGlvbnMudW5saW5rKHAsIGNiKVxuICAgICAgfSlcbiAgfSlcbn1cblxuY29uc3QgZml4V2luRVBFUk1TeW5jID0gKHAsIG9wdGlvbnMsIGVyKSA9PiB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcblxuICB0cnkge1xuICAgIG9wdGlvbnMuY2htb2RTeW5jKHAsIDBvNjY2KVxuICB9IGNhdGNoIChlcjIpIHtcbiAgICBpZiAoZXIyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICByZXR1cm5cbiAgICBlbHNlXG4gICAgICB0aHJvdyBlclxuICB9XG5cbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBvcHRpb25zLnN0YXRTeW5jKHApXG4gIH0gY2F0Y2ggKGVyMykge1xuICAgIGlmIChlcjMuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgIHJldHVyblxuICAgIGVsc2VcbiAgICAgIHRocm93IGVyXG4gIH1cblxuICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSlcbiAgICBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gIGVsc2VcbiAgICBvcHRpb25zLnVubGlua1N5bmMocClcbn1cblxuY29uc3Qgcm1kaXIgPSAocCwgb3B0aW9ucywgb3JpZ2luYWxFciwgY2IpID0+IHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIC8vIHRyeSB0byBybWRpciBmaXJzdCwgYW5kIG9ubHkgcmVhZGRpciBvbiBFTk9URU1QVFkgb3IgRUVYSVNUIChTdW5PUylcbiAgLy8gaWYgd2UgZ3Vlc3NlZCB3cm9uZywgYW5kIGl0J3Mgbm90IGEgZGlyZWN0b3J5LCB0aGVuXG4gIC8vIHJhaXNlIHRoZSBvcmlnaW5hbCBlcnJvci5cbiAgb3B0aW9ucy5ybWRpcihwLCBlciA9PiB7XG4gICAgaWYgKGVyICYmIChlci5jb2RlID09PSBcIkVOT1RFTVBUWVwiIHx8IGVyLmNvZGUgPT09IFwiRUVYSVNUXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKSlcbiAgICAgIHJta2lkcyhwLCBvcHRpb25zLCBjYilcbiAgICBlbHNlIGlmIChlciAmJiBlci5jb2RlID09PSBcIkVOT1RESVJcIilcbiAgICAgIGNiKG9yaWdpbmFsRXIpXG4gICAgZWxzZVxuICAgICAgY2IoZXIpXG4gIH0pXG59XG5cbmNvbnN0IHJta2lkcyA9IChwLCBvcHRpb25zLCBjYikgPT4ge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgb3B0aW9ucy5yZWFkZGlyKHAsIChlciwgZmlsZXMpID0+IHtcbiAgICBpZiAoZXIpXG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgbGV0IG4gPSBmaWxlcy5sZW5ndGhcbiAgICBpZiAobiA9PT0gMClcbiAgICAgIHJldHVybiBvcHRpb25zLnJtZGlyKHAsIGNiKVxuICAgIGxldCBlcnJTdGF0ZVxuICAgIGZpbGVzLmZvckVhY2goZiA9PiB7XG4gICAgICByaW1yYWYocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zLCBlciA9PiB7XG4gICAgICAgIGlmIChlcnJTdGF0ZSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgaWYgKGVyKVxuICAgICAgICAgIHJldHVybiBjYihlcnJTdGF0ZSA9IGVyKVxuICAgICAgICBpZiAoLS1uID09PSAwKVxuICAgICAgICAgIG9wdGlvbnMucm1kaXIocCwgY2IpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIHRoaXMgbG9va3Mgc2ltcGxlciwgYW5kIGlzIHN0cmljdGx5ICpmYXN0ZXIqLCBidXQgd2lsbFxuLy8gdGllIHVwIHRoZSBKYXZhU2NyaXB0IHRocmVhZCBhbmQgZmFpbCBvbiBleGNlc3NpdmVseVxuLy8gZGVlcCBkaXJlY3RvcnkgdHJlZXMuXG5jb25zdCByaW1yYWZTeW5jID0gKHAsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgZGVmYXVsdHMob3B0aW9ucylcblxuICBhc3NlcnQocCwgJ3JpbXJhZjogbWlzc2luZyBwYXRoJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBwLCAnc3RyaW5nJywgJ3JpbXJhZjogcGF0aCBzaG91bGQgYmUgYSBzdHJpbmcnKVxuICBhc3NlcnQob3B0aW9ucywgJ3JpbXJhZjogbWlzc2luZyBvcHRpb25zJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBvcHRpb25zLCAnb2JqZWN0JywgJ3JpbXJhZjogb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0JylcblxuICBsZXQgcmVzdWx0c1xuXG4gIGlmIChvcHRpb25zLmRpc2FibGVHbG9iIHx8ICFnbG9iLmhhc01hZ2ljKHApKSB7XG4gICAgcmVzdWx0cyA9IFtwXVxuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zLmxzdGF0U3luYyhwKVxuICAgICAgcmVzdWx0cyA9IFtwXVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXN1bHRzID0gZ2xvYi5zeW5jKHAsIG9wdGlvbnMuZ2xvYilcbiAgICB9XG4gIH1cblxuICBpZiAoIXJlc3VsdHMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHAgPSByZXN1bHRzW2ldXG5cbiAgICBsZXQgc3RcbiAgICB0cnkge1xuICAgICAgc3QgPSBvcHRpb25zLmxzdGF0U3luYyhwKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIC8vIFdpbmRvd3MgY2FuIEVQRVJNIG9uIHN0YXQuICBMaWZlIGlzIHN1ZmZlcmluZy5cbiAgICAgIGlmIChlci5jb2RlID09PSBcIkVQRVJNXCIgJiYgaXNXaW5kb3dzKVxuICAgICAgICBmaXhXaW5FUEVSTVN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHN1bm9zIGxldHMgdGhlIHJvb3QgdXNlciB1bmxpbmsgZGlyZWN0b3JpZXMsIHdoaWNoIGlzLi4uIHdlaXJkLlxuICAgICAgaWYgKHN0ICYmIHN0LmlzRGlyZWN0b3J5KCkpXG4gICAgICAgIHJtZGlyU3luYyhwLCBvcHRpb25zLCBudWxsKVxuICAgICAgZWxzZVxuICAgICAgICBvcHRpb25zLnVubGlua1N5bmMocClcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICAgIHJldHVyblxuICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgICAgcmV0dXJuIGlzV2luZG93cyA/IGZpeFdpbkVQRVJNU3luYyhwLCBvcHRpb25zLCBlcikgOiBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgICBpZiAoZXIuY29kZSAhPT0gXCJFSVNESVJcIilcbiAgICAgICAgdGhyb3cgZXJcblxuICAgICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBybWRpclN5bmMgPSAocCwgb3B0aW9ucywgb3JpZ2luYWxFcikgPT4ge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG5cbiAgdHJ5IHtcbiAgICBvcHRpb25zLnJtZGlyU3luYyhwKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgcmV0dXJuXG4gICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PVERJUlwiKVxuICAgICAgdGhyb3cgb3JpZ2luYWxFclxuICAgIGlmIChlci5jb2RlID09PSBcIkVOT1RFTVBUWVwiIHx8IGVyLmNvZGUgPT09IFwiRUVYSVNUXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKVxuICAgICAgcm1raWRzU3luYyhwLCBvcHRpb25zKVxuICB9XG59XG5cbmNvbnN0IHJta2lkc1N5bmMgPSAocCwgb3B0aW9ucykgPT4ge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIG9wdGlvbnMucmVhZGRpclN5bmMocCkuZm9yRWFjaChmID0+IHJpbXJhZlN5bmMocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zKSlcblxuICAvLyBXZSBvbmx5IGVuZCB1cCBoZXJlIG9uY2Ugd2UgZ290IEVOT1RFTVBUWSBhdCBsZWFzdCBvbmNlLCBhbmRcbiAgLy8gYXQgdGhpcyBwb2ludCwgd2UgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSByZW1vdmVkIGFsbCB0aGUga2lkcy5cbiAgLy8gU28sIHdlIGtub3cgdGhhdCBpdCB3b24ndCBiZSBFTk9FTlQgb3IgRU5PVERJUiBvciBhbnl0aGluZyBlbHNlLlxuICAvLyB0cnkgcmVhbGx5IGhhcmQgdG8gZGVsZXRlIHN0dWZmIG9uIHdpbmRvd3MsIGJlY2F1c2UgaXQgaGFzIGFcbiAgLy8gUFJPRk9VTkRMWSBhbm5veWluZyBoYWJpdCBvZiBub3QgY2xvc2luZyBoYW5kbGVzIHByb21wdGx5IHdoZW5cbiAgLy8gZmlsZXMgYXJlIGRlbGV0ZWQsIHJlc3VsdGluZyBpbiBzcHVyaW91cyBFTk9URU1QVFkgZXJyb3JzLlxuICBjb25zdCByZXRyaWVzID0gaXNXaW5kb3dzID8gMTAwIDogMVxuICBsZXQgaSA9IDBcbiAgZG8ge1xuICAgIGxldCB0aHJldyA9IHRydWVcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmV0ID0gb3B0aW9ucy5ybWRpclN5bmMocCwgb3B0aW9ucylcbiAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgIHJldHVybiByZXRcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCsraSA8IHJldHJpZXMgJiYgdGhyZXcpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgfVxuICB9IHdoaWxlICh0cnVlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJpbXJhZlxucmltcmFmLnN5bmMgPSByaW1yYWZTeW5jXG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsInBhdGgiLCJmcyIsImdsb2IiLCJ1bmRlZmluZWQiLCJfZXJyIiwiZGVmYXVsdEdsb2JPcHRzIiwibm9zb3J0Iiwic2lsZW50IiwidGltZW91dCIsImlzV2luZG93cyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsImRlZmF1bHRzIiwib3B0aW9ucyIsIm1ldGhvZHMiLCJmb3JFYWNoIiwibSIsIm1heEJ1c3lUcmllcyIsImVtZmlsZVdhaXQiLCJkaXNhYmxlR2xvYiIsIkVycm9yIiwicmltcmFmIiwicCIsImNiIiwiZXF1YWwiLCJidXN5VHJpZXMiLCJlcnJTdGF0ZSIsIm4iLCJuZXh0IiwiZXIiLCJhZnRlckdsb2IiLCJyZXN1bHRzIiwibGVuZ3RoIiwiQ0IiLCJjb2RlIiwic2V0VGltZW91dCIsInJpbXJhZl8iLCJoYXNNYWdpYyIsImxzdGF0Iiwic3RhdCIsInN0IiwiZml4V2luRVBFUk0iLCJpc0RpcmVjdG9yeSIsInJtZGlyIiwidW5saW5rIiwiY2htb2QiLCJlcjIiLCJlcjMiLCJzdGF0cyIsImZpeFdpbkVQRVJNU3luYyIsImNobW9kU3luYyIsInN0YXRTeW5jIiwicm1kaXJTeW5jIiwidW5saW5rU3luYyIsIm9yaWdpbmFsRXIiLCJybWtpZHMiLCJyZWFkZGlyIiwiZmlsZXMiLCJmIiwiam9pbiIsInJpbXJhZlN5bmMiLCJsc3RhdFN5bmMiLCJzeW5jIiwiaSIsInJta2lkc1N5bmMiLCJyZWFkZGlyU3luYyIsInJldHJpZXMiLCJ0aHJldyIsInJldCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rimraf/rimraf.js\n");

/***/ })

};
;