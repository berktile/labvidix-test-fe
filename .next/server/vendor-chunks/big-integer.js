/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/big-integer";
exports.ids = ["vendor-chunks/big-integer"];
exports.modules = {

/***/ "(ssr)/./node_modules/big-integer/BigInteger.js":
/*!************************************************!*\
  !*** ./node_modules/big-integer/BigInteger.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;var bigInt = function(undefined) {\n    \"use strict\";\n    var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    var supportsNativeBigInt = typeof BigInt === \"function\";\n    function Integer(v, radix, alphabet, caseSensitive) {\n        if (typeof v === \"undefined\") return Integer[0];\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\n        return parseValue(v);\n    }\n    function BigInteger(value, sign) {\n        this.value = value;\n        this.sign = sign;\n        this.isSmall = false;\n    }\n    BigInteger.prototype = Object.create(Integer.prototype);\n    function SmallInteger(value) {\n        this.value = value;\n        this.sign = value < 0;\n        this.isSmall = true;\n    }\n    SmallInteger.prototype = Object.create(Integer.prototype);\n    function NativeBigInt(value) {\n        this.value = value;\n    }\n    NativeBigInt.prototype = Object.create(Integer.prototype);\n    function isPrecise(n) {\n        return -MAX_INT < n && n < MAX_INT;\n    }\n    function smallToArray(n) {\n        if (n < 1e7) return [\n            n\n        ];\n        if (n < 1e14) return [\n            n % 1e7,\n            Math.floor(n / 1e7)\n        ];\n        return [\n            n % 1e7,\n            Math.floor(n / 1e7) % 1e7,\n            Math.floor(n / 1e14)\n        ];\n    }\n    function arrayToSmall(arr) {\n        trim(arr);\n        var length = arr.length;\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\n            switch(length){\n                case 0:\n                    return 0;\n                case 1:\n                    return arr[0];\n                case 2:\n                    return arr[0] + arr[1] * BASE;\n                default:\n                    return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\n            }\n        }\n        return arr;\n    }\n    function trim(v) {\n        var i = v.length;\n        while(v[--i] === 0);\n        v.length = i + 1;\n    }\n    function createArray(length) {\n        var x = new Array(length);\n        var i = -1;\n        while(++i < length){\n            x[i] = 0;\n        }\n        return x;\n    }\n    function truncate(n) {\n        if (n > 0) return Math.floor(n);\n        return Math.ceil(n);\n    }\n    function add(a, b) {\n        var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum, i;\n        for(i = 0; i < l_b; i++){\n            sum = a[i] + b[i] + carry;\n            carry = sum >= base ? 1 : 0;\n            r[i] = sum - carry * base;\n        }\n        while(i < l_a){\n            sum = a[i] + carry;\n            carry = sum === base ? 1 : 0;\n            r[i++] = sum - carry * base;\n        }\n        if (carry > 0) r.push(carry);\n        return r;\n    }\n    function addAny(a, b) {\n        if (a.length >= b.length) return add(a, b);\n        return add(b, a);\n    }\n    function addSmall(a, carry) {\n        var l = a.length, r = new Array(l), base = BASE, sum, i;\n        for(i = 0; i < l; i++){\n            sum = a[i] - base + carry;\n            carry = Math.floor(sum / base);\n            r[i] = sum - carry * base;\n            carry += 1;\n        }\n        while(carry > 0){\n            r[i++] = carry % base;\n            carry = Math.floor(carry / base);\n        }\n        return r;\n    }\n    BigInteger.prototype.add = function(v) {\n        var n = parseValue(v);\n        if (this.sign !== n.sign) {\n            return this.subtract(n.negate());\n        }\n        var a = this.value, b = n.value;\n        if (n.isSmall) {\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\n        }\n        return new BigInteger(addAny(a, b), this.sign);\n    };\n    BigInteger.prototype.plus = BigInteger.prototype.add;\n    SmallInteger.prototype.add = function(v) {\n        var n = parseValue(v);\n        var a = this.value;\n        if (a < 0 !== n.sign) {\n            return this.subtract(n.negate());\n        }\n        var b = n.value;\n        if (n.isSmall) {\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\n            b = smallToArray(Math.abs(b));\n        }\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\n    };\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\n    NativeBigInt.prototype.add = function(v) {\n        return new NativeBigInt(this.value + parseValue(v).value);\n    };\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\n    function subtract(a, b) {\n        var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i, difference;\n        for(i = 0; i < b_l; i++){\n            difference = a[i] - borrow - b[i];\n            if (difference < 0) {\n                difference += base;\n                borrow = 1;\n            } else borrow = 0;\n            r[i] = difference;\n        }\n        for(i = b_l; i < a_l; i++){\n            difference = a[i] - borrow;\n            if (difference < 0) difference += base;\n            else {\n                r[i++] = difference;\n                break;\n            }\n            r[i] = difference;\n        }\n        for(; i < a_l; i++){\n            r[i] = a[i];\n        }\n        trim(r);\n        return r;\n    }\n    function subtractAny(a, b, sign) {\n        var value;\n        if (compareAbs(a, b) >= 0) {\n            value = subtract(a, b);\n        } else {\n            value = subtract(b, a);\n            sign = !sign;\n        }\n        value = arrayToSmall(value);\n        if (typeof value === \"number\") {\n            if (sign) value = -value;\n            return new SmallInteger(value);\n        }\n        return new BigInteger(value, sign);\n    }\n    function subtractSmall(a, b, sign) {\n        var l = a.length, r = new Array(l), carry = -b, base = BASE, i, difference;\n        for(i = 0; i < l; i++){\n            difference = a[i] + carry;\n            carry = Math.floor(difference / base);\n            difference %= base;\n            r[i] = difference < 0 ? difference + base : difference;\n        }\n        r = arrayToSmall(r);\n        if (typeof r === \"number\") {\n            if (sign) r = -r;\n            return new SmallInteger(r);\n        }\n        return new BigInteger(r, sign);\n    }\n    BigInteger.prototype.subtract = function(v) {\n        var n = parseValue(v);\n        if (this.sign !== n.sign) {\n            return this.add(n.negate());\n        }\n        var a = this.value, b = n.value;\n        if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);\n        return subtractAny(a, b, this.sign);\n    };\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\n    SmallInteger.prototype.subtract = function(v) {\n        var n = parseValue(v);\n        var a = this.value;\n        if (a < 0 !== n.sign) {\n            return this.add(n.negate());\n        }\n        var b = n.value;\n        if (n.isSmall) {\n            return new SmallInteger(a - b);\n        }\n        return subtractSmall(b, Math.abs(a), a >= 0);\n    };\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\n    NativeBigInt.prototype.subtract = function(v) {\n        return new NativeBigInt(this.value - parseValue(v).value);\n    };\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\n    BigInteger.prototype.negate = function() {\n        return new BigInteger(this.value, !this.sign);\n    };\n    SmallInteger.prototype.negate = function() {\n        var sign = this.sign;\n        var small = new SmallInteger(-this.value);\n        small.sign = !sign;\n        return small;\n    };\n    NativeBigInt.prototype.negate = function() {\n        return new NativeBigInt(-this.value);\n    };\n    BigInteger.prototype.abs = function() {\n        return new BigInteger(this.value, false);\n    };\n    SmallInteger.prototype.abs = function() {\n        return new SmallInteger(Math.abs(this.value));\n    };\n    NativeBigInt.prototype.abs = function() {\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\n    };\n    function multiplyLong(a, b) {\n        var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE, product, carry, i, a_i, b_j;\n        for(i = 0; i < a_l; ++i){\n            a_i = a[i];\n            for(var j = 0; j < b_l; ++j){\n                b_j = b[j];\n                product = a_i * b_j + r[i + j];\n                carry = Math.floor(product / base);\n                r[i + j] = product - carry * base;\n                r[i + j + 1] += carry;\n            }\n        }\n        trim(r);\n        return r;\n    }\n    function multiplySmall(a, b) {\n        var l = a.length, r = new Array(l), base = BASE, carry = 0, product, i;\n        for(i = 0; i < l; i++){\n            product = a[i] * b + carry;\n            carry = Math.floor(product / base);\n            r[i] = product - carry * base;\n        }\n        while(carry > 0){\n            r[i++] = carry % base;\n            carry = Math.floor(carry / base);\n        }\n        return r;\n    }\n    function shiftLeft(x, n) {\n        var r = [];\n        while(n-- > 0)r.push(0);\n        return r.concat(x);\n    }\n    function multiplyKaratsuba(x, y) {\n        var n = Math.max(x.length, y.length);\n        if (n <= 30) return multiplyLong(x, y);\n        n = Math.ceil(n / 2);\n        var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);\n        var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\n        trim(product);\n        return product;\n    }\n    // The following function is derived from a surface fit of a graph plotting the performance difference\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\n    function useKaratsuba(l1, l2) {\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\n    }\n    BigInteger.prototype.multiply = function(v) {\n        var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;\n        if (n.isSmall) {\n            if (b === 0) return Integer[0];\n            if (b === 1) return this;\n            if (b === -1) return this.negate();\n            abs = Math.abs(b);\n            if (abs < BASE) {\n                return new BigInteger(multiplySmall(a, abs), sign);\n            }\n            b = smallToArray(abs);\n        }\n        if (useKaratsuba(a.length, b.length)) return new BigInteger(multiplyKaratsuba(a, b), sign);\n        return new BigInteger(multiplyLong(a, b), sign);\n    };\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\n    function multiplySmallAndArray(a, b, sign) {\n        if (a < BASE) {\n            return new BigInteger(multiplySmall(b, a), sign);\n        }\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\n    }\n    SmallInteger.prototype._multiplyBySmall = function(a) {\n        if (isPrecise(a.value * this.value)) {\n            return new SmallInteger(a.value * this.value);\n        }\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\n    };\n    BigInteger.prototype._multiplyBySmall = function(a) {\n        if (a.value === 0) return Integer[0];\n        if (a.value === 1) return this;\n        if (a.value === -1) return this.negate();\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\n    };\n    SmallInteger.prototype.multiply = function(v) {\n        return parseValue(v)._multiplyBySmall(this);\n    };\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\n    NativeBigInt.prototype.multiply = function(v) {\n        return new NativeBigInt(this.value * parseValue(v).value);\n    };\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\n    function square(a) {\n        //console.assert(2 * BASE * BASE < MAX_INT);\n        var l = a.length, r = createArray(l + l), base = BASE, product, carry, i, a_i, a_j;\n        for(i = 0; i < l; i++){\n            a_i = a[i];\n            carry = 0 - a_i * a_i;\n            for(var j = i; j < l; j++){\n                a_j = a[j];\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\n                carry = Math.floor(product / base);\n                r[i + j] = product - carry * base;\n            }\n            r[i + l] = carry;\n        }\n        trim(r);\n        return r;\n    }\n    BigInteger.prototype.square = function() {\n        return new BigInteger(square(this.value), false);\n    };\n    SmallInteger.prototype.square = function() {\n        var value = this.value * this.value;\n        if (isPrecise(value)) return new SmallInteger(value);\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\n    };\n    NativeBigInt.prototype.square = function(v) {\n        return new NativeBigInt(this.value * this.value);\n    };\n    function divMod1(a, b) {\n        var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], // normalization\n        lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i, l, q;\n        if (remainder.length <= a_l) remainder.push(0);\n        divisor.push(0);\n        divisorMostSignificantDigit = divisor[b_l - 1];\n        for(shift = a_l - b_l; shift >= 0; shift--){\n            quotientDigit = base - 1;\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\n            }\n            // quotientDigit <= base - 1\n            carry = 0;\n            borrow = 0;\n            l = divisor.length;\n            for(i = 0; i < l; i++){\n                carry += quotientDigit * divisor[i];\n                q = Math.floor(carry / base);\n                borrow += remainder[shift + i] - (carry - q * base);\n                carry = q;\n                if (borrow < 0) {\n                    remainder[shift + i] = borrow + base;\n                    borrow = -1;\n                } else {\n                    remainder[shift + i] = borrow;\n                    borrow = 0;\n                }\n            }\n            while(borrow !== 0){\n                quotientDigit -= 1;\n                carry = 0;\n                for(i = 0; i < l; i++){\n                    carry += remainder[shift + i] - base + divisor[i];\n                    if (carry < 0) {\n                        remainder[shift + i] = carry + base;\n                        carry = 0;\n                    } else {\n                        remainder[shift + i] = carry;\n                        carry = 1;\n                    }\n                }\n                borrow += carry;\n            }\n            result[shift] = quotientDigit;\n        }\n        // denormalization\n        remainder = divModSmall(remainder, lambda)[0];\n        return [\n            arrayToSmall(result),\n            arrayToSmall(remainder)\n        ];\n    }\n    function divMod2(a, b) {\n        // Performs faster than divMod1 on larger input sizes.\n        var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;\n        while(a_l){\n            part.unshift(a[--a_l]);\n            trim(part);\n            if (compareAbs(part, b) < 0) {\n                result.push(0);\n                continue;\n            }\n            xlen = part.length;\n            highx = part[xlen - 1] * base + part[xlen - 2];\n            highy = b[b_l - 1] * base + b[b_l - 2];\n            if (xlen > b_l) {\n                highx = (highx + 1) * base;\n            }\n            guess = Math.ceil(highx / highy);\n            do {\n                check = multiplySmall(b, guess);\n                if (compareAbs(check, part) <= 0) break;\n                guess--;\n            }while (guess);\n            result.push(guess);\n            part = subtract(part, check);\n        }\n        result.reverse();\n        return [\n            arrayToSmall(result),\n            arrayToSmall(part)\n        ];\n    }\n    function divModSmall(value, lambda) {\n        var length = value.length, quotient = createArray(length), base = BASE, i, q, remainder, divisor;\n        remainder = 0;\n        for(i = length - 1; i >= 0; --i){\n            divisor = remainder * base + value[i];\n            q = truncate(divisor / lambda);\n            remainder = divisor - q * lambda;\n            quotient[i] = q | 0;\n        }\n        return [\n            quotient,\n            remainder | 0\n        ];\n    }\n    function divModAny(self, v) {\n        var value, n = parseValue(v);\n        if (supportsNativeBigInt) {\n            return [\n                new NativeBigInt(self.value / n.value),\n                new NativeBigInt(self.value % n.value)\n            ];\n        }\n        var a = self.value, b = n.value;\n        var quotient;\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\n        if (self.isSmall) {\n            if (n.isSmall) {\n                return [\n                    new SmallInteger(truncate(a / b)),\n                    new SmallInteger(a % b)\n                ];\n            }\n            return [\n                Integer[0],\n                self\n            ];\n        }\n        if (n.isSmall) {\n            if (b === 1) return [\n                self,\n                Integer[0]\n            ];\n            if (b == -1) return [\n                self.negate(),\n                Integer[0]\n            ];\n            var abs = Math.abs(b);\n            if (abs < BASE) {\n                value = divModSmall(a, abs);\n                quotient = arrayToSmall(value[0]);\n                var remainder = value[1];\n                if (self.sign) remainder = -remainder;\n                if (typeof quotient === \"number\") {\n                    if (self.sign !== n.sign) quotient = -quotient;\n                    return [\n                        new SmallInteger(quotient),\n                        new SmallInteger(remainder)\n                    ];\n                }\n                return [\n                    new BigInteger(quotient, self.sign !== n.sign),\n                    new SmallInteger(remainder)\n                ];\n            }\n            b = smallToArray(abs);\n        }\n        var comparison = compareAbs(a, b);\n        if (comparison === -1) return [\n            Integer[0],\n            self\n        ];\n        if (comparison === 0) return [\n            Integer[self.sign === n.sign ? 1 : -1],\n            Integer[0]\n        ];\n        // divMod1 is faster on smaller input sizes\n        if (a.length + b.length <= 200) value = divMod1(a, b);\n        else value = divMod2(a, b);\n        quotient = value[0];\n        var qSign = self.sign !== n.sign, mod = value[1], mSign = self.sign;\n        if (typeof quotient === \"number\") {\n            if (qSign) quotient = -quotient;\n            quotient = new SmallInteger(quotient);\n        } else quotient = new BigInteger(quotient, qSign);\n        if (typeof mod === \"number\") {\n            if (mSign) mod = -mod;\n            mod = new SmallInteger(mod);\n        } else mod = new BigInteger(mod, mSign);\n        return [\n            quotient,\n            mod\n        ];\n    }\n    BigInteger.prototype.divmod = function(v) {\n        var result = divModAny(this, v);\n        return {\n            quotient: result[0],\n            remainder: result[1]\n        };\n    };\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\n    BigInteger.prototype.divide = function(v) {\n        return divModAny(this, v)[0];\n    };\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {\n        return new NativeBigInt(this.value / parseValue(v).value);\n    };\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\n    BigInteger.prototype.mod = function(v) {\n        return divModAny(this, v)[1];\n    };\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {\n        return new NativeBigInt(this.value % parseValue(v).value);\n    };\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\n    BigInteger.prototype.pow = function(v) {\n        var n = parseValue(v), a = this.value, b = n.value, value, x, y;\n        if (b === 0) return Integer[1];\n        if (a === 0) return Integer[0];\n        if (a === 1) return Integer[1];\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\n        if (n.sign) {\n            return Integer[0];\n        }\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\n        if (this.isSmall) {\n            if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));\n        }\n        x = this;\n        y = Integer[1];\n        while(true){\n            if (b & 1 === 1) {\n                y = y.times(x);\n                --b;\n            }\n            if (b === 0) break;\n            b /= 2;\n            x = x.square();\n        }\n        return y;\n    };\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\n    NativeBigInt.prototype.pow = function(v) {\n        var n = parseValue(v);\n        var a = this.value, b = n.value;\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\n        if (b === _0) return Integer[1];\n        if (a === _0) return Integer[0];\n        if (a === _1) return Integer[1];\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\n        if (n.isNegative()) return new NativeBigInt(_0);\n        var x = this;\n        var y = Integer[1];\n        while(true){\n            if ((b & _1) === _1) {\n                y = y.times(x);\n                --b;\n            }\n            if (b === _0) break;\n            b /= _2;\n            x = x.square();\n        }\n        return y;\n    };\n    BigInteger.prototype.modPow = function(exp, mod) {\n        exp = parseValue(exp);\n        mod = parseValue(mod);\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\n        var r = Integer[1], base = this.mod(mod);\n        if (exp.isNegative()) {\n            exp = exp.multiply(Integer[-1]);\n            base = base.modInv(mod);\n        }\n        while(exp.isPositive()){\n            if (base.isZero()) return Integer[0];\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\n            exp = exp.divide(2);\n            base = base.square().mod(mod);\n        }\n        return r;\n    };\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\n    function compareAbs(a, b) {\n        if (a.length !== b.length) {\n            return a.length > b.length ? 1 : -1;\n        }\n        for(var i = a.length - 1; i >= 0; i--){\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\n        }\n        return 0;\n    }\n    BigInteger.prototype.compareAbs = function(v) {\n        var n = parseValue(v), a = this.value, b = n.value;\n        if (n.isSmall) return 1;\n        return compareAbs(a, b);\n    };\n    SmallInteger.prototype.compareAbs = function(v) {\n        var n = parseValue(v), a = Math.abs(this.value), b = n.value;\n        if (n.isSmall) {\n            b = Math.abs(b);\n            return a === b ? 0 : a > b ? 1 : -1;\n        }\n        return -1;\n    };\n    NativeBigInt.prototype.compareAbs = function(v) {\n        var a = this.value;\n        var b = parseValue(v).value;\n        a = a >= 0 ? a : -a;\n        b = b >= 0 ? b : -b;\n        return a === b ? 0 : a > b ? 1 : -1;\n    };\n    BigInteger.prototype.compare = function(v) {\n        // See discussion about comparison with Infinity:\n        // https://github.com/peterolson/BigInteger.js/issues/61\n        if (v === Infinity) {\n            return -1;\n        }\n        if (v === -Infinity) {\n            return 1;\n        }\n        var n = parseValue(v), a = this.value, b = n.value;\n        if (this.sign !== n.sign) {\n            return n.sign ? 1 : -1;\n        }\n        if (n.isSmall) {\n            return this.sign ? -1 : 1;\n        }\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\n    };\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\n    SmallInteger.prototype.compare = function(v) {\n        if (v === Infinity) {\n            return -1;\n        }\n        if (v === -Infinity) {\n            return 1;\n        }\n        var n = parseValue(v), a = this.value, b = n.value;\n        if (n.isSmall) {\n            return a == b ? 0 : a > b ? 1 : -1;\n        }\n        if (a < 0 !== n.sign) {\n            return a < 0 ? -1 : 1;\n        }\n        return a < 0 ? 1 : -1;\n    };\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\n    NativeBigInt.prototype.compare = function(v) {\n        if (v === Infinity) {\n            return -1;\n        }\n        if (v === -Infinity) {\n            return 1;\n        }\n        var a = this.value;\n        var b = parseValue(v).value;\n        return a === b ? 0 : a > b ? 1 : -1;\n    };\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\n    BigInteger.prototype.equals = function(v) {\n        return this.compare(v) === 0;\n    };\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\n    BigInteger.prototype.notEquals = function(v) {\n        return this.compare(v) !== 0;\n    };\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\n    BigInteger.prototype.greater = function(v) {\n        return this.compare(v) > 0;\n    };\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\n    BigInteger.prototype.lesser = function(v) {\n        return this.compare(v) < 0;\n    };\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\n    BigInteger.prototype.greaterOrEquals = function(v) {\n        return this.compare(v) >= 0;\n    };\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\n    BigInteger.prototype.lesserOrEquals = function(v) {\n        return this.compare(v) <= 0;\n    };\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\n    BigInteger.prototype.isEven = function() {\n        return (this.value[0] & 1) === 0;\n    };\n    SmallInteger.prototype.isEven = function() {\n        return (this.value & 1) === 0;\n    };\n    NativeBigInt.prototype.isEven = function() {\n        return (this.value & BigInt(1)) === BigInt(0);\n    };\n    BigInteger.prototype.isOdd = function() {\n        return (this.value[0] & 1) === 1;\n    };\n    SmallInteger.prototype.isOdd = function() {\n        return (this.value & 1) === 1;\n    };\n    NativeBigInt.prototype.isOdd = function() {\n        return (this.value & BigInt(1)) === BigInt(1);\n    };\n    BigInteger.prototype.isPositive = function() {\n        return !this.sign;\n    };\n    SmallInteger.prototype.isPositive = function() {\n        return this.value > 0;\n    };\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\n    BigInteger.prototype.isNegative = function() {\n        return this.sign;\n    };\n    SmallInteger.prototype.isNegative = function() {\n        return this.value < 0;\n    };\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\n    BigInteger.prototype.isUnit = function() {\n        return false;\n    };\n    SmallInteger.prototype.isUnit = function() {\n        return Math.abs(this.value) === 1;\n    };\n    NativeBigInt.prototype.isUnit = function() {\n        return this.abs().value === BigInt(1);\n    };\n    BigInteger.prototype.isZero = function() {\n        return false;\n    };\n    SmallInteger.prototype.isZero = function() {\n        return this.value === 0;\n    };\n    NativeBigInt.prototype.isZero = function() {\n        return this.value === BigInt(0);\n    };\n    BigInteger.prototype.isDivisibleBy = function(v) {\n        var n = parseValue(v);\n        if (n.isZero()) return false;\n        if (n.isUnit()) return true;\n        if (n.compareAbs(2) === 0) return this.isEven();\n        return this.mod(n).isZero();\n    };\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\n    function isBasicPrime(v) {\n        var n = v.abs();\n        if (n.isUnit()) return false;\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\n        if (n.lesser(49)) return true;\n    // we don't know if it's prime: let the other functions figure it out\n    }\n    function millerRabinTest(n, a) {\n        var nPrev = n.prev(), b = nPrev, r = 0, d, t, i, x;\n        while(b.isEven())b = b.divide(2), r++;\n        next: for(i = 0; i < a.length; i++){\n            if (n.lesser(a[i])) continue;\n            x = bigInt(a[i]).modPow(b, n);\n            if (x.isUnit() || x.equals(nPrev)) continue;\n            for(d = r - 1; d != 0; d--){\n                x = x.square().mod(n);\n                if (x.isUnit()) return false;\n                if (x.equals(nPrev)) continue next;\n            }\n            return false;\n        }\n        return true;\n    }\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\n    BigInteger.prototype.isPrime = function(strict) {\n        var isPrime = isBasicPrime(this);\n        if (isPrime !== undefined) return isPrime;\n        var n = this.abs();\n        var bits = n.bitLength();\n        if (bits <= 64) return millerRabinTest(n, [\n            2,\n            3,\n            5,\n            7,\n            11,\n            13,\n            17,\n            19,\n            23,\n            29,\n            31,\n            37\n        ]);\n        var logN = Math.log(2) * bits.toJSNumber();\n        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);\n        for(var a = [], i = 0; i < t; i++){\n            a.push(bigInt(i + 2));\n        }\n        return millerRabinTest(n, a);\n    };\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\n    BigInteger.prototype.isProbablePrime = function(iterations, rng) {\n        var isPrime = isBasicPrime(this);\n        if (isPrime !== undefined) return isPrime;\n        var n = this.abs();\n        var t = iterations === undefined ? 5 : iterations;\n        for(var a = [], i = 0; i < t; i++){\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\n        }\n        return millerRabinTest(n, a);\n    };\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\n    BigInteger.prototype.modInv = function(n) {\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\n        while(!newR.isZero()){\n            q = r.divide(newR);\n            lastT = t;\n            lastR = r;\n            t = newT;\n            r = newR;\n            newT = lastT.subtract(q.multiply(newT));\n            newR = lastR.subtract(q.multiply(newR));\n        }\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\n        if (t.compare(0) === -1) {\n            t = t.add(n);\n        }\n        if (this.isNegative()) {\n            return t.negate();\n        }\n        return t;\n    };\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\n    BigInteger.prototype.next = function() {\n        var value = this.value;\n        if (this.sign) {\n            return subtractSmall(value, 1, this.sign);\n        }\n        return new BigInteger(addSmall(value, 1), this.sign);\n    };\n    SmallInteger.prototype.next = function() {\n        var value = this.value;\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\n        return new BigInteger(MAX_INT_ARR, false);\n    };\n    NativeBigInt.prototype.next = function() {\n        return new NativeBigInt(this.value + BigInt(1));\n    };\n    BigInteger.prototype.prev = function() {\n        var value = this.value;\n        if (this.sign) {\n            return new BigInteger(addSmall(value, 1), true);\n        }\n        return subtractSmall(value, 1, this.sign);\n    };\n    SmallInteger.prototype.prev = function() {\n        var value = this.value;\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\n        return new BigInteger(MAX_INT_ARR, true);\n    };\n    NativeBigInt.prototype.prev = function() {\n        return new NativeBigInt(this.value - BigInt(1));\n    };\n    var powersOfTwo = [\n        1\n    ];\n    while(2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\n    function shift_isSmall(n) {\n        return Math.abs(n) <= BASE;\n    }\n    BigInteger.prototype.shiftLeft = function(v) {\n        var n = parseValue(v).toJSNumber();\n        if (!shift_isSmall(n)) {\n            throw new Error(String(n) + \" is too large for shifting.\");\n        }\n        if (n < 0) return this.shiftRight(-n);\n        var result = this;\n        if (result.isZero()) return result;\n        while(n >= powers2Length){\n            result = result.multiply(highestPower2);\n            n -= powers2Length - 1;\n        }\n        return result.multiply(powersOfTwo[n]);\n    };\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\n    BigInteger.prototype.shiftRight = function(v) {\n        var remQuo;\n        var n = parseValue(v).toJSNumber();\n        if (!shift_isSmall(n)) {\n            throw new Error(String(n) + \" is too large for shifting.\");\n        }\n        if (n < 0) return this.shiftLeft(-n);\n        var result = this;\n        while(n >= powers2Length){\n            if (result.isZero() || result.isNegative() && result.isUnit()) return result;\n            remQuo = divModAny(result, highestPower2);\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n            n -= powers2Length - 1;\n        }\n        remQuo = divModAny(result, powersOfTwo[n]);\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n    };\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\n    function bitwise(x, y, fn) {\n        y = parseValue(y);\n        var xSign = x.isNegative(), ySign = y.isNegative();\n        var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;\n        var xDigit = 0, yDigit = 0;\n        var xDivMod = null, yDivMod = null;\n        var result = [];\n        while(!xRem.isZero() || !yRem.isZero()){\n            xDivMod = divModAny(xRem, highestPower2);\n            xDigit = xDivMod[1].toJSNumber();\n            if (xSign) {\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\n            }\n            yDivMod = divModAny(yRem, highestPower2);\n            yDigit = yDivMod[1].toJSNumber();\n            if (ySign) {\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\n            }\n            xRem = xDivMod[0];\n            yRem = yDivMod[0];\n            result.push(fn(xDigit, yDigit));\n        }\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\n        for(var i = result.length - 1; i >= 0; i -= 1){\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\n        }\n        return sum;\n    }\n    BigInteger.prototype.not = function() {\n        return this.negate().prev();\n    };\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\n    BigInteger.prototype.and = function(n) {\n        return bitwise(this, n, function(a, b) {\n            return a & b;\n        });\n    };\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\n    BigInteger.prototype.or = function(n) {\n        return bitwise(this, n, function(a, b) {\n            return a | b;\n        });\n    };\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\n    BigInteger.prototype.xor = function(n) {\n        return bitwise(this, n, function(a, b) {\n            return a ^ b;\n        });\n    };\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\n    function roughLOB(n) {\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\n        var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;\n        return x & -x;\n    }\n    function integerLogarithm(value, base) {\n        if (base.compareTo(value) <= 0) {\n            var tmp = integerLogarithm(value, base.square(base));\n            var p = tmp.p;\n            var e = tmp.e;\n            var t = p.multiply(base);\n            return t.compareTo(value) <= 0 ? {\n                p: t,\n                e: e * 2 + 1\n            } : {\n                p: p,\n                e: e * 2\n            };\n        }\n        return {\n            p: bigInt(1),\n            e: 0\n        };\n    }\n    BigInteger.prototype.bitLength = function() {\n        var n = this;\n        if (n.compareTo(bigInt(0)) < 0) {\n            n = n.negate().subtract(bigInt(1));\n        }\n        if (n.compareTo(bigInt(0)) === 0) {\n            return bigInt(0);\n        }\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\n    };\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\n    function max(a, b) {\n        a = parseValue(a);\n        b = parseValue(b);\n        return a.greater(b) ? a : b;\n    }\n    function min(a, b) {\n        a = parseValue(a);\n        b = parseValue(b);\n        return a.lesser(b) ? a : b;\n    }\n    function gcd(a, b) {\n        a = parseValue(a).abs();\n        b = parseValue(b).abs();\n        if (a.equals(b)) return a;\n        if (a.isZero()) return b;\n        if (b.isZero()) return a;\n        var c = Integer[1], d, t;\n        while(a.isEven() && b.isEven()){\n            d = min(roughLOB(a), roughLOB(b));\n            a = a.divide(d);\n            b = b.divide(d);\n            c = c.multiply(d);\n        }\n        while(a.isEven()){\n            a = a.divide(roughLOB(a));\n        }\n        do {\n            while(b.isEven()){\n                b = b.divide(roughLOB(b));\n            }\n            if (a.greater(b)) {\n                t = b;\n                b = a;\n                a = t;\n            }\n            b = b.subtract(a);\n        }while (!b.isZero());\n        return c.isUnit() ? a : a.multiply(c);\n    }\n    function lcm(a, b) {\n        a = parseValue(a).abs();\n        b = parseValue(b).abs();\n        return a.divide(gcd(a, b)).multiply(b);\n    }\n    function randBetween(a, b, rng) {\n        a = parseValue(a);\n        b = parseValue(b);\n        var usedRNG = rng || Math.random;\n        var low = min(a, b), high = max(a, b);\n        var range = high.subtract(low).add(1);\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\n        var digits = toBase(range, BASE).value;\n        var result = [], restricted = true;\n        for(var i = 0; i < digits.length; i++){\n            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;\n            var digit = truncate(usedRNG() * top);\n            result.push(digit);\n            if (digit < digits[i]) restricted = false;\n        }\n        return low.add(Integer.fromArray(result, BASE, false));\n    }\n    var parseBase = function(text, base, alphabet, caseSensitive) {\n        alphabet = alphabet || DEFAULT_ALPHABET;\n        text = String(text);\n        if (!caseSensitive) {\n            text = text.toLowerCase();\n            alphabet = alphabet.toLowerCase();\n        }\n        var length = text.length;\n        var i;\n        var absBase = Math.abs(base);\n        var alphabetValues = {};\n        for(i = 0; i < alphabet.length; i++){\n            alphabetValues[alphabet[i]] = i;\n        }\n        for(i = 0; i < length; i++){\n            var c = text[i];\n            if (c === \"-\") continue;\n            if (c in alphabetValues) {\n                if (alphabetValues[c] >= absBase) {\n                    if (c === \"1\" && absBase === 1) continue;\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\n                }\n            }\n        }\n        base = parseValue(base);\n        var digits = [];\n        var isNegative = text[0] === \"-\";\n        for(i = isNegative ? 1 : 0; i < text.length; i++){\n            var c = text[i];\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\n            else if (c === \"<\") {\n                var start = i;\n                do {\n                    i++;\n                }while (text[i] !== \">\" && i < text.length);\n                digits.push(parseValue(text.slice(start + 1, i)));\n            } else throw new Error(c + \" is not a valid character\");\n        }\n        return parseBaseFromArray(digits, base, isNegative);\n    };\n    function parseBaseFromArray(digits, base, isNegative) {\n        var val = Integer[0], pow = Integer[1], i;\n        for(i = digits.length - 1; i >= 0; i--){\n            val = val.add(digits[i].times(pow));\n            pow = pow.times(base);\n        }\n        return isNegative ? val.negate() : val;\n    }\n    function stringify(digit, alphabet) {\n        alphabet = alphabet || DEFAULT_ALPHABET;\n        if (digit < alphabet.length) {\n            return alphabet[digit];\n        }\n        return \"<\" + digit + \">\";\n    }\n    function toBase(n, base) {\n        base = bigInt(base);\n        if (base.isZero()) {\n            if (n.isZero()) return {\n                value: [\n                    0\n                ],\n                isNegative: false\n            };\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\n        }\n        if (base.equals(-1)) {\n            if (n.isZero()) return {\n                value: [\n                    0\n                ],\n                isNegative: false\n            };\n            if (n.isNegative()) return {\n                value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [\n                    1,\n                    0\n                ])),\n                isNegative: false\n            };\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [\n                0,\n                1\n            ]);\n            arr.unshift([\n                1\n            ]);\n            return {\n                value: [].concat.apply([], arr),\n                isNegative: false\n            };\n        }\n        var neg = false;\n        if (n.isNegative() && base.isPositive()) {\n            neg = true;\n            n = n.abs();\n        }\n        if (base.isUnit()) {\n            if (n.isZero()) return {\n                value: [\n                    0\n                ],\n                isNegative: false\n            };\n            return {\n                value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),\n                isNegative: neg\n            };\n        }\n        var out = [];\n        var left = n, divmod;\n        while(left.isNegative() || left.compareAbs(base) >= 0){\n            divmod = left.divmod(base);\n            left = divmod.quotient;\n            var digit = divmod.remainder;\n            if (digit.isNegative()) {\n                digit = base.minus(digit).abs();\n                left = left.next();\n            }\n            out.push(digit.toJSNumber());\n        }\n        out.push(left.toJSNumber());\n        return {\n            value: out.reverse(),\n            isNegative: neg\n        };\n    }\n    function toBaseString(n, base, alphabet) {\n        var arr = toBase(n, base);\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function(x) {\n            return stringify(x, alphabet);\n        }).join(\"\");\n    }\n    BigInteger.prototype.toArray = function(radix) {\n        return toBase(this, radix);\n    };\n    SmallInteger.prototype.toArray = function(radix) {\n        return toBase(this, radix);\n    };\n    NativeBigInt.prototype.toArray = function(radix) {\n        return toBase(this, radix);\n    };\n    BigInteger.prototype.toString = function(radix, alphabet) {\n        if (radix === undefined) radix = 10;\n        if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\n        while(--l >= 0){\n            digit = String(v[l]);\n            str += zeros.slice(digit.length) + digit;\n        }\n        var sign = this.sign ? \"-\" : \"\";\n        return sign + str;\n    };\n    SmallInteger.prototype.toString = function(radix, alphabet) {\n        if (radix === undefined) radix = 10;\n        if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);\n        return String(this.value);\n    };\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {\n        return this.toString();\n    };\n    BigInteger.prototype.valueOf = function() {\n        return parseInt(this.toString(), 10);\n    };\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\n    SmallInteger.prototype.valueOf = function() {\n        return this.value;\n    };\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {\n        return parseInt(this.toString(), 10);\n    };\n    function parseStringValue(v) {\n        if (isPrecise(+v)) {\n            var x = +v;\n            if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\n            throw new Error(\"Invalid integer: \" + v);\n        }\n        var sign = v[0] === \"-\";\n        if (sign) v = v.slice(1);\n        var split = v.split(/e/i);\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\n        if (split.length === 2) {\n            var exp = split[1];\n            if (exp[0] === \"+\") exp = exp.slice(1);\n            exp = +exp;\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\n            var text = split[0];\n            var decimalPlace = text.indexOf(\".\");\n            if (decimalPlace >= 0) {\n                exp -= text.length - decimalPlace - 1;\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\n            }\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\n            text += new Array(exp + 1).join(\"0\");\n            v = text;\n        }\n        var isValid = /^([0-9][0-9]*)$/.test(v);\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\n        if (supportsNativeBigInt) {\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\n        }\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\n        while(max > 0){\n            r.push(+v.slice(min, max));\n            min -= l;\n            if (min < 0) min = 0;\n            max -= l;\n        }\n        trim(r);\n        return new BigInteger(r, sign);\n    }\n    function parseNumberValue(v) {\n        if (supportsNativeBigInt) {\n            return new NativeBigInt(BigInt(v));\n        }\n        if (isPrecise(v)) {\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\n            return new SmallInteger(v);\n        }\n        return parseStringValue(v.toString());\n    }\n    function parseValue(v) {\n        if (typeof v === \"number\") {\n            return parseNumberValue(v);\n        }\n        if (typeof v === \"string\") {\n            return parseStringValue(v);\n        }\n        if (typeof v === \"bigint\") {\n            return new NativeBigInt(v);\n        }\n        return v;\n    }\n    // Pre-define numbers in range [-999,999]\n    for(var i = 0; i < 1000; i++){\n        Integer[i] = parseValue(i);\n        if (i > 0) Integer[-i] = parseValue(-i);\n    }\n    // Backwards compatibility\n    Integer.one = Integer[1];\n    Integer.zero = Integer[0];\n    Integer.minusOne = Integer[-1];\n    Integer.max = max;\n    Integer.min = min;\n    Integer.gcd = gcd;\n    Integer.lcm = lcm;\n    Integer.isInstance = function(x) {\n        return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;\n    };\n    Integer.randBetween = randBetween;\n    Integer.fromArray = function(digits, base, isNegative) {\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\n    };\n    return Integer;\n}();\n// Node.js check\nif ( true && module.hasOwnProperty(\"exports\")) {\n    module.exports = bigInt;\n}\n//amd check\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return bigInt;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmlnLWludGVnZXIvQmlnSW50ZWdlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsc0NBQUlBLFNBQVMsU0FBV0MsU0FBUztJQUM3QjtJQUVBLElBQUlDLE9BQU8sS0FDUEMsV0FBVyxHQUNYQyxVQUFVLGtCQUNWQyxjQUFjQyxhQUFhRixVQUMzQkcsbUJBQW1CO0lBRXZCLElBQUlDLHVCQUF1QixPQUFPQyxXQUFXO0lBRTdDLFNBQVNDLFFBQVFDLENBQUMsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLGFBQWE7UUFDOUMsSUFBSSxPQUFPSCxNQUFNLGFBQWEsT0FBT0QsT0FBTyxDQUFDLEVBQUU7UUFDL0MsSUFBSSxPQUFPRSxVQUFVLGFBQWEsT0FBTyxDQUFDQSxVQUFVLE1BQU0sQ0FBQ0MsV0FBV0UsV0FBV0osS0FBS0ssVUFBVUwsR0FBR0MsT0FBT0MsVUFBVUM7UUFDcEgsT0FBT0MsV0FBV0o7SUFDdEI7SUFFQSxTQUFTTSxXQUFXQyxLQUFLLEVBQUVDLElBQUk7UUFDM0IsSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDbkI7SUFDQUgsV0FBV0ksU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNiLFFBQVFXLFNBQVM7SUFFdEQsU0FBU0csYUFBYU4sS0FBSztRQUN2QixJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLElBQUksR0FBR0QsUUFBUTtRQUNwQixJQUFJLENBQUNFLE9BQU8sR0FBRztJQUNuQjtJQUNBSSxhQUFhSCxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ2IsUUFBUVcsU0FBUztJQUV4RCxTQUFTSSxhQUFhUCxLQUFLO1FBQ3ZCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtJQUNBTyxhQUFhSixTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ2IsUUFBUVcsU0FBUztJQUV4RCxTQUFTSyxV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LEdBQUcxUDtBQUNyQjtBQUVBLFdBQVc7QUFDWCxJQUFJLElBQTBDLEVBQUU7SUFDNUMyUCxtQ0FBUTtRQUNKLE9BQU8zUDtJQUNYLENBQUM7QUFBQSxrR0FBQztBQUNOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFidmlkaXgtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYmlnLWludGVnZXIvQmlnSW50ZWdlci5qcz9kNmM0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBiaWdJbnQgPSAoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIEJBU0UgPSAxZTcsXHJcbiAgICAgICAgTE9HX0JBU0UgPSA3LFxyXG4gICAgICAgIE1BWF9JTlQgPSA5MDA3MTk5MjU0NzQwOTkyLFxyXG4gICAgICAgIE1BWF9JTlRfQVJSID0gc21hbGxUb0FycmF5KE1BWF9JTlQpLFxyXG4gICAgICAgIERFRkFVTFRfQUxQSEFCRVQgPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xyXG5cclxuICAgIHZhciBzdXBwb3J0c05hdGl2ZUJpZ0ludCA9IHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIjtcclxuXHJcbiAgICBmdW5jdGlvbiBJbnRlZ2VyKHYsIHJhZGl4LCBhbHBoYWJldCwgY2FzZVNlbnNpdGl2ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgaWYgKHR5cGVvZiByYWRpeCAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuICtyYWRpeCA9PT0gMTAgJiYgIWFscGhhYmV0ID8gcGFyc2VWYWx1ZSh2KSA6IHBhcnNlQmFzZSh2LCByYWRpeCwgYWxwaGFiZXQsIGNhc2VTZW5zaXRpdmUpO1xyXG4gICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHYpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEJpZ0ludGVnZXIodmFsdWUsIHNpZ24pIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zaWduID0gc2lnbjtcclxuICAgICAgICB0aGlzLmlzU21hbGwgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnRlZ2VyLnByb3RvdHlwZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gU21hbGxJbnRlZ2VyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc2lnbiA9IHZhbHVlIDwgMDtcclxuICAgICAgICB0aGlzLmlzU21hbGwgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE5hdGl2ZUJpZ0ludCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEludGVnZXIucHJvdG90eXBlKTtcclxuXHJcbiAgICBmdW5jdGlvbiBpc1ByZWNpc2Uobikge1xyXG4gICAgICAgIHJldHVybiAtTUFYX0lOVCA8IG4gJiYgbiA8IE1BWF9JTlQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc21hbGxUb0FycmF5KG4pIHsgLy8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgZG9lc24ndCByZWZlcmVuY2UgQkFTRSwgbmVlZCB0byBjaGFuZ2UgdGhpcyBmdW5jdGlvbiBpZiBCQVNFIGNoYW5nZXNcclxuICAgICAgICBpZiAobiA8IDFlNylcclxuICAgICAgICAgICAgcmV0dXJuIFtuXTtcclxuICAgICAgICBpZiAobiA8IDFlMTQpXHJcbiAgICAgICAgICAgIHJldHVybiBbbiAlIDFlNywgTWF0aC5mbG9vcihuIC8gMWU3KV07XHJcbiAgICAgICAgcmV0dXJuIFtuICUgMWU3LCBNYXRoLmZsb29yKG4gLyAxZTcpICUgMWU3LCBNYXRoLmZsb29yKG4gLyAxZTE0KV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXJyYXlUb1NtYWxsKGFycikgeyAvLyBJZiBCQVNFIGNoYW5nZXMgdGhpcyBmdW5jdGlvbiBtYXkgbmVlZCB0byBjaGFuZ2VcclxuICAgICAgICB0cmltKGFycik7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA8IDQgJiYgY29tcGFyZUFicyhhcnIsIE1BWF9JTlRfQVJSKSA8IDApIHtcclxuICAgICAgICAgICAgc3dpdGNoIChsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBhcnJbMF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBhcnJbMF0gKyBhcnJbMV0gKiBCQVNFO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGFyclswXSArIChhcnJbMV0gKyBhcnJbMl0gKiBCQVNFKSAqIEJBU0U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cmltKHYpIHtcclxuICAgICAgICB2YXIgaSA9IHYubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlICh2Wy0taV0gPT09IDApO1xyXG4gICAgICAgIHYubGVuZ3RoID0gaSArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQXJyYXkobGVuZ3RoKSB7IC8vIGZ1bmN0aW9uIHNoYW1lbGVzc2x5IHN0b2xlbiBmcm9tIFlhZmZsZSdzIGxpYnJhcnkgaHR0cHM6Ly9naXRodWIuY29tL1lhZmZsZS9CaWdJbnRlZ2VyXHJcbiAgICAgICAgdmFyIHggPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICB2YXIgaSA9IC0xO1xyXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgeFtpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRydW5jYXRlKG4pIHtcclxuICAgICAgICBpZiAobiA+IDApIHJldHVybiBNYXRoLmZsb29yKG4pO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkKGEsIGIpIHsgLy8gYXNzdW1lcyBhIGFuZCBiIGFyZSBhcnJheXMgd2l0aCBhLmxlbmd0aCA+PSBiLmxlbmd0aFxyXG4gICAgICAgIHZhciBsX2EgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgbF9iID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobF9hKSxcclxuICAgICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgc3VtLCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsX2I7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gPSBhW2ldICsgYltpXSArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IHN1bSA+PSBiYXNlID8gMSA6IDA7XHJcbiAgICAgICAgICAgIHJbaV0gPSBzdW0gLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpIDwgbF9hKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gKyBjYXJyeTtcclxuICAgICAgICAgICAgY2FycnkgPSBzdW0gPT09IGJhc2UgPyAxIDogMDtcclxuICAgICAgICAgICAgcltpKytdID0gc3VtIC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FycnkgPiAwKSByLnB1c2goY2FycnkpO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZEFueShhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoID49IGIubGVuZ3RoKSByZXR1cm4gYWRkKGEsIGIpO1xyXG4gICAgICAgIHJldHVybiBhZGQoYiwgYSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkU21hbGwoYSwgY2FycnkpIHsgLy8gYXNzdW1lcyBhIGlzIGFycmF5LCBjYXJyeSBpcyBudW1iZXIgd2l0aCAwIDw9IGNhcnJ5IDwgTUFYX0lOVFxyXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBzdW0sIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gPSBhW2ldIC0gYmFzZSArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3Ioc3VtIC8gYmFzZSk7XHJcbiAgICAgICAgICAgIHJbaV0gPSBzdW0gLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgICAgIGNhcnJ5ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcclxuICAgICAgICAgICAgcltpKytdID0gY2FycnkgJSBiYXNlO1xyXG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IoY2FycnkgLyBiYXNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbiAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KG4ubmVnYXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWUsIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKGEsIE1hdGguYWJzKGIpKSwgdGhpcy5zaWduKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZEFueShhLCBiKSwgdGhpcy5zaWduKTtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wbHVzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkO1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmIChhIDwgMCAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KG4ubmVnYXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNQcmVjaXNlKGEgKyBiKSkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYSArIGIpO1xyXG4gICAgICAgICAgICBiID0gc21hbGxUb0FycmF5KE1hdGguYWJzKGIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKGIsIE1hdGguYWJzKGEpKSwgYSA8IDApO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucGx1cyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWRkO1xyXG5cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlICsgcGFyc2VWYWx1ZSh2KS52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnBsdXMgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmFkZDtcclxuXHJcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiKSB7IC8vIGFzc3VtZXMgYSBhbmQgYiBhcmUgYXJyYXlzIHdpdGggYSA+PSBiXHJcbiAgICAgICAgdmFyIGFfbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBiX2wgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShhX2wpLFxyXG4gICAgICAgICAgICBib3Jyb3cgPSAwLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgaSwgZGlmZmVyZW5jZTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYl9sOyBpKyspIHtcclxuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IGFbaV0gLSBib3Jyb3cgLSBiW2ldO1xyXG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGRpZmZlcmVuY2UgKz0gYmFzZTtcclxuICAgICAgICAgICAgICAgIGJvcnJvdyA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBib3Jyb3cgPSAwO1xyXG4gICAgICAgICAgICByW2ldID0gZGlmZmVyZW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gYl9sOyBpIDwgYV9sOyBpKyspIHtcclxuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IGFbaV0gLSBib3Jyb3c7XHJcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlIDwgMCkgZGlmZmVyZW5jZSArPSBiYXNlO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJbaSsrXSA9IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW2ldID0gZGlmZmVyZW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICg7IGkgPCBhX2w7IGkrKykge1xyXG4gICAgICAgICAgICByW2ldID0gYVtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpbShyKTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdEFueShhLCBiLCBzaWduKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgIGlmIChjb21wYXJlQWJzKGEsIGIpID49IDApIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBzdWJ0cmFjdChhLCBiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHN1YnRyYWN0KGIsIGEpO1xyXG4gICAgICAgICAgICBzaWduID0gIXNpZ247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlID0gYXJyYXlUb1NtYWxsKHZhbHVlKTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChzaWduKSB2YWx1ZSA9IC12YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodmFsdWUsIHNpZ24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0U21hbGwoYSwgYiwgc2lnbikgeyAvLyBhc3N1bWVzIGEgaXMgYXJyYXksIGIgaXMgbnVtYmVyIHdpdGggMCA8PSBiIDwgTUFYX0lOVFxyXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobCksXHJcbiAgICAgICAgICAgIGNhcnJ5ID0gLWIsXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBpLCBkaWZmZXJlbmNlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IGFbaV0gKyBjYXJyeTtcclxuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKGRpZmZlcmVuY2UgLyBiYXNlKTtcclxuICAgICAgICAgICAgZGlmZmVyZW5jZSAlPSBiYXNlO1xyXG4gICAgICAgICAgICByW2ldID0gZGlmZmVyZW5jZSA8IDAgPyBkaWZmZXJlbmNlICsgYmFzZSA6IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIgPSBhcnJheVRvU21hbGwocik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChzaWduKSByID0gLXI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHIpO1xyXG4gICAgICAgIH0gcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHIsIHNpZ24pO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbiAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChuLm5lZ2F0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbChhLCBNYXRoLmFicyhiKSwgdGhpcy5zaWduKTtcclxuICAgICAgICByZXR1cm4gc3VidHJhY3RBbnkoYSwgYiwgdGhpcy5zaWduKTtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taW51cyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG4ubmVnYXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhIC0gYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKGIsIE1hdGguYWJzKGEpLCBhID49IDApO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubWludXMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0O1xyXG5cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgLSBwYXJzZVZhbHVlKHYpLnZhbHVlKTtcclxuICAgIH1cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubWludXMgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnN1YnRyYWN0O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy52YWx1ZSwgIXRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNpZ24gPSB0aGlzLnNpZ247XHJcbiAgICAgICAgdmFyIHNtYWxsID0gbmV3IFNtYWxsSW50ZWdlcigtdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgc21hbGwuc2lnbiA9ICFzaWduO1xyXG4gICAgICAgIHJldHVybiBzbWFsbDtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCgtdGhpcy52YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcih0aGlzLnZhbHVlLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoTWF0aC5hYnModGhpcy52YWx1ZSkpO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgPj0gMCA/IHRoaXMudmFsdWUgOiAtdGhpcy52YWx1ZSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIG11bHRpcGx5TG9uZyhhLCBiKSB7XHJcbiAgICAgICAgdmFyIGFfbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBiX2wgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgbCA9IGFfbCArIGJfbCxcclxuICAgICAgICAgICAgciA9IGNyZWF0ZUFycmF5KGwpLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgcHJvZHVjdCwgY2FycnksIGksIGFfaSwgYl9qO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhX2w7ICsraSkge1xyXG4gICAgICAgICAgICBhX2kgPSBhW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJfbDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBiX2ogPSBiW2pdO1xyXG4gICAgICAgICAgICAgICAgcHJvZHVjdCA9IGFfaSAqIGJfaiArIHJbaSArIGpdO1xyXG4gICAgICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKHByb2R1Y3QgLyBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHJbaSArIGpdID0gcHJvZHVjdCAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICAgICAgICAgIHJbaSArIGogKyAxXSArPSBjYXJyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0cmltKHIpO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG11bHRpcGx5U21hbGwoYSwgYikgeyAvLyBhc3N1bWVzIGEgaXMgYXJyYXksIGIgaXMgbnVtYmVyIHdpdGggfGJ8IDwgQkFTRVxyXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICAgIHByb2R1Y3QsIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBwcm9kdWN0ID0gYVtpXSAqIGIgKyBjYXJyeTtcclxuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKHByb2R1Y3QgLyBiYXNlKTtcclxuICAgICAgICAgICAgcltpXSA9IHByb2R1Y3QgLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcclxuICAgICAgICAgICAgcltpKytdID0gY2FycnkgJSBiYXNlO1xyXG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IoY2FycnkgLyBiYXNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2hpZnRMZWZ0KHgsIG4pIHtcclxuICAgICAgICB2YXIgciA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSByLnB1c2goMCk7XHJcbiAgICAgICAgcmV0dXJuIHIuY29uY2F0KHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG11bHRpcGx5S2FyYXRzdWJhKHgsIHkpIHtcclxuICAgICAgICB2YXIgbiA9IE1hdGgubWF4KHgubGVuZ3RoLCB5Lmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGlmIChuIDw9IDMwKSByZXR1cm4gbXVsdGlwbHlMb25nKHgsIHkpO1xyXG4gICAgICAgIG4gPSBNYXRoLmNlaWwobiAvIDIpO1xyXG5cclxuICAgICAgICB2YXIgYiA9IHguc2xpY2UobiksXHJcbiAgICAgICAgICAgIGEgPSB4LnNsaWNlKDAsIG4pLFxyXG4gICAgICAgICAgICBkID0geS5zbGljZShuKSxcclxuICAgICAgICAgICAgYyA9IHkuc2xpY2UoMCwgbik7XHJcblxyXG4gICAgICAgIHZhciBhYyA9IG11bHRpcGx5S2FyYXRzdWJhKGEsIGMpLFxyXG4gICAgICAgICAgICBiZCA9IG11bHRpcGx5S2FyYXRzdWJhKGIsIGQpLFxyXG4gICAgICAgICAgICBhYmNkID0gbXVsdGlwbHlLYXJhdHN1YmEoYWRkQW55KGEsIGIpLCBhZGRBbnkoYywgZCkpO1xyXG5cclxuICAgICAgICB2YXIgcHJvZHVjdCA9IGFkZEFueShhZGRBbnkoYWMsIHNoaWZ0TGVmdChzdWJ0cmFjdChzdWJ0cmFjdChhYmNkLCBhYyksIGJkKSwgbikpLCBzaGlmdExlZnQoYmQsIDIgKiBuKSk7XHJcbiAgICAgICAgdHJpbShwcm9kdWN0KTtcclxuICAgICAgICByZXR1cm4gcHJvZHVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBhIHN1cmZhY2UgZml0IG9mIGEgZ3JhcGggcGxvdHRpbmcgdGhlIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VcclxuICAgIC8vIGJldHdlZW4gbG9uZyBtdWx0aXBsaWNhdGlvbiBhbmQga2FyYXRzdWJhIG11bHRpcGxpY2F0aW9uIHZlcnN1cyB0aGUgbGVuZ3RocyBvZiB0aGUgdHdvIGFycmF5cy5cclxuICAgIGZ1bmN0aW9uIHVzZUthcmF0c3ViYShsMSwgbDIpIHtcclxuICAgICAgICByZXR1cm4gLTAuMDEyICogbDEgLSAwLjAxMiAqIGwyICsgMC4wMDAwMTUgKiBsMSAqIGwyID4gMDtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWUsXHJcbiAgICAgICAgICAgIHNpZ24gPSB0aGlzLnNpZ24gIT09IG4uc2lnbixcclxuICAgICAgICAgICAgYWJzO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgaWYgKGIgPT09IDApIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMSkgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChiID09PSAtMSkgcmV0dXJuIHRoaXMubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIGFicyA9IE1hdGguYWJzKGIpO1xyXG4gICAgICAgICAgICBpZiAoYWJzIDwgQkFTRSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5U21hbGwoYSwgYWJzKSwgc2lnbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYiA9IHNtYWxsVG9BcnJheShhYnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXNlS2FyYXRzdWJhKGEubGVuZ3RoLCBiLmxlbmd0aCkpIC8vIEthcmF0c3ViYSBpcyBvbmx5IGZhc3RlciBmb3IgY2VydGFpbiBhcnJheSBzaXplc1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlLYXJhdHN1YmEoYSwgYiksIHNpZ24pO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseUxvbmcoYSwgYiksIHNpZ24pO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50aW1lcyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5O1xyXG5cclxuICAgIGZ1bmN0aW9uIG11bHRpcGx5U21hbGxBbmRBcnJheShhLCBiLCBzaWduKSB7IC8vIGEgPj0gMFxyXG4gICAgICAgIGlmIChhIDwgQkFTRSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlTbWFsbChiLCBhKSwgc2lnbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseUxvbmcoYiwgc21hbGxUb0FycmF5KGEpKSwgc2lnbik7XHJcbiAgICB9XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLl9tdWx0aXBseUJ5U21hbGwgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIGlmIChpc1ByZWNpc2UoYS52YWx1ZSAqIHRoaXMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKGEudmFsdWUgKiB0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG11bHRpcGx5U21hbGxBbmRBcnJheShNYXRoLmFicyhhLnZhbHVlKSwgc21hbGxUb0FycmF5KE1hdGguYWJzKHRoaXMudmFsdWUpKSwgdGhpcy5zaWduICE9PSBhLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLl9tdWx0aXBseUJ5U21hbGwgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIGlmIChhLnZhbHVlID09PSAwKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICBpZiAoYS52YWx1ZSA9PT0gMSkgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgaWYgKGEudmFsdWUgPT09IC0xKSByZXR1cm4gdGhpcy5uZWdhdGUoKTtcclxuICAgICAgICByZXR1cm4gbXVsdGlwbHlTbWFsbEFuZEFycmF5KE1hdGguYWJzKGEudmFsdWUpLCB0aGlzLnZhbHVlLCB0aGlzLnNpZ24gIT09IGEuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodikuX211bHRpcGx5QnlTbWFsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRpbWVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlICogcGFyc2VWYWx1ZSh2KS52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnRpbWVzID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbiAgICBmdW5jdGlvbiBzcXVhcmUoYSkge1xyXG4gICAgICAgIC8vY29uc29sZS5hc3NlcnQoMiAqIEJBU0UgKiBCQVNFIDwgTUFYX0lOVCk7XHJcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IGNyZWF0ZUFycmF5KGwgKyBsKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIHByb2R1Y3QsIGNhcnJ5LCBpLCBhX2ksIGFfajtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFfaSA9IGFbaV07XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gMCAtIGFfaSAqIGFfaTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBsOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGFfaiA9IGFbal07XHJcbiAgICAgICAgICAgICAgICBwcm9kdWN0ID0gMiAqIChhX2kgKiBhX2opICsgcltpICsgal0gKyBjYXJyeTtcclxuICAgICAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XHJcbiAgICAgICAgICAgICAgICByW2kgKyBqXSA9IHByb2R1Y3QgLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltpICsgbF0gPSBjYXJyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpbShyKTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHNxdWFyZSh0aGlzLnZhbHVlKSwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlICogdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAoaXNQcmVjaXNlKHZhbHVlKSkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihzcXVhcmUoc21hbGxUb0FycmF5KE1hdGguYWJzKHRoaXMudmFsdWUpKSksIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgKiB0aGlzLnZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaXZNb2QxKGEsIGIpIHsgLy8gTGVmdCBvdmVyIGZyb20gcHJldmlvdXMgdmVyc2lvbi4gUGVyZm9ybXMgZmFzdGVyIHRoYW4gZGl2TW9kMiBvbiBzbWFsbGVyIGlucHV0IHNpemVzLlxyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICByZXN1bHQgPSBjcmVhdGVBcnJheShiLmxlbmd0aCksXHJcbiAgICAgICAgICAgIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCA9IGJbYl9sIC0gMV0sXHJcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb25cclxuICAgICAgICAgICAgbGFtYmRhID0gTWF0aC5jZWlsKGJhc2UgLyAoMiAqIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCkpLFxyXG4gICAgICAgICAgICByZW1haW5kZXIgPSBtdWx0aXBseVNtYWxsKGEsIGxhbWJkYSksXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBtdWx0aXBseVNtYWxsKGIsIGxhbWJkYSksXHJcbiAgICAgICAgICAgIHF1b3RpZW50RGlnaXQsIHNoaWZ0LCBjYXJyeSwgYm9ycm93LCBpLCBsLCBxO1xyXG4gICAgICAgIGlmIChyZW1haW5kZXIubGVuZ3RoIDw9IGFfbCkgcmVtYWluZGVyLnB1c2goMCk7XHJcbiAgICAgICAgZGl2aXNvci5wdXNoKDApO1xyXG4gICAgICAgIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCA9IGRpdmlzb3JbYl9sIC0gMV07XHJcbiAgICAgICAgZm9yIChzaGlmdCA9IGFfbCAtIGJfbDsgc2hpZnQgPj0gMDsgc2hpZnQtLSkge1xyXG4gICAgICAgICAgICBxdW90aWVudERpZ2l0ID0gYmFzZSAtIDE7XHJcbiAgICAgICAgICAgIGlmIChyZW1haW5kZXJbc2hpZnQgKyBiX2xdICE9PSBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQpIHtcclxuICAgICAgICAgICAgICAgIHF1b3RpZW50RGlnaXQgPSBNYXRoLmZsb29yKChyZW1haW5kZXJbc2hpZnQgKyBiX2xdICogYmFzZSArIHJlbWFpbmRlcltzaGlmdCArIGJfbCAtIDFdKSAvIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcXVvdGllbnREaWdpdCA8PSBiYXNlIC0gMVxyXG4gICAgICAgICAgICBjYXJyeSA9IDA7XHJcbiAgICAgICAgICAgIGJvcnJvdyA9IDA7XHJcbiAgICAgICAgICAgIGwgPSBkaXZpc29yLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2FycnkgKz0gcXVvdGllbnREaWdpdCAqIGRpdmlzb3JbaV07XHJcbiAgICAgICAgICAgICAgICBxID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgYm9ycm93ICs9IHJlbWFpbmRlcltzaGlmdCArIGldIC0gKGNhcnJ5IC0gcSAqIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgY2FycnkgPSBxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvcnJvdyA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGJvcnJvdyArIGJhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9ycm93ID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gYm9ycm93O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcnJvdyA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKGJvcnJvdyAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcXVvdGllbnREaWdpdCAtPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FycnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcnJ5ICs9IHJlbWFpbmRlcltzaGlmdCArIGldIC0gYmFzZSArIGRpdmlzb3JbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcnJ5IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGNhcnJ5ICsgYmFzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FycnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gY2Fycnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBib3Jyb3cgKz0gY2Fycnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0W3NoaWZ0XSA9IHF1b3RpZW50RGlnaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRlbm9ybWFsaXphdGlvblxyXG4gICAgICAgIHJlbWFpbmRlciA9IGRpdk1vZFNtYWxsKHJlbWFpbmRlciwgbGFtYmRhKVswXTtcclxuICAgICAgICByZXR1cm4gW2FycmF5VG9TbWFsbChyZXN1bHQpLCBhcnJheVRvU21hbGwocmVtYWluZGVyKV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGl2TW9kMihhLCBiKSB7IC8vIEltcGxlbWVudGF0aW9uIGlkZWEgc2hhbWVsZXNzbHkgc3RvbGVuIGZyb20gU2lsZW50IE1hdHQncyBsaWJyYXJ5IGh0dHA6Ly9zaWxlbnRtYXR0LmNvbS9iaWdpbnRlZ2VyL1xyXG4gICAgICAgIC8vIFBlcmZvcm1zIGZhc3RlciB0aGFuIGRpdk1vZDEgb24gbGFyZ2VyIGlucHV0IHNpemVzLlxyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICBwYXJ0ID0gW10sXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBndWVzcywgeGxlbiwgaGlnaHgsIGhpZ2h5LCBjaGVjaztcclxuICAgICAgICB3aGlsZSAoYV9sKSB7XHJcbiAgICAgICAgICAgIHBhcnQudW5zaGlmdChhWy0tYV9sXSk7XHJcbiAgICAgICAgICAgIHRyaW0ocGFydCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJlQWJzKHBhcnQsIGIpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goMCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4bGVuID0gcGFydC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGhpZ2h4ID0gcGFydFt4bGVuIC0gMV0gKiBiYXNlICsgcGFydFt4bGVuIC0gMl07XHJcbiAgICAgICAgICAgIGhpZ2h5ID0gYltiX2wgLSAxXSAqIGJhc2UgKyBiW2JfbCAtIDJdO1xyXG4gICAgICAgICAgICBpZiAoeGxlbiA+IGJfbCkge1xyXG4gICAgICAgICAgICAgICAgaGlnaHggPSAoaGlnaHggKyAxKSAqIGJhc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3Vlc3MgPSBNYXRoLmNlaWwoaGlnaHggLyBoaWdoeSk7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrID0gbXVsdGlwbHlTbWFsbChiLCBndWVzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZUFicyhjaGVjaywgcGFydCkgPD0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBndWVzcy0tO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChndWVzcyk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGd1ZXNzKTtcclxuICAgICAgICAgICAgcGFydCA9IHN1YnRyYWN0KHBhcnQsIGNoZWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnJldmVyc2UoKTtcclxuICAgICAgICByZXR1cm4gW2FycmF5VG9TbWFsbChyZXN1bHQpLCBhcnJheVRvU21hbGwocGFydCldO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpdk1vZFNtYWxsKHZhbHVlLCBsYW1iZGEpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxyXG4gICAgICAgICAgICBxdW90aWVudCA9IGNyZWF0ZUFycmF5KGxlbmd0aCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBpLCBxLCByZW1haW5kZXIsIGRpdmlzb3I7XHJcbiAgICAgICAgcmVtYWluZGVyID0gMDtcclxuICAgICAgICBmb3IgKGkgPSBsZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICBkaXZpc29yID0gcmVtYWluZGVyICogYmFzZSArIHZhbHVlW2ldO1xyXG4gICAgICAgICAgICBxID0gdHJ1bmNhdGUoZGl2aXNvciAvIGxhbWJkYSk7XHJcbiAgICAgICAgICAgIHJlbWFpbmRlciA9IGRpdmlzb3IgLSBxICogbGFtYmRhO1xyXG4gICAgICAgICAgICBxdW90aWVudFtpXSA9IHEgfCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3F1b3RpZW50LCByZW1haW5kZXIgfCAwXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaXZNb2RBbnkoc2VsZiwgdikge1xyXG4gICAgICAgIHZhciB2YWx1ZSwgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgaWYgKHN1cHBvcnRzTmF0aXZlQmlnSW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbbmV3IE5hdGl2ZUJpZ0ludChzZWxmLnZhbHVlIC8gbi52YWx1ZSksIG5ldyBOYXRpdmVCaWdJbnQoc2VsZi52YWx1ZSAlIG4udmFsdWUpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGEgPSBzZWxmLnZhbHVlLCBiID0gbi52YWx1ZTtcclxuICAgICAgICB2YXIgcXVvdGllbnQ7XHJcbiAgICAgICAgaWYgKGIgPT09IDApIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkaXZpZGUgYnkgemVyb1wiKTtcclxuICAgICAgICBpZiAoc2VsZi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFNtYWxsSW50ZWdlcih0cnVuY2F0ZShhIC8gYikpLCBuZXcgU21hbGxJbnRlZ2VyKGEgJSBiKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtJbnRlZ2VyWzBdLCBzZWxmXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMSkgcmV0dXJuIFtzZWxmLCBJbnRlZ2VyWzBdXTtcclxuICAgICAgICAgICAgaWYgKGIgPT0gLTEpIHJldHVybiBbc2VsZi5uZWdhdGUoKSwgSW50ZWdlclswXV07XHJcbiAgICAgICAgICAgIHZhciBhYnMgPSBNYXRoLmFicyhiKTtcclxuICAgICAgICAgICAgaWYgKGFicyA8IEJBU0UpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGl2TW9kU21hbGwoYSwgYWJzKTtcclxuICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gYXJyYXlUb1NtYWxsKHZhbHVlWzBdKTtcclxuICAgICAgICAgICAgICAgIHZhciByZW1haW5kZXIgPSB2YWx1ZVsxXTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNpZ24pIHJlbWFpbmRlciA9IC1yZW1haW5kZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHF1b3RpZW50ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuc2lnbiAhPT0gbi5zaWduKSBxdW90aWVudCA9IC1xdW90aWVudDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBTbWFsbEludGVnZXIocXVvdGllbnQpLCBuZXcgU21hbGxJbnRlZ2VyKHJlbWFpbmRlcildO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgQmlnSW50ZWdlcihxdW90aWVudCwgc2VsZi5zaWduICE9PSBuLnNpZ24pLCBuZXcgU21hbGxJbnRlZ2VyKHJlbWFpbmRlcildO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoYWJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbXBhcmlzb24gPSBjb21wYXJlQWJzKGEsIGIpO1xyXG4gICAgICAgIGlmIChjb21wYXJpc29uID09PSAtMSkgcmV0dXJuIFtJbnRlZ2VyWzBdLCBzZWxmXTtcclxuICAgICAgICBpZiAoY29tcGFyaXNvbiA9PT0gMCkgcmV0dXJuIFtJbnRlZ2VyW3NlbGYuc2lnbiA9PT0gbi5zaWduID8gMSA6IC0xXSwgSW50ZWdlclswXV07XHJcblxyXG4gICAgICAgIC8vIGRpdk1vZDEgaXMgZmFzdGVyIG9uIHNtYWxsZXIgaW5wdXQgc2l6ZXNcclxuICAgICAgICBpZiAoYS5sZW5ndGggKyBiLmxlbmd0aCA8PSAyMDApXHJcbiAgICAgICAgICAgIHZhbHVlID0gZGl2TW9kMShhLCBiKTtcclxuICAgICAgICBlbHNlIHZhbHVlID0gZGl2TW9kMihhLCBiKTtcclxuXHJcbiAgICAgICAgcXVvdGllbnQgPSB2YWx1ZVswXTtcclxuICAgICAgICB2YXIgcVNpZ24gPSBzZWxmLnNpZ24gIT09IG4uc2lnbixcclxuICAgICAgICAgICAgbW9kID0gdmFsdWVbMV0sXHJcbiAgICAgICAgICAgIG1TaWduID0gc2VsZi5zaWduO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcXVvdGllbnQgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKHFTaWduKSBxdW90aWVudCA9IC1xdW90aWVudDtcclxuICAgICAgICAgICAgcXVvdGllbnQgPSBuZXcgU21hbGxJbnRlZ2VyKHF1b3RpZW50KTtcclxuICAgICAgICB9IGVsc2UgcXVvdGllbnQgPSBuZXcgQmlnSW50ZWdlcihxdW90aWVudCwgcVNpZ24pO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbW9kID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChtU2lnbikgbW9kID0gLW1vZDtcclxuICAgICAgICAgICAgbW9kID0gbmV3IFNtYWxsSW50ZWdlcihtb2QpO1xyXG4gICAgICAgIH0gZWxzZSBtb2QgPSBuZXcgQmlnSW50ZWdlcihtb2QsIG1TaWduKTtcclxuICAgICAgICByZXR1cm4gW3F1b3RpZW50LCBtb2RdO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRpdk1vZEFueSh0aGlzLCB2KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBxdW90aWVudDogcmVzdWx0WzBdLFxyXG4gICAgICAgICAgICByZW1haW5kZXI6IHJlc3VsdFsxXVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5kaXZtb2QgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmRpdm1vZCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZDtcclxuXHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gZGl2TW9kQW55KHRoaXMsIHYpWzBdO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUub3ZlciA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlIC8gcGFyc2VWYWx1ZSh2KS52YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vdmVyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vdmVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIGRpdk1vZEFueSh0aGlzLCB2KVsxXTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm1vZCA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUucmVtYWluZGVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlICUgcGFyc2VWYWx1ZSh2KS52YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm1vZCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlLFxyXG4gICAgICAgICAgICB2YWx1ZSwgeCwgeTtcclxuICAgICAgICBpZiAoYiA9PT0gMCkgcmV0dXJuIEludGVnZXJbMV07XHJcbiAgICAgICAgaWYgKGEgPT09IDApIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgIGlmIChhID09PSAxKSByZXR1cm4gSW50ZWdlclsxXTtcclxuICAgICAgICBpZiAoYSA9PT0gLTEpIHJldHVybiBuLmlzRXZlbigpID8gSW50ZWdlclsxXSA6IEludGVnZXJbLTFdO1xyXG4gICAgICAgIGlmIChuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbi5pc1NtYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZXhwb25lbnQgXCIgKyBuLnRvU3RyaW5nKCkgKyBcIiBpcyB0b28gbGFyZ2UuXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgaWYgKGlzUHJlY2lzZSh2YWx1ZSA9IE1hdGgucG93KGEsIGIpKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHRydW5jYXRlKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHggPSB0aGlzO1xyXG4gICAgICAgIHkgPSBJbnRlZ2VyWzFdO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmIChiICYgMSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICAgICAgICAtLWI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGIgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBiIC89IDI7XHJcbiAgICAgICAgICAgIHggPSB4LnNxdWFyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnBvdyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdztcclxuXHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgdmFyIF8wID0gQmlnSW50KDApLCBfMSA9IEJpZ0ludCgxKSwgXzIgPSBCaWdJbnQoMik7XHJcbiAgICAgICAgaWYgKGIgPT09IF8wKSByZXR1cm4gSW50ZWdlclsxXTtcclxuICAgICAgICBpZiAoYSA9PT0gXzApIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgIGlmIChhID09PSBfMSkgcmV0dXJuIEludGVnZXJbMV07XHJcbiAgICAgICAgaWYgKGEgPT09IEJpZ0ludCgtMSkpIHJldHVybiBuLmlzRXZlbigpID8gSW50ZWdlclsxXSA6IEludGVnZXJbLTFdO1xyXG4gICAgICAgIGlmIChuLmlzTmVnYXRpdmUoKSkgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQoXzApO1xyXG4gICAgICAgIHZhciB4ID0gdGhpcztcclxuICAgICAgICB2YXIgeSA9IEludGVnZXJbMV07XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKChiICYgXzEpID09PSBfMSkge1xyXG4gICAgICAgICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICAgICAgICAtLWI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGIgPT09IF8wKSBicmVhaztcclxuICAgICAgICAgICAgYiAvPSBfMjtcclxuICAgICAgICAgICAgeCA9IHguc3F1YXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IGZ1bmN0aW9uIChleHAsIG1vZCkge1xyXG4gICAgICAgIGV4cCA9IHBhcnNlVmFsdWUoZXhwKTtcclxuICAgICAgICBtb2QgPSBwYXJzZVZhbHVlKG1vZCk7XHJcbiAgICAgICAgaWYgKG1vZC5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRha2UgbW9kUG93IHdpdGggbW9kdWx1cyAwXCIpO1xyXG4gICAgICAgIHZhciByID0gSW50ZWdlclsxXSxcclxuICAgICAgICAgICAgYmFzZSA9IHRoaXMubW9kKG1vZCk7XHJcbiAgICAgICAgaWYgKGV4cC5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgZXhwID0gZXhwLm11bHRpcGx5KEludGVnZXJbLTFdKTtcclxuICAgICAgICAgICAgYmFzZSA9IGJhc2UubW9kSW52KG1vZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChleHAuaXNQb3NpdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXNlLmlzWmVybygpKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICAgICAgaWYgKGV4cC5pc09kZCgpKSByID0gci5tdWx0aXBseShiYXNlKS5tb2QobW9kKTtcclxuICAgICAgICAgICAgZXhwID0gZXhwLmRpdmlkZSgyKTtcclxuICAgICAgICAgICAgYmFzZSA9IGJhc2Uuc3F1YXJlKCkubW9kKG1vZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubW9kUG93ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3c7XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGFyZUFicyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZUFicyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkgcmV0dXJuIDE7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVBYnMoYSwgYik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlQWJzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSBNYXRoLmFicyh0aGlzLnZhbHVlKSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBiID0gTWF0aC5hYnMoYik7XHJcbiAgICAgICAgICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5jb21wYXJlQWJzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgdmFyIGIgPSBwYXJzZVZhbHVlKHYpLnZhbHVlO1xyXG4gICAgICAgIGEgPSBhID49IDAgPyBhIDogLWE7XHJcbiAgICAgICAgYiA9IGIgPj0gMCA/IGIgOiAtYjtcclxuICAgICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBhYm91dCBjb21wYXJpc29uIHdpdGggSW5maW5pdHk6XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BldGVyb2xzb24vQmlnSW50ZWdlci5qcy9pc3N1ZXMvNjFcclxuICAgICAgICBpZiAodiA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodiA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbiAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuLnNpZ24gPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbiA/IC0xIDogMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVBYnMoYSwgYikgKiAodGhpcy5zaWduID8gLTEgOiAxKTtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHYgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYgPT09IC1JbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYSA8IDAgPyAxIDogLTE7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmU7XHJcblxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAodiA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodiA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgdmFyIGIgPSBwYXJzZVZhbHVlKHYpLnZhbHVlO1xyXG4gICAgICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xyXG4gICAgfVxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5jb21wYXJlVG8gPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmNvbXBhcmU7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpID09PSAwO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZXEgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmVxdWFscyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSAhPT0gMDtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5lcSA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubm90RXF1YWxzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm5vdEVxdWFscyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm5lcSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpID4gMDtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmd0ID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5ncmVhdGVyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ndCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmd0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlcjtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPCAwO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubHQgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmxlc3NlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubHQgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlc3NlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmx0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA+PSAwO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZ2VxID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmdlcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ2VxID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpIDw9IDA7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5sZXEgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZVswXSAmIDEpID09PSAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIDEpID09PSAwO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIEJpZ0ludCgxKSkgPT09IEJpZ0ludCgwKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWVbMF0gJiAxKSA9PT0gMTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIDEpID09PSAxO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgQmlnSW50KDEpKSA9PT0gQmlnSW50KDEpO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnNpZ247XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID4gMDtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzUG9zaXRpdmUgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUG9zaXRpdmU7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaWduO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA8IDA7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc05lZ2F0aXZlID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc05lZ2F0aXZlO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1VuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMudmFsdWUpID09PSAxO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFicygpLnZhbHVlID09PSBCaWdJbnQoMSk7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gMDtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gQmlnSW50KDApO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnkgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChuLmlzVW5pdCgpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAobi5jb21wYXJlQWJzKDIpID09PSAwKSByZXR1cm4gdGhpcy5pc0V2ZW4oKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2QobikuaXNaZXJvKCk7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeTtcclxuXHJcbiAgICBmdW5jdGlvbiBpc0Jhc2ljUHJpbWUodikge1xyXG4gICAgICAgIHZhciBuID0gdi5hYnMoKTtcclxuICAgICAgICBpZiAobi5pc1VuaXQoKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChuLmVxdWFscygyKSB8fCBuLmVxdWFscygzKSB8fCBuLmVxdWFscyg1KSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKG4uaXNFdmVuKCkgfHwgbi5pc0RpdmlzaWJsZUJ5KDMpIHx8IG4uaXNEaXZpc2libGVCeSg1KSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChuLmxlc3Nlcig0OSkpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIC8vIHdlIGRvbid0IGtub3cgaWYgaXQncyBwcmltZTogbGV0IHRoZSBvdGhlciBmdW5jdGlvbnMgZmlndXJlIGl0IG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1pbGxlclJhYmluVGVzdChuLCBhKSB7XHJcbiAgICAgICAgdmFyIG5QcmV2ID0gbi5wcmV2KCksXHJcbiAgICAgICAgICAgIGIgPSBuUHJldixcclxuICAgICAgICAgICAgciA9IDAsXHJcbiAgICAgICAgICAgIGQsIHQsIGksIHg7XHJcbiAgICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIGIgPSBiLmRpdmlkZSgyKSwgcisrO1xyXG4gICAgICAgIG5leHQ6IGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmxlc3NlcihhW2ldKSkgY29udGludWU7XHJcbiAgICAgICAgICAgIHggPSBiaWdJbnQoYVtpXSkubW9kUG93KGIsIG4pO1xyXG4gICAgICAgICAgICBpZiAoeC5pc1VuaXQoKSB8fCB4LmVxdWFscyhuUHJldikpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBmb3IgKGQgPSByIC0gMTsgZCAhPSAwOyBkLS0pIHtcclxuICAgICAgICAgICAgICAgIHggPSB4LnNxdWFyZSgpLm1vZChuKTtcclxuICAgICAgICAgICAgICAgIGlmICh4LmlzVW5pdCgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoeC5lcXVhbHMoblByZXYpKSBjb250aW51ZSBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IFwic3RyaWN0XCIgdG8gdHJ1ZSB0byBmb3JjZSBHUkgtc3VwcG9ydGVkIGxvd2VyIGJvdW5kIG9mIDIqbG9nKE4pXjJcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJpbWUgPSBmdW5jdGlvbiAoc3RyaWN0KSB7XHJcbiAgICAgICAgdmFyIGlzUHJpbWUgPSBpc0Jhc2ljUHJpbWUodGhpcyk7XHJcbiAgICAgICAgaWYgKGlzUHJpbWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzUHJpbWU7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLmFicygpO1xyXG4gICAgICAgIHZhciBiaXRzID0gbi5iaXRMZW5ndGgoKTtcclxuICAgICAgICBpZiAoYml0cyA8PSA2NClcclxuICAgICAgICAgICAgcmV0dXJuIG1pbGxlclJhYmluVGVzdChuLCBbMiwgMywgNSwgNywgMTEsIDEzLCAxNywgMTksIDIzLCAyOSwgMzEsIDM3XSk7XHJcbiAgICAgICAgdmFyIGxvZ04gPSBNYXRoLmxvZygyKSAqIGJpdHMudG9KU051bWJlcigpO1xyXG4gICAgICAgIHZhciB0ID0gTWF0aC5jZWlsKChzdHJpY3QgPT09IHRydWUpID8gKDIgKiBNYXRoLnBvdyhsb2dOLCAyKSkgOiBsb2dOKTtcclxuICAgICAgICBmb3IgKHZhciBhID0gW10sIGkgPSAwOyBpIDwgdDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGEucHVzaChiaWdJbnQoaSArIDIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1pbGxlclJhYmluVGVzdChuLCBhKTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzUHJpbWUgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUHJpbWUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uIChpdGVyYXRpb25zLCBybmcpIHtcclxuICAgICAgICB2YXIgaXNQcmltZSA9IGlzQmFzaWNQcmltZSh0aGlzKTtcclxuICAgICAgICBpZiAoaXNQcmltZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gaXNQcmltZTtcclxuICAgICAgICB2YXIgbiA9IHRoaXMuYWJzKCk7XHJcbiAgICAgICAgdmFyIHQgPSBpdGVyYXRpb25zID09PSB1bmRlZmluZWQgPyA1IDogaXRlcmF0aW9ucztcclxuICAgICAgICBmb3IgKHZhciBhID0gW10sIGkgPSAwOyBpIDwgdDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGEucHVzaChiaWdJbnQucmFuZEJldHdlZW4oMiwgbi5taW51cygyKSwgcm5nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtaWxsZXJSYWJpblRlc3QobiwgYSk7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnYgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHZhciB0ID0gYmlnSW50Lnplcm8sIG5ld1QgPSBiaWdJbnQub25lLCByID0gcGFyc2VWYWx1ZShuKSwgbmV3UiA9IHRoaXMuYWJzKCksIHEsIGxhc3RULCBsYXN0UjtcclxuICAgICAgICB3aGlsZSAoIW5ld1IuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgcSA9IHIuZGl2aWRlKG5ld1IpO1xyXG4gICAgICAgICAgICBsYXN0VCA9IHQ7XHJcbiAgICAgICAgICAgIGxhc3RSID0gcjtcclxuICAgICAgICAgICAgdCA9IG5ld1Q7XHJcbiAgICAgICAgICAgIHIgPSBuZXdSO1xyXG4gICAgICAgICAgICBuZXdUID0gbGFzdFQuc3VidHJhY3QocS5tdWx0aXBseShuZXdUKSk7XHJcbiAgICAgICAgICAgIG5ld1IgPSBsYXN0Ui5zdWJ0cmFjdChxLm11bHRpcGx5KG5ld1IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyLmlzVW5pdCgpKSB0aHJvdyBuZXcgRXJyb3IodGhpcy50b1N0cmluZygpICsgXCIgYW5kIFwiICsgbi50b1N0cmluZygpICsgXCIgYXJlIG5vdCBjby1wcmltZVwiKTtcclxuICAgICAgICBpZiAodC5jb21wYXJlKDApID09PSAtMSkge1xyXG4gICAgICAgICAgICB0ID0gdC5hZGQobik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdC5uZWdhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubW9kSW52ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnYgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnY7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwodmFsdWUsIDEsIHRoaXMuc2lnbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbCh2YWx1ZSwgMSksIHRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlICsgMSA8IE1BWF9JTlQpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKE1BWF9JTlRfQVJSLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgKyBCaWdJbnQoMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbCh2YWx1ZSwgMSksIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbCh2YWx1ZSwgMSwgdGhpcy5zaWduKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAodmFsdWUgLSAxID4gLU1BWF9JTlQpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlIC0gMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKE1BWF9JTlRfQVJSLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAtIEJpZ0ludCgxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBvd2Vyc09mVHdvID0gWzFdO1xyXG4gICAgd2hpbGUgKDIgKiBwb3dlcnNPZlR3b1twb3dlcnNPZlR3by5sZW5ndGggLSAxXSA8PSBCQVNFKSBwb3dlcnNPZlR3by5wdXNoKDIgKiBwb3dlcnNPZlR3b1twb3dlcnNPZlR3by5sZW5ndGggLSAxXSk7XHJcbiAgICB2YXIgcG93ZXJzMkxlbmd0aCA9IHBvd2Vyc09mVHdvLmxlbmd0aCwgaGlnaGVzdFBvd2VyMiA9IHBvd2Vyc09mVHdvW3Bvd2VyczJMZW5ndGggLSAxXTtcclxuXHJcbiAgICBmdW5jdGlvbiBzaGlmdF9pc1NtYWxsKG4pIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMobikgPD0gQkFTRTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KS50b0pTTnVtYmVyKCk7XHJcbiAgICAgICAgaWYgKCFzaGlmdF9pc1NtYWxsKG4pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihTdHJpbmcobikgKyBcIiBpcyB0b28gbGFyZ2UgZm9yIHNoaWZ0aW5nLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4gPCAwKSByZXR1cm4gdGhpcy5zaGlmdFJpZ2h0KC1uKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcztcclxuICAgICAgICBpZiAocmVzdWx0LmlzWmVybygpKSByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIHdoaWxlIChuID49IHBvd2VyczJMZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bHRpcGx5KGhpZ2hlc3RQb3dlcjIpO1xyXG4gICAgICAgICAgICBuIC09IHBvd2VyczJMZW5ndGggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0Lm11bHRpcGx5KHBvd2Vyc09mVHdvW25dKTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnNoaWZ0TGVmdCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciByZW1RdW87XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLnRvSlNOdW1iZXIoKTtcclxuICAgICAgICBpZiAoIXNoaWZ0X2lzU21hbGwobikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFN0cmluZyhuKSArIFwiIGlzIHRvbyBsYXJnZSBmb3Igc2hpZnRpbmcuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobiA8IDApIHJldHVybiB0aGlzLnNoaWZ0TGVmdCgtbik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKG4gPj0gcG93ZXJzMkxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LmlzWmVybygpIHx8IChyZXN1bHQuaXNOZWdhdGl2ZSgpICYmIHJlc3VsdC5pc1VuaXQoKSkpIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIHJlbVF1byA9IGRpdk1vZEFueShyZXN1bHQsIGhpZ2hlc3RQb3dlcjIpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZW1RdW9bMV0uaXNOZWdhdGl2ZSgpID8gcmVtUXVvWzBdLnByZXYoKSA6IHJlbVF1b1swXTtcclxuICAgICAgICAgICAgbiAtPSBwb3dlcnMyTGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtUXVvID0gZGl2TW9kQW55KHJlc3VsdCwgcG93ZXJzT2ZUd29bbl0pO1xyXG4gICAgICAgIHJldHVybiByZW1RdW9bMV0uaXNOZWdhdGl2ZSgpID8gcmVtUXVvWzBdLnByZXYoKSA6IHJlbVF1b1swXTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0O1xyXG5cclxuICAgIGZ1bmN0aW9uIGJpdHdpc2UoeCwgeSwgZm4pIHtcclxuICAgICAgICB5ID0gcGFyc2VWYWx1ZSh5KTtcclxuICAgICAgICB2YXIgeFNpZ24gPSB4LmlzTmVnYXRpdmUoKSwgeVNpZ24gPSB5LmlzTmVnYXRpdmUoKTtcclxuICAgICAgICB2YXIgeFJlbSA9IHhTaWduID8geC5ub3QoKSA6IHgsXHJcbiAgICAgICAgICAgIHlSZW0gPSB5U2lnbiA/IHkubm90KCkgOiB5O1xyXG4gICAgICAgIHZhciB4RGlnaXQgPSAwLCB5RGlnaXQgPSAwO1xyXG4gICAgICAgIHZhciB4RGl2TW9kID0gbnVsbCwgeURpdk1vZCA9IG51bGw7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHdoaWxlICgheFJlbS5pc1plcm8oKSB8fCAheVJlbS5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICB4RGl2TW9kID0gZGl2TW9kQW55KHhSZW0sIGhpZ2hlc3RQb3dlcjIpO1xyXG4gICAgICAgICAgICB4RGlnaXQgPSB4RGl2TW9kWzFdLnRvSlNOdW1iZXIoKTtcclxuICAgICAgICAgICAgaWYgKHhTaWduKSB7XHJcbiAgICAgICAgICAgICAgICB4RGlnaXQgPSBoaWdoZXN0UG93ZXIyIC0gMSAtIHhEaWdpdDsgLy8gdHdvJ3MgY29tcGxlbWVudCBmb3IgbmVnYXRpdmUgbnVtYmVyc1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB5RGl2TW9kID0gZGl2TW9kQW55KHlSZW0sIGhpZ2hlc3RQb3dlcjIpO1xyXG4gICAgICAgICAgICB5RGlnaXQgPSB5RGl2TW9kWzFdLnRvSlNOdW1iZXIoKTtcclxuICAgICAgICAgICAgaWYgKHlTaWduKSB7XHJcbiAgICAgICAgICAgICAgICB5RGlnaXQgPSBoaWdoZXN0UG93ZXIyIC0gMSAtIHlEaWdpdDsgLy8gdHdvJ3MgY29tcGxlbWVudCBmb3IgbmVnYXRpdmUgbnVtYmVyc1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4UmVtID0geERpdk1vZFswXTtcclxuICAgICAgICAgICAgeVJlbSA9IHlEaXZNb2RbMF07XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZuKHhEaWdpdCwgeURpZ2l0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdW0gPSBmbih4U2lnbiA/IDEgOiAwLCB5U2lnbiA/IDEgOiAwKSAhPT0gMCA/IGJpZ0ludCgtMSkgOiBiaWdJbnQoMCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgICAgICAgICBzdW0gPSBzdW0ubXVsdGlwbHkoaGlnaGVzdFBvd2VyMikuYWRkKGJpZ0ludChyZXN1bHRbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkucHJldigpO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubm90ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3Q7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICByZXR1cm4gYml0d2lzZSh0aGlzLCBuLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAmIGI7IH0pO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuYW5kID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQ7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIHwgYjsgfSk7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5vciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUub3IgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vcjtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIF4gYjsgfSk7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS54b3IgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnhvciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnhvcjtcclxuXHJcbiAgICB2YXIgTE9CTUFTS19JID0gMSA8PCAzMCwgTE9CTUFTS19CSSA9IChCQVNFICYgLUJBU0UpICogKEJBU0UgJiAtQkFTRSkgfCBMT0JNQVNLX0k7XHJcbiAgICBmdW5jdGlvbiByb3VnaExPQihuKSB7IC8vIGdldCBsb3dlc3RPbmVCaXQgKHJvdWdoKVxyXG4gICAgICAgIC8vIFNtYWxsSW50ZWdlcjogcmV0dXJuIE1pbihsb3dlc3RPbmVCaXQobiksIDEgPDwgMzApXHJcbiAgICAgICAgLy8gQmlnSW50ZWdlcjogcmV0dXJuIE1pbihsb3dlc3RPbmVCaXQobiksIDEgPDwgMTQpIFtCQVNFPTFlN11cclxuICAgICAgICB2YXIgdiA9IG4udmFsdWUsXHJcbiAgICAgICAgICAgIHggPSB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiA/IHYgfCBMT0JNQVNLX0kgOlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHYgPT09IFwiYmlnaW50XCIgPyB2IHwgQmlnSW50KExPQk1BU0tfSSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIHZbMF0gKyB2WzFdICogQkFTRSB8IExPQk1BU0tfQkk7XHJcbiAgICAgICAgcmV0dXJuIHggJiAteDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnRlZ2VyTG9nYXJpdGhtKHZhbHVlLCBiYXNlKSB7XHJcbiAgICAgICAgaWYgKGJhc2UuY29tcGFyZVRvKHZhbHVlKSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSBpbnRlZ2VyTG9nYXJpdGhtKHZhbHVlLCBiYXNlLnNxdWFyZShiYXNlKSk7XHJcbiAgICAgICAgICAgIHZhciBwID0gdG1wLnA7XHJcbiAgICAgICAgICAgIHZhciBlID0gdG1wLmU7XHJcbiAgICAgICAgICAgIHZhciB0ID0gcC5tdWx0aXBseShiYXNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHQuY29tcGFyZVRvKHZhbHVlKSA8PSAwID8geyBwOiB0LCBlOiBlICogMiArIDEgfSA6IHsgcDogcCwgZTogZSAqIDIgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgcDogYmlnSW50KDEpLCBlOiAwIH07XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBuID0gdGhpcztcclxuICAgICAgICBpZiAobi5jb21wYXJlVG8oYmlnSW50KDApKSA8IDApIHtcclxuICAgICAgICAgICAgbiA9IG4ubmVnYXRlKCkuc3VidHJhY3QoYmlnSW50KDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4uY29tcGFyZVRvKGJpZ0ludCgwKSkgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpZ0ludCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJpZ0ludChpbnRlZ2VyTG9nYXJpdGhtKG4sIGJpZ0ludCgyKSkuZSkuYWRkKGJpZ0ludCgxKSk7XHJcbiAgICB9XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmJpdExlbmd0aCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoID0gQmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoO1xyXG5cclxuICAgIGZ1bmN0aW9uIG1heChhLCBiKSB7XHJcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSk7XHJcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYik7XHJcbiAgICAgICAgcmV0dXJuIGEuZ3JlYXRlcihiKSA/IGEgOiBiO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWluKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcclxuICAgICAgICByZXR1cm4gYS5sZXNzZXIoYikgPyBhIDogYjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdjZChhLCBiKSB7XHJcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSkuYWJzKCk7XHJcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYikuYWJzKCk7XHJcbiAgICAgICAgaWYgKGEuZXF1YWxzKGIpKSByZXR1cm4gYTtcclxuICAgICAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGI7XHJcbiAgICAgICAgaWYgKGIuaXNaZXJvKCkpIHJldHVybiBhO1xyXG4gICAgICAgIHZhciBjID0gSW50ZWdlclsxXSwgZCwgdDtcclxuICAgICAgICB3aGlsZSAoYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpKSB7XHJcbiAgICAgICAgICAgIGQgPSBtaW4ocm91Z2hMT0IoYSksIHJvdWdoTE9CKGIpKTtcclxuICAgICAgICAgICAgYSA9IGEuZGl2aWRlKGQpO1xyXG4gICAgICAgICAgICBiID0gYi5kaXZpZGUoZCk7XHJcbiAgICAgICAgICAgIGMgPSBjLm11bHRpcGx5KGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xyXG4gICAgICAgICAgICBhID0gYS5kaXZpZGUocm91Z2hMT0IoYSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XHJcbiAgICAgICAgICAgICAgICBiID0gYi5kaXZpZGUocm91Z2hMT0IoYikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhLmdyZWF0ZXIoYikpIHtcclxuICAgICAgICAgICAgICAgIHQgPSBiOyBiID0gYTsgYSA9IHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYiA9IGIuc3VidHJhY3QoYSk7XHJcbiAgICAgICAgfSB3aGlsZSAoIWIuaXNaZXJvKCkpO1xyXG4gICAgICAgIHJldHVybiBjLmlzVW5pdCgpID8gYSA6IGEubXVsdGlwbHkoYyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBsY20oYSwgYikge1xyXG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpLmFicygpO1xyXG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpLmFicygpO1xyXG4gICAgICAgIHJldHVybiBhLmRpdmlkZShnY2QoYSwgYikpLm11bHRpcGx5KGIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmFuZEJldHdlZW4oYSwgYiwgcm5nKSB7XHJcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSk7XHJcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYik7XHJcbiAgICAgICAgdmFyIHVzZWRSTkcgPSBybmcgfHwgTWF0aC5yYW5kb207XHJcbiAgICAgICAgdmFyIGxvdyA9IG1pbihhLCBiKSwgaGlnaCA9IG1heChhLCBiKTtcclxuICAgICAgICB2YXIgcmFuZ2UgPSBoaWdoLnN1YnRyYWN0KGxvdykuYWRkKDEpO1xyXG4gICAgICAgIGlmIChyYW5nZS5pc1NtYWxsKSByZXR1cm4gbG93LmFkZChNYXRoLmZsb29yKHVzZWRSTkcoKSAqIHJhbmdlKSk7XHJcbiAgICAgICAgdmFyIGRpZ2l0cyA9IHRvQmFzZShyYW5nZSwgQkFTRSkudmFsdWU7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCByZXN0cmljdGVkID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdG9wID0gcmVzdHJpY3RlZCA/IGRpZ2l0c1tpXSArIChpICsgMSA8IGRpZ2l0cy5sZW5ndGggPyBkaWdpdHNbaSArIDFdIC8gQkFTRSA6IDApIDogQkFTRTtcclxuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gdHJ1bmNhdGUodXNlZFJORygpICogdG9wKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGlnaXQpO1xyXG4gICAgICAgICAgICBpZiAoZGlnaXQgPCBkaWdpdHNbaV0pIHJlc3RyaWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvdy5hZGQoSW50ZWdlci5mcm9tQXJyYXkocmVzdWx0LCBCQVNFLCBmYWxzZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwYXJzZUJhc2UgPSBmdW5jdGlvbiAodGV4dCwgYmFzZSwgYWxwaGFiZXQsIGNhc2VTZW5zaXRpdmUpIHtcclxuICAgICAgICBhbHBoYWJldCA9IGFscGhhYmV0IHx8IERFRkFVTFRfQUxQSEFCRVQ7XHJcbiAgICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0KTtcclxuICAgICAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcclxuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgYWxwaGFiZXQgPSBhbHBoYWJldC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGFic0Jhc2UgPSBNYXRoLmFicyhiYXNlKTtcclxuICAgICAgICB2YXIgYWxwaGFiZXRWYWx1ZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYWxwaGFiZXRWYWx1ZXNbYWxwaGFiZXRbaV1dID0gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGV4dFtpXTtcclxuICAgICAgICAgICAgaWYgKGMgPT09IFwiLVwiKSBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKGMgaW4gYWxwaGFiZXRWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhbHBoYWJldFZhbHVlc1tjXSA+PSBhYnNCYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiMVwiICYmIGFic0Jhc2UgPT09IDEpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjICsgXCIgaXMgbm90IGEgdmFsaWQgZGlnaXQgaW4gYmFzZSBcIiArIGJhc2UgKyBcIi5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYmFzZSA9IHBhcnNlVmFsdWUoYmFzZSk7XHJcbiAgICAgICAgdmFyIGRpZ2l0cyA9IFtdO1xyXG4gICAgICAgIHZhciBpc05lZ2F0aXZlID0gdGV4dFswXSA9PT0gXCItXCI7XHJcbiAgICAgICAgZm9yIChpID0gaXNOZWdhdGl2ZSA/IDEgOiAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRleHRbaV07XHJcbiAgICAgICAgICAgIGlmIChjIGluIGFscGhhYmV0VmFsdWVzKSBkaWdpdHMucHVzaChwYXJzZVZhbHVlKGFscGhhYmV0VmFsdWVzW2NdKSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPFwiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgZG8geyBpKys7IH0gd2hpbGUgKHRleHRbaV0gIT09IFwiPlwiICYmIGkgPCB0ZXh0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBkaWdpdHMucHVzaChwYXJzZVZhbHVlKHRleHQuc2xpY2Uoc3RhcnQgKyAxLCBpKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKGMgKyBcIiBpcyBub3QgYSB2YWxpZCBjaGFyYWN0ZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLCBiYXNlLCBpc05lZ2F0aXZlKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VCYXNlRnJvbUFycmF5KGRpZ2l0cywgYmFzZSwgaXNOZWdhdGl2ZSkge1xyXG4gICAgICAgIHZhciB2YWwgPSBJbnRlZ2VyWzBdLCBwb3cgPSBJbnRlZ2VyWzFdLCBpO1xyXG4gICAgICAgIGZvciAoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YWwgPSB2YWwuYWRkKGRpZ2l0c1tpXS50aW1lcyhwb3cpKTtcclxuICAgICAgICAgICAgcG93ID0gcG93LnRpbWVzKGJhc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNOZWdhdGl2ZSA/IHZhbC5uZWdhdGUoKSA6IHZhbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoZGlnaXQsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgYWxwaGFiZXQgPSBhbHBoYWJldCB8fCBERUZBVUxUX0FMUEhBQkVUO1xyXG4gICAgICAgIGlmIChkaWdpdCA8IGFscGhhYmV0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbZGlnaXRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCI8XCIgKyBkaWdpdCArIFwiPlwiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvQmFzZShuLCBiYXNlKSB7XHJcbiAgICAgICAgYmFzZSA9IGJpZ0ludChiYXNlKTtcclxuICAgICAgICBpZiAoYmFzZS5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIHsgdmFsdWU6IFswXSwgaXNOZWdhdGl2ZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgbm9uemVybyBudW1iZXJzIHRvIGJhc2UgMC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiYXNlLmVxdWFscygtMSkpIHtcclxuICAgICAgICAgICAgaWYgKG4uaXNaZXJvKCkpIHJldHVybiB7IHZhbHVlOiBbMF0sIGlzTmVnYXRpdmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgIGlmIChuLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtdLmNvbmNhdC5hcHBseShbXSwgQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoLW4udG9KU051bWJlcigpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChBcnJheS5wcm90b3R5cGUudmFsdWVPZiwgWzEsIDBdKVxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNOZWdhdGl2ZTogZmFsc2VcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgYXJyID0gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkobi50b0pTTnVtYmVyKCkgLSAxKSlcclxuICAgICAgICAgICAgICAgIC5tYXAoQXJyYXkucHJvdG90eXBlLnZhbHVlT2YsIFswLCAxXSk7XHJcbiAgICAgICAgICAgIGFyci51bnNoaWZ0KFsxXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogW10uY29uY2F0LmFwcGx5KFtdLCBhcnIpLFxyXG4gICAgICAgICAgICAgICAgaXNOZWdhdGl2ZTogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBuZWcgPSBmYWxzZTtcclxuICAgICAgICBpZiAobi5pc05lZ2F0aXZlKCkgJiYgYmFzZS5pc1Bvc2l0aXZlKCkpIHtcclxuICAgICAgICAgICAgbmVnID0gdHJ1ZTtcclxuICAgICAgICAgICAgbiA9IG4uYWJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiYXNlLmlzVW5pdCgpKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4geyB2YWx1ZTogWzBdLCBpc05lZ2F0aXZlOiBmYWxzZSB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBBcnJheS5hcHBseShudWxsLCBBcnJheShuLnRvSlNOdW1iZXIoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsIDEpLFxyXG4gICAgICAgICAgICAgICAgaXNOZWdhdGl2ZTogbmVnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXQgPSBbXTtcclxuICAgICAgICB2YXIgbGVmdCA9IG4sIGRpdm1vZDtcclxuICAgICAgICB3aGlsZSAobGVmdC5pc05lZ2F0aXZlKCkgfHwgbGVmdC5jb21wYXJlQWJzKGJhc2UpID49IDApIHtcclxuICAgICAgICAgICAgZGl2bW9kID0gbGVmdC5kaXZtb2QoYmFzZSk7XHJcbiAgICAgICAgICAgIGxlZnQgPSBkaXZtb2QucXVvdGllbnQ7XHJcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IGRpdm1vZC5yZW1haW5kZXI7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdC5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIGRpZ2l0ID0gYmFzZS5taW51cyhkaWdpdCkuYWJzKCk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5uZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0LnB1c2goZGlnaXQudG9KU051bWJlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0LnB1c2gobGVmdC50b0pTTnVtYmVyKCkpO1xyXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvdXQucmV2ZXJzZSgpLCBpc05lZ2F0aXZlOiBuZWcgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0Jhc2VTdHJpbmcobiwgYmFzZSwgYWxwaGFiZXQpIHtcclxuICAgICAgICB2YXIgYXJyID0gdG9CYXNlKG4sIGJhc2UpO1xyXG4gICAgICAgIHJldHVybiAoYXJyLmlzTmVnYXRpdmUgPyBcIi1cIiA6IFwiXCIpICsgYXJyLnZhbHVlLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHgsIGFscGhhYmV0KTtcclxuICAgICAgICB9KS5qb2luKCcnKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKHJhZGl4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRvQmFzZSh0aGlzLCByYWRpeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChyYWRpeCkge1xyXG4gICAgICAgIHJldHVybiB0b0Jhc2UodGhpcywgcmFkaXgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgICByZXR1cm4gdG9CYXNlKHRoaXMsIHJhZGl4KTtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgaWYgKHJhZGl4ID09PSB1bmRlZmluZWQpIHJhZGl4ID0gMTA7XHJcbiAgICAgICAgaWYgKHJhZGl4ICE9PSAxMCB8fCBhbHBoYWJldCkgcmV0dXJuIHRvQmFzZVN0cmluZyh0aGlzLCByYWRpeCwgYWxwaGFiZXQpO1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy52YWx1ZSwgbCA9IHYubGVuZ3RoLCBzdHIgPSBTdHJpbmcodlstLWxdKSwgemVyb3MgPSBcIjAwMDAwMDBcIiwgZGlnaXQ7XHJcbiAgICAgICAgd2hpbGUgKC0tbCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGRpZ2l0ID0gU3RyaW5nKHZbbF0pO1xyXG4gICAgICAgICAgICBzdHIgKz0gemVyb3Muc2xpY2UoZGlnaXQubGVuZ3RoKSArIGRpZ2l0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2lnbiA9IHRoaXMuc2lnbiA/IFwiLVwiIDogXCJcIjtcclxuICAgICAgICByZXR1cm4gc2lnbiArIHN0cjtcclxuICAgIH07XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChyYWRpeCwgYWxwaGFiZXQpIHtcclxuICAgICAgICBpZiAocmFkaXggPT09IHVuZGVmaW5lZCkgcmFkaXggPSAxMDtcclxuICAgICAgICBpZiAocmFkaXggIT0gMTAgfHwgYWxwaGFiZXQpIHJldHVybiB0b0Jhc2VTdHJpbmcodGhpcywgcmFkaXgsIGFscGhhYmV0KTtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMudmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnRvU3RyaW5nID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZztcclxuXHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnRvSlNPTiA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnRvSlNPTiA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50b1N0cmluZygpOyB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy50b1N0cmluZygpLCAxMCk7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9KU051bWJlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnZhbHVlT2Y7XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9KU051bWJlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZjtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudmFsdWVPZiA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudG9KU051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy50b1N0cmluZygpLCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmdWYWx1ZSh2KSB7XHJcbiAgICAgICAgaWYgKGlzUHJlY2lzZSgrdikpIHtcclxuICAgICAgICAgICAgdmFyIHggPSArdjtcclxuICAgICAgICAgICAgaWYgKHggPT09IHRydW5jYXRlKHgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRzTmF0aXZlQmlnSW50ID8gbmV3IE5hdGl2ZUJpZ0ludChCaWdJbnQoeCkpIDogbmV3IFNtYWxsSW50ZWdlcih4KTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2lnbiA9IHZbMF0gPT09IFwiLVwiO1xyXG4gICAgICAgIGlmIChzaWduKSB2ID0gdi5zbGljZSgxKTtcclxuICAgICAgICB2YXIgc3BsaXQgPSB2LnNwbGl0KC9lL2kpO1xyXG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAyKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgc3BsaXQuam9pbihcImVcIikpO1xyXG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgdmFyIGV4cCA9IHNwbGl0WzFdO1xyXG4gICAgICAgICAgICBpZiAoZXhwWzBdID09PSBcIitcIikgZXhwID0gZXhwLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICBleHAgPSArZXhwO1xyXG4gICAgICAgICAgICBpZiAoZXhwICE9PSB0cnVuY2F0ZShleHApIHx8ICFpc1ByZWNpc2UoZXhwKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIGV4cCArIFwiIGlzIG5vdCBhIHZhbGlkIGV4cG9uZW50LlwiKTtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSBzcGxpdFswXTtcclxuICAgICAgICAgICAgdmFyIGRlY2ltYWxQbGFjZSA9IHRleHQuaW5kZXhPZihcIi5cIik7XHJcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGxhY2UgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgZXhwIC09IHRleHQubGVuZ3RoIC0gZGVjaW1hbFBsYWNlIC0gMTtcclxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIGRlY2ltYWxQbGFjZSkgKyB0ZXh0LnNsaWNlKGRlY2ltYWxQbGFjZSArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChleHAgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5jbHVkZSBuZWdhdGl2ZSBleHBvbmVudCBwYXJ0IGZvciBpbnRlZ2Vyc1wiKTtcclxuICAgICAgICAgICAgdGV4dCArPSAobmV3IEFycmF5KGV4cCArIDEpKS5qb2luKFwiMFwiKTtcclxuICAgICAgICAgICAgdiA9IHRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpc1ZhbGlkID0gL14oWzAtOV1bMC05XSopJC8udGVzdCh2KTtcclxuICAgICAgICBpZiAoIWlzVmFsaWQpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIgKyB2KTtcclxuICAgICAgICBpZiAoc3VwcG9ydHNOYXRpdmVCaWdJbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQoQmlnSW50KHNpZ24gPyBcIi1cIiArIHYgOiB2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByID0gW10sIG1heCA9IHYubGVuZ3RoLCBsID0gTE9HX0JBU0UsIG1pbiA9IG1heCAtIGw7XHJcbiAgICAgICAgd2hpbGUgKG1heCA+IDApIHtcclxuICAgICAgICAgICAgci5wdXNoKCt2LnNsaWNlKG1pbiwgbWF4KSk7XHJcbiAgICAgICAgICAgIG1pbiAtPSBsO1xyXG4gICAgICAgICAgICBpZiAobWluIDwgMCkgbWluID0gMDtcclxuICAgICAgICAgICAgbWF4IC09IGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaW0ocik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHIsIHNpZ24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlTnVtYmVyVmFsdWUodikge1xyXG4gICAgICAgIGlmIChzdXBwb3J0c05hdGl2ZUJpZ0ludCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludChCaWdJbnQodikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNQcmVjaXNlKHYpKSB7XHJcbiAgICAgICAgICAgIGlmICh2ICE9PSB0cnVuY2F0ZSh2KSkgdGhyb3cgbmV3IEVycm9yKHYgKyBcIiBpcyBub3QgYW4gaW50ZWdlci5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmdWYWx1ZSh2LnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1iZXJWYWx1ZSh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1ZhbHVlKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwiYmlnaW50XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfVxyXG4gICAgLy8gUHJlLWRlZmluZSBudW1iZXJzIGluIHJhbmdlIFstOTk5LDk5OV1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XHJcbiAgICAgICAgSW50ZWdlcltpXSA9IHBhcnNlVmFsdWUoaSk7XHJcbiAgICAgICAgaWYgKGkgPiAwKSBJbnRlZ2VyWy1pXSA9IHBhcnNlVmFsdWUoLWkpO1xyXG4gICAgfVxyXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuICAgIEludGVnZXIub25lID0gSW50ZWdlclsxXTtcclxuICAgIEludGVnZXIuemVybyA9IEludGVnZXJbMF07XHJcbiAgICBJbnRlZ2VyLm1pbnVzT25lID0gSW50ZWdlclstMV07XHJcbiAgICBJbnRlZ2VyLm1heCA9IG1heDtcclxuICAgIEludGVnZXIubWluID0gbWluO1xyXG4gICAgSW50ZWdlci5nY2QgPSBnY2Q7XHJcbiAgICBJbnRlZ2VyLmxjbSA9IGxjbTtcclxuICAgIEludGVnZXIuaXNJbnN0YW5jZSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgQmlnSW50ZWdlciB8fCB4IGluc3RhbmNlb2YgU21hbGxJbnRlZ2VyIHx8IHggaW5zdGFuY2VvZiBOYXRpdmVCaWdJbnQ7IH07XHJcbiAgICBJbnRlZ2VyLnJhbmRCZXR3ZWVuID0gcmFuZEJldHdlZW47XHJcblxyXG4gICAgSW50ZWdlci5mcm9tQXJyYXkgPSBmdW5jdGlvbiAoZGlnaXRzLCBiYXNlLCBpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMubWFwKHBhcnNlVmFsdWUpLCBwYXJzZVZhbHVlKGJhc2UgfHwgMTApLCBpc05lZ2F0aXZlKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEludGVnZXI7XHJcbn0pKCk7XHJcblxyXG4vLyBOb2RlLmpzIGNoZWNrXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5oYXNPd25Qcm9wZXJ0eShcImV4cG9ydHNcIikpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gYmlnSW50O1xyXG59XHJcblxyXG4vL2FtZCBjaGVja1xyXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZSggZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBiaWdJbnQ7XHJcbiAgICB9KTtcclxufVxyXG4iXSwibmFtZXMiOlsiYmlnSW50IiwidW5kZWZpbmVkIiwiQkFTRSIsIkxPR19CQVNFIiwiTUFYX0lOVCIsIk1BWF9JTlRfQVJSIiwic21hbGxUb0FycmF5IiwiREVGQVVMVF9BTFBIQUJFVCIsInN1cHBvcnRzTmF0aXZlQmlnSW50IiwiQmlnSW50IiwiSW50ZWdlciIsInYiLCJyYWRpeCIsImFscGhhYmV0IiwiY2FzZVNlbnNpdGl2ZSIsInBhcnNlVmFsdWUiLCJwYXJzZUJhc2UiLCJCaWdJbnRlZ2VyIiwidmFsdWUiLCJzaWduIiwiaXNTbWFsbCIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsIlNtYWxsSW50ZWdlciIsIk5hdGl2ZUJpZ0ludCIsImlzUHJlY2lzZSIsIm4iLCJNYXRoIiwiZmxvb3IiLCJhcnJheVRvU21hbGwiLCJhcnIiLCJ0cmltIiwibGVuZ3RoIiwiY29tcGFyZUFicyIsImkiLCJjcmVhdGVBcnJheSIsIngiLCJBcnJheSIsInRydW5jYXRlIiwiY2VpbCIsImFkZCIsImEiLCJiIiwibF9hIiwibF9iIiwiciIsImNhcnJ5IiwiYmFzZSIsInN1bSIsInB1c2giLCJhZGRBbnkiLCJhZGRTbWFsbCIsImwiLCJzdWJ0cmFjdCIsIm5lZ2F0ZSIsImFicyIsInBsdXMiLCJhX2wiLCJiX2wiLCJib3Jyb3ciLCJkaWZmZXJlbmNlIiwic3VidHJhY3RBbnkiLCJzdWJ0cmFjdFNtYWxsIiwibWludXMiLCJzbWFsbCIsIm11bHRpcGx5TG9uZyIsInByb2R1Y3QiLCJhX2kiLCJiX2oiLCJqIiwibXVsdGlwbHlTbWFsbCIsInNoaWZ0TGVmdCIsImNvbmNhdCIsIm11bHRpcGx5S2FyYXRzdWJhIiwieSIsIm1heCIsInNsaWNlIiwiZCIsImMiLCJhYyIsImJkIiwiYWJjZCIsInVzZUthcmF0c3ViYSIsImwxIiwibDIiLCJtdWx0aXBseSIsInRpbWVzIiwibXVsdGlwbHlTbWFsbEFuZEFycmF5IiwiX211bHRpcGx5QnlTbWFsbCIsInNxdWFyZSIsImFfaiIsImRpdk1vZDEiLCJyZXN1bHQiLCJkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQiLCJsYW1iZGEiLCJyZW1haW5kZXIiLCJkaXZpc29yIiwicXVvdGllbnREaWdpdCIsInNoaWZ0IiwicSIsImRpdk1vZFNtYWxsIiwiZGl2TW9kMiIsInBhcnQiLCJndWVzcyIsInhsZW4iLCJoaWdoeCIsImhpZ2h5IiwiY2hlY2siLCJ1bnNoaWZ0IiwicmV2ZXJzZSIsInF1b3RpZW50IiwiZGl2TW9kQW55Iiwic2VsZiIsIkVycm9yIiwiY29tcGFyaXNvbiIsInFTaWduIiwibW9kIiwibVNpZ24iLCJkaXZtb2QiLCJkaXZpZGUiLCJvdmVyIiwicG93IiwiaXNFdmVuIiwidG9TdHJpbmciLCJfMCIsIl8xIiwiXzIiLCJpc05lZ2F0aXZlIiwibW9kUG93IiwiZXhwIiwiaXNaZXJvIiwibW9kSW52IiwiaXNQb3NpdGl2ZSIsImlzT2RkIiwiY29tcGFyZSIsIkluZmluaXR5IiwiY29tcGFyZVRvIiwiZXF1YWxzIiwiZXEiLCJub3RFcXVhbHMiLCJuZXEiLCJncmVhdGVyIiwiZ3QiLCJsZXNzZXIiLCJsdCIsImdyZWF0ZXJPckVxdWFscyIsImdlcSIsImxlc3Nlck9yRXF1YWxzIiwibGVxIiwiaXNVbml0IiwiaXNEaXZpc2libGVCeSIsImlzQmFzaWNQcmltZSIsIm1pbGxlclJhYmluVGVzdCIsIm5QcmV2IiwicHJldiIsInQiLCJuZXh0IiwiaXNQcmltZSIsInN0cmljdCIsImJpdHMiLCJiaXRMZW5ndGgiLCJsb2dOIiwibG9nIiwidG9KU051bWJlciIsImlzUHJvYmFibGVQcmltZSIsIml0ZXJhdGlvbnMiLCJybmciLCJyYW5kQmV0d2VlbiIsInplcm8iLCJuZXdUIiwib25lIiwibmV3UiIsImxhc3RUIiwibGFzdFIiLCJwb3dlcnNPZlR3byIsInBvd2VyczJMZW5ndGgiLCJoaWdoZXN0UG93ZXIyIiwic2hpZnRfaXNTbWFsbCIsIlN0cmluZyIsInNoaWZ0UmlnaHQiLCJyZW1RdW8iLCJiaXR3aXNlIiwiZm4iLCJ4U2lnbiIsInlTaWduIiwieFJlbSIsIm5vdCIsInlSZW0iLCJ4RGlnaXQiLCJ5RGlnaXQiLCJ4RGl2TW9kIiwieURpdk1vZCIsImFuZCIsIm9yIiwieG9yIiwiTE9CTUFTS19JIiwiTE9CTUFTS19CSSIsInJvdWdoTE9CIiwiaW50ZWdlckxvZ2FyaXRobSIsInRtcCIsInAiLCJlIiwibWluIiwiZ2NkIiwibGNtIiwidXNlZFJORyIsInJhbmRvbSIsImxvdyIsImhpZ2giLCJyYW5nZSIsImRpZ2l0cyIsInRvQmFzZSIsInJlc3RyaWN0ZWQiLCJ0b3AiLCJkaWdpdCIsImZyb21BcnJheSIsInRleHQiLCJ0b0xvd2VyQ2FzZSIsImFic0Jhc2UiLCJhbHBoYWJldFZhbHVlcyIsInN0YXJ0IiwicGFyc2VCYXNlRnJvbUFycmF5IiwidmFsIiwic3RyaW5naWZ5IiwiYXBwbHkiLCJtYXAiLCJ2YWx1ZU9mIiwibmVnIiwiTnVtYmVyIiwib3V0IiwibGVmdCIsInRvQmFzZVN0cmluZyIsImpvaW4iLCJ0b0FycmF5Iiwic3RyIiwiemVyb3MiLCJ0b0pTT04iLCJwYXJzZUludCIsInBhcnNlU3RyaW5nVmFsdWUiLCJzcGxpdCIsImRlY2ltYWxQbGFjZSIsImluZGV4T2YiLCJpc1ZhbGlkIiwidGVzdCIsInBhcnNlTnVtYmVyVmFsdWUiLCJtaW51c09uZSIsImlzSW5zdGFuY2UiLCJtb2R1bGUiLCJoYXNPd25Qcm9wZXJ0eSIsImV4cG9ydHMiLCJkZWZpbmUiLCJhbWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/big-integer/BigInteger.js\n");

/***/ })

};
;